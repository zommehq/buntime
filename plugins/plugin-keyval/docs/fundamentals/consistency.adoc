== Modelo de Consistência

Este documento descreve as garantias de consistência do KeyVal, inspirado nas documentações do https://github.com/tursodatabase/libsql/blob/main/docs/CONSISTENCY_MODEL.md[libSQL] e https://docs.deno.com/deploy/kv/manual/[Deno KV].

=== Fundamentos

==== Transações SQLite

O KeyVal herda as garantias transacionais do SQLite/libSQL:

- **Serializable Isolation**: Transações são executadas como se fossem sequenciais
- **Atomicidade**: Todas as operações de uma transação completam ou nenhuma completa
- **Durabilidade**: Dados commitados sobrevivem a falhas

==== Optimistic Concurrency Control (OCC)

O KeyVal usa OCC em vez de locks pessimistas:

[source]
----
┌─────────────────────────────────────────────────────────────┐
│                 Pessimistic Locking                          │
├─────────────────────────────────────────────────────────────┤
│  1. BEGIN TRANSACTION                                        │
│  2. SELECT ... FOR UPDATE  ← Lock adquirido                  │
│  3. UPDATE ...                                               │
│  4. COMMIT                 ← Lock liberado                   │
│                                                              │
│  Problema: Outros clientes bloqueados durante todo o tempo   │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                 Optimistic Concurrency (KeyVal)              │
├─────────────────────────────────────────────────────────────┤
│  1. GET key → {value, versionstamp}  ← Sem lock             │
│  2. (Processamento local)                                    │
│  3. ATOMIC                                                   │
│       CHECK(key, versionstamp)       ← Verifica se mudou    │
│       SET(key, newValue)                                     │
│     COMMIT                                                   │
│                                                              │
│  Se versionstamp mudou: conflito → retry                     │
│  Se igual: commit bem-sucedido                               │
└─────────────────────────────────────────────────────────────┘
----

**Vantagens do OCC:**

- Sem bloqueio durante leituras
- Melhor throughput para cargas read-heavy
- Sem deadlocks

**Desvantagens:**

- Retries em caso de conflito
- Overhead de versionstamp em cada operação

==== Versionstamps

Cada entrada no KeyVal tem um `versionstamp` - um identificador único que muda a cada modificação:

[source,typescript]
----
interface KvEntry<T> {
  key: KvKey;
  value: T | null;
  versionstamp: string | null;  // UUIDv7 - ordenável por tempo
}
----

**Características:**

- Gerado como UUIDv7 (time-ordered UUID)
- Único globalmente
- Crescente monotonicamente no tempo
- Usado para detecção de conflitos em `atomic().check()`

=== Modos de Consistência

O KeyVal suporta dois modos de consistência para operações de leitura:

[cols="1,2,2"]
|===
| Modo | Descrição | Quando usar

| `strong` (padrão)
| Sempre lê do nó primário, garantindo o valor mais recente
| Operações críticas que precisam do dado mais atual

| `eventual`
| Pode ler de uma réplica, com menor latência mas possível atraso
| Dashboards, caches, dados que não mudam frequentemente
|===

NOTE: O modo `eventual` só funciona quando o plugin está configurado com `libsqlReplicaUrl`. Caso contrário, todas as leituras usam o primário.

=== Configuração

==== Docker Compose (Desenvolvimento)

Para simular replicação localmente:

[source,yaml]
----
services:
  libsql:
    image: ghcr.io/tursodatabase/libsql-server:latest
    ports:
      - "8880:8080" # HTTP API
      - "8881:5001" # gRPC (replicação)
    environment:
      SQLD_NODE: primary
      SQLD_HTTP_LISTEN_ADDR: 0.0.0.0:8080
      SQLD_GRPC_LISTEN_ADDR: 0.0.0.0:5001
      SQLD_DISABLE_AUTH: "true"

  libsql-replica:
    image: ghcr.io/tursodatabase/libsql-server:latest
    ports:
      - "8882:8080" # HTTP API (replica)
    environment:
      SQLD_NODE: replica
      SQLD_PRIMARY_URL: http://libsql:5001
      SQLD_HTTP_LISTEN_ADDR: 0.0.0.0:8080
      SQLD_DISABLE_AUTH: "true"
    depends_on:
      - libsql
----

==== Configuração do Plugin

[source,jsonc]
----
{
  "plugins": [
    ["@buntime/plugin-keyval", {
      "libsqlUrl": "${LIBSQL_URL}",           // Primary: http://localhost:8880
      "libsqlReplicaUrl": "${LIBSQL_REPLICA_URL}", // Replica: http://localhost:8882
      "libsqlToken": "${LIBSQL_TOKEN}"
    }]
  ]
}
----

==== Variáveis de Ambiente

[source,bash]
----
# Desenvolvimento local
LIBSQL_URL=http://localhost:8880
LIBSQL_REPLICA_URL=http://localhost:8882

# Produção (libSQL self-hosted)
LIBSQL_URL=http://libsql-primary:8080
LIBSQL_REPLICA_URL=http://libsql-replica:8080
LIBSQL_TOKEN=your-jwt-token
----

=== Uso

==== Strong Consistency (Padrão)

[source,typescript]
----
// Leitura do primário - sempre o valor mais recente
const entry = await kv.get(["users", 123]);

// Explicitamente strong
const entry = await kv.get(["users", 123], { consistency: "strong" });

// List também suporta
for await (const entry of kv.list(["users"], { consistency: "strong" })) {
  console.log(entry);
}
----

==== Eventual Consistency

[source,typescript]
----
// Leitura da réplica - menor latência, possivelmente desatualizado
const entry = await kv.get(["users", 123], { consistency: "eventual" });

// List com eventual consistency
for await (const entry of kv.list(["metrics"], { consistency: "eventual" })) {
  console.log(entry);
}
----

=== Exemplos

==== Dashboard de Métricas

Métricas não precisam ser 100% atuais, então eventual consistency é ideal:

[source,typescript]
----
interface DashboardMetrics {
  activeUsers: number;
  requestsPerSecond: number;
  errorRate: number;
}

async function getDashboardMetrics(): Promise<DashboardMetrics> {
  const entries = [];

  for await (const entry of kv.list<number>({
    prefix: ["metrics"],
    consistency: "eventual", // OK se dados tiverem alguns ms de atraso
  })) {
    entries.push(entry);
  }

  return {
    activeUsers: entries.find(e => e.key[1] === "active_users")?.value ?? 0,
    requestsPerSecond: entries.find(e => e.key[1] === "rps")?.value ?? 0,
    errorRate: entries.find(e => e.key[1] === "error_rate")?.value ?? 0,
  };
}
----

==== Operação Crítica de Pagamento

Para operações críticas, use strong consistency:

[source,typescript]
----
interface UserBalance {
  amount: number;
  currency: string;
}

async function processPayment(userId: string, amount: number): Promise<boolean> {
  // SEMPRE usar strong para operações financeiras
  const entry = await kv.get<UserBalance>(
    ["balances", userId],
    { consistency: "strong" }
  );

  if (!entry.value || entry.value.amount < amount) {
    return false; // Saldo insuficiente
  }

  // Usar atomic com check para garantir consistência
  const result = await kv.atomic()
    .check({ key: ["balances", userId], versionstamp: entry.versionstamp })
    .set(["balances", userId], {
      ...entry.value,
      amount: entry.value.amount - amount,
    })
    .commit();

  return result.ok;
}
----

==== Cache de Configurações

Configurações que raramente mudam são ótimas para eventual consistency:

[source,typescript]
----
interface AppConfig {
  featureFlags: Record<string, boolean>;
  maintenanceMode: boolean;
  version: string;
}

// Cache local com refresh periódico
let cachedConfig: AppConfig | null = null;
let lastFetch = 0;
const CACHE_TTL = 30_000; // 30 segundos

async function getConfig(): Promise<AppConfig> {
  const now = Date.now();

  if (cachedConfig && now - lastFetch < CACHE_TTL) {
    return cachedConfig;
  }

  // Eventual consistency é ok para config
  const entry = await kv.get<AppConfig>(
    ["config", "app"],
    { consistency: "eventual" }
  );

  if (entry.value) {
    cachedConfig = entry.value;
    lastFetch = now;
  }

  return cachedConfig ?? getDefaultConfig();
}
----

==== Leitura Híbrida

Combine ambos os modos conforme a necessidade:

[source,typescript]
----
interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
}

async function getProductDetails(productId: string): Promise<{
  product: Product | null;
  currentStock: number;
}> {
  // Dados do produto podem ser eventual (nome, descrição raramente mudam)
  const product = await kv.get<Product>(
    ["products", productId],
    { consistency: "eventual" }
  );

  // Estoque precisa ser strong (muda frequentemente, crítico para compras)
  const stock = await kv.get<number>(
    ["stock", productId],
    { consistency: "strong" }
  );

  return {
    product: product.value,
    currentStock: stock.value ?? 0,
  };
}
----

=== Como Funciona

==== Arquitetura

[source]
----
┌─────────────────────────────────────────────────────────────┐
│                        Aplicação                            │
│                   kv.get(key, options)                      │
└─────────────────────┬───────────────────────────────────────┘
                      │
                      ▼ consistency="strong" (padrão)
┌─────────────────────────────────────────────────────────────┐
│                 @buntime/plugin-keyval                      │
│                                                             │
│   ┌──────────────┐              ┌──────────────┐           │
│   │ Primary      │◄─────────────│ Replica      │           │
│   │ Client       │  replicação  │ Client       │           │
│   └──────┬───────┘              └──────┬───────┘           │
│          │                              │                   │
│          │ consistency="strong"         │ consistency="eventual"
│          ▼                              ▼                   │
│   ┌──────────────┐              ┌──────────────┐           │
│   │ libSQL       │              │ libSQL       │           │
│   │ Primary      │─────────────►│ Replica      │           │
│   │ :8880        │    gRPC      │ :8882        │           │
│   └──────────────┘              └──────────────┘           │
└─────────────────────────────────────────────────────────────┘
----

==== Latência de Replicação

A replicação entre primary e replica tem latência típica de:

- **Mesmo host**: < 1ms
- **Mesma região**: 1-5ms
- **Cross-region**: 50-200ms

Ao usar `eventual`, você aceita que os dados podem estar desatualizados por esse período.

=== Boas Práticas

==== Quando Usar Strong

- Operações financeiras (pagamentos, saldos)
- Verificações de permissão/autenticação
- Dados que mudam frequentemente e precisam ser atuais
- Operações com `atomic()` que dependem do versionstamp

==== Quando Usar Eventual

- Dashboards e métricas
- Dados de perfil do usuário (nome, foto)
- Configurações e feature flags
- Caches e dados agregados
- Listagens que toleram atraso (catálogo de produtos)

==== Evite Misturar em Transações

[source,typescript]
----
// Evite: ler com eventual e depois usar em atomic
const entry = await kv.get(key, { consistency: "eventual" });
await kv.atomic()
  .check({ key, versionstamp: entry.versionstamp }) // versionstamp pode estar desatualizado!
  .set(key, newValue)
  .commit();

// Correto: use strong quando precisar do versionstamp
const entry = await kv.get(key, { consistency: "strong" });
await kv.atomic()
  .check({ key, versionstamp: entry.versionstamp })
  .set(key, newValue)
  .commit();
----

=== Limitações

==== Sem Replica Configurada

Se `libsqlReplicaUrl` não estiver configurado, todas as leituras usam o primário:

[source,typescript]
----
// Sem replica, ambos vão para o primário
await kv.get(key); // → primary
await kv.get(key, { consistency: "eventual" }); // → primary (fallback)
----

==== Escritas Sempre no Primário

Escritas (`set`, `delete`, `atomic`) sempre vão para o primário, independente do consistency mode:

[source,typescript]
----
// Escritas ignoram consistency (sempre strong)
await kv.set(key, value); // → primary
await kv.delete(key);     // → primary
await kv.atomic()...      // → primary
----

=== Garantias de Visibilidade

==== Read-Your-Writes

Dentro de uma mesma conexão, você sempre vê suas próprias escritas:

[source,typescript]
----
await kv.set(["counter"], 1);
const entry = await kv.get(["counter"]);
// entry.value === 1 (garantido)
----

==== Monotonic Reads

Uma vez que você leu um valor, leituras subsequentes nunca retornam valores mais antigos:

[source,typescript]
----
// Leitura 1: valor versão V5
const entry1 = await kv.get(["data"], { consistency: "eventual" });

// Leitura 2: nunca retorna versão < V5
const entry2 = await kv.get(["data"], { consistency: "eventual" });
----

==== Causal Consistency

O KeyVal **não** garante consistência causal entre clientes diferentes:

[source,typescript]
----
// Cliente A
await kv.set(["flag"], true);
await notifyClientB(); // Notifica via canal externo

// Cliente B (pode não ver a escrita ainda!)
const flag = await kv.get(["flag"], { consistency: "eventual" });
// flag.value pode ser false se replicação não completou
----

Para garantir visibilidade entre clientes, use `consistency: "strong"` ou implemente sincronização explícita.

==== Ordenação Global

Não há garantia de ordenação global entre operações independentes:

[source,typescript]
----
// Operações em paralelo - ordem não determinística
await Promise.all([
  kv.set(["a"], 1),
  kv.set(["b"], 2),
]);

// Outro cliente pode ver:
// - a=1, b=undefined
// - a=undefined, b=2
// - a=1, b=2
// - a=undefined, b=undefined
----

Para ordenação garantida, use operações atômicas:

[source,typescript]
----
await kv.atomic()
  .set(["a"], 1)
  .set(["b"], 2)
  .commit();

// Agora ambos são visíveis atomicamente
----

=== Comparação com Deno KV

O KeyVal foi inspirado no Deno KV e busca compatibilidade de API. Esta tabela compara as funcionalidades:

[cols="2,1,1,2"]
|===
| Funcionalidade | KeyVal | Deno KV | Notas

| *Operações Básicas*
|
|
|

| get
| Sim
| Sim
| Idêntico

| getMany
| Sim
| Sim
| Idêntico

| set
| Sim
| Sim
| Idêntico

| delete
| Sim
| Sim
| Idêntico

| list (prefixo)
| Sim
| Sim
| Idêntico

| list (range)
| Sim
| Sim
| start/end keys

| *Transações*
|
|
|

| atomic()
| Sim
| Sim
| OCC com versionstamps

| check()
| Sim
| Sim
| Verifica versionstamp

| sum()
| Sim
| Sim
| Contadores atômicos

| max()
| Sim
| Sim
| Máximo atômico

| min()
| Sim
| Sim
| Mínimo atômico

| *Consistência*
|
|
|

| Strong (padrão)
| Sim
| Sim
| Leitura do primário

| Eventual
| Sim (com réplica)
| Sim
| Leitura de réplica

| *Watch*
|
|
|

| watch keys
| Sim (polling)
| Sim (nativo)
| KeyVal usa polling 100ms

| watch prefix
| Sim (polling)
| Não
| Extensão do KeyVal

| *Filas*
|
|
|

| enqueue
| Sim
| Sim
| Idêntico

| listenQueue
| Sim
| Sim
| Idêntico

| delay
| Sim
| Sim
| Agendamento futuro

| keysIfUndelivered (DLQ)
| Sim
| Sim
| Dead Letter Queue

| backoffSchedule
| Sim
| Sim
| Retry customizado

| *Expiração*
|
|
|

| expireIn
| Sim
| Sim
| TTL em milissegundos

| expireAt
| Sim
| Sim
| Timestamp absoluto

| *Filtros (where)*
|
|
|

| Filtros em list()
| Sim
| Não
| Extensão do KeyVal

| *Busca Textual*
|
|
|

| Full-text search (FTS5)
| Sim
| Não
| Extensão do KeyVal

| *Limites*
|
|
|

| Checks por atomic
| 1000
| 100
| KeyVal mais permissivo

| Mutations por atomic
| 1000
| 1000
| Idêntico

| Tamanho de chave
| ~20KB
| 2KB
| KeyVal mais permissivo

| Tamanho de valor
| Sem limite rígido
| 64KB
| KeyVal usa libSQL

| *Backend*
|
|
|

| Produção
| libSQL (sqld)
| FoundationDB
| Arquiteturas diferentes

| Local
| libSQL (sqld)
| SQLite
| KeyVal sempre usa libSQL
|===

=== Comparação com Outros Sistemas

[cols="1,1,1,1"]
|===
| Sistema | Consistência Padrão | Suporta Eventual | Modelo de Conflito

| KeyVal
| Strong
| Sim (com réplica)
| OCC com versionstamps

| Deno KV
| Strong
| Sim
| OCC com versionstamps

| Redis
| Eventual (cluster)
| Sempre
| Last-write-wins

| DynamoDB
| Eventual
| Strong opcional
| Conditional writes

| PostgreSQL
| Strong
| Não
| Pessimistic locking
|===

=== Referências

- https://github.com/tursodatabase/libsql/blob/main/docs/CONSISTENCY_MODEL.md[libSQL Consistency Model]
- https://docs.deno.com/deploy/kv/manual/[Deno KV Manual]
- https://github.com/denoland/docs/tree/main/deploy/kv[Deno KV Documentation Source]
- https://jepsen.io/consistency[Jepsen Consistency Models]
