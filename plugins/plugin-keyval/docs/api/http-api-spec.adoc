:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

== HTTP API Specification

Esta seção documenta a API REST completa do plugin KeyVal, incluindo todos os endpoints disponíveis, parâmetros, schemas de requisição/resposta e exemplos de uso.

=== Configuração Base

[cols="1,2"]
|===
| Item | Valor

| Base Path
| `/api/keyval`

| Content-Type
| `application/json`

| Formato de Erro
| `{"error": "mensagem"}`

| Códigos HTTP
| 200 (sucesso), 400 (validação), 404 (não encontrado), 500 (erro interno)
|===

=== Keys API

==== GET /keys/:key

Obtém um único valor por chave.

**Resposta (200):**

[source,typescript]
----
{
  "key": ["users", "123"],
  "value": {"name": "João", "email": "joao@example.com"},
  "versionstamp": "00000000000000010000"
}
----

**Resposta (404):**

[source,json]
----
{
  "error": "Key not found"
}
----

**Exemplo:**

[source,bash]
----
curl -X GET "http://localhost:4000/api/keyval/keys/users/123"
----

==== POST /keys/batch

Obtém múltiplos valores em uma única requisição (batch get).

**Request Body:**

[source,typescript]
----
{
  "keys": [
    ["users", "123"],
    ["posts", "456"]
  ]
}
----

**Resposta (200):**

[source,typescript]
----
[
  {
    "key": ["users", "123"],
    "value": {"name": "João"},
    "versionstamp": "00000000000000010000"
  },
  {
    "key": ["posts", "456"],
    "value": null,
    "versionstamp": null
  }
]
----

NOTE: Quando uma chave não existe, o retorno contém `value: null` e `versionstamp: null`. A ordem das respostas corresponde à ordem das chaves solicitadas.

**Validação:**

- Máximo de 1000 chaves por requisição
- Cada chave deve ter no máximo 20 partes

**Exemplo:**

[source,bash]
----
curl -X POST "http://localhost:4000/api/keyval/keys/batch" \
  -H "Content-Type: application/json" \
  -d '{"keys": [["users", "123"], ["posts", "456"]]}'

# Resposta inclui chaves existentes e não existentes
# [
#   {"key": ["users", "123"], "value": {...}, "versionstamp": "..."},
#   {"key": ["posts", "456"], "value": null, "versionstamp": null}
# ]
----

==== POST /keys/delete-batch

Remove múltiplas chaves em uma única requisição (batch delete).

**Request Body:**

[source,typescript]
----
{
  "keys": [
    ["users", "123"],
    ["posts", "456"],
    ["cache", "temp"]
  ],
  "exact": true,  // opcional: se true, deleta apenas chaves exatas (sem filhos)
  "where": {      // opcional: filtro aplicado a cada chave
    "status": "completed"
  }
}
----

**Resposta (200):**

[source,typescript]
----
{
  "deletedCount": 7  // total de entradas deletadas (incluindo filhos se exact=false)
}
----

**Validação:**

- Máximo de 1000 chaves por requisição
- Cada chave deve ter no máximo 20 partes
- `exact` e `where` são opcionais e aplicados a todas as chaves

NOTE: Quando `exact` é false ou omitido, cada chave é tratada como prefixo e todos os filhos também são deletados. O `deletedCount` retorna a soma total de todas as entradas removidas.

**Exemplo:**

[source,bash]
----
# Delete batch simples (remove chaves + filhos)
curl -X POST "http://localhost:4000/api/keyval/keys/delete-batch" \
  -H "Content-Type: application/json" \
  -d '{"keys": [["users", "123"], ["posts", "456"]]}'

# Delete batch exato (sem remover filhos)
curl -X POST "http://localhost:4000/api/keyval/keys/delete-batch" \
  -H "Content-Type: application/json" \
  -d '{
    "keys": [["users", "123"], ["posts", "456"]],
    "exact": true
  }'

# Delete batch com filtro WHERE
curl -X POST "http://localhost:4000/api/keyval/keys/delete-batch" \
  -H "Content-Type: application/json" \
  -d '{
    "keys": [["tasks"], ["jobs"]],
    "where": {"status": "completed"}
  }'
----

==== PUT /keys/:key

Define ou atualiza um valor.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| expiresIn
| number
| null
| TTL em milissegundos (máximo: 2147483647)
|===

**Request Body:**

Qualquer valor JSON serializável (será armazenado como `value`).

[source,typescript]
----
{
  "name": "João Silva",
  "email": "joao@example.com",
  "active": true
}
----

**Resposta (200):**

[source,typescript]
----
{
  "ok": true,
  "versionstamp": "00000000000000030000"
}
----

**Exemplo:**

[source,bash]
----
# Set sem TTL
curl -X PUT "http://localhost:4000/api/keyval/keys/users/123" \
  -H "Content-Type: application/json" \
  -d '{"name": "João", "email": "joao@example.com"}'

# Set com TTL de 1 hora (3600000 ms)
curl -X PUT "http://localhost:4000/api/keyval/keys/sessions/abc?expiresIn=3600000" \
  -H "Content-Type: application/json" \
  -d '{"userId": "123", "createdAt": 1234567890}'
----

==== DELETE /keys/:key

Remove uma chave específica ou múltiplas entradas por filtro WHERE.

**Modo 1: Delete simples (sem body)**

Sem body, deleta a chave fornecida na URL E todas as sub-chaves (filhos) que começam com esse prefixo.

NOTE: Por padrão, delete() remove a chave especificada E todas as sub-chaves (filhos). Por exemplo, deletar `["users", "123"]` irá remover também `["users", "123", "profile"]`, `["users", "123", "settings"]`, etc.

**Modo 2: Delete exato (com exact: true)**

Com body contendo `{"exact": true}`, deleta APENAS a chave exata sem remover filhos.

**Modo 3: Delete com filtro WHERE**

Com body contendo `where`, a chave na URL é tratada como **prefixo** e todas as entradas que correspondem ao filtro são deletadas em lote.

**Request Body (Opcional):**

[source,typescript]
----
{
  "exact": true,  // opcional: se true, deleta apenas a chave exata (sem filhos)
  "where": {      // opcional: filtro para delete em lote
    "status": "completed",
    "updatedAt": { "$lt": { "$now": true } }
  }
}
----

IMPORTANT: Quando `where` é fornecido, a chave na URL vira um prefixo. Todas as entradas com esse prefixo que satisfazem o filtro são deletadas atomicamente.

**Resposta (200):**

[source,typescript]
----
{
  "deletedCount": 3
}
----

**Exemplo:**

[source,bash]
----
# Delete simples (remove chave + todos os filhos)
curl -X DELETE "http://localhost:4000/api/keyval/keys/users/123"

# Delete exato (remove APENAS a chave, não os filhos)
curl -X DELETE "http://localhost:4000/api/keyval/keys/users/123" \
  -H "Content-Type: application/json" \
  -d '{"exact": true}'

# Delete com filtro (deleta entradas com status = "completed")
curl -X DELETE "http://localhost:4000/api/keyval/keys/tasks" \
  -H "Content-Type: application/json" \
  -d '{"where": {"status": "completed"}}'

# Delete com filtro de data (todas tarefas atualizadas há mais de 1 dia)
curl -X DELETE "http://localhost:4000/api/keyval/keys/tasks" \
  -H "Content-Type: application/json" \
  -d '{"where": {"updatedAt": {"$lt": {"$now": true}}}}'
----

==== GET /keys

Lista entradas por prefixo com paginação simples (sem filtros).

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| prefix
| string
| ""
| Prefixo de chave (ex: "users" para listar ["users", ...])

| start
| string
| null
| Chave inicial (inclusiva, formato "part1/part2")

| end
| string
| null
| Chave final (exclusiva, formato "part1/part2")

| limit
| number
| 100
| Máximo de entradas (máximo: 1000)

| reverse
| boolean
| false
| Retornar em ordem reversa
|===

**Resposta (200):**

[source,typescript]
----
[
  {
    "key": ["users", "001"],
    "value": {"name": "Alice"},
    "versionstamp": "00000000000000010000"
  },
  {
    "key": ["users", "002"],
    "value": {"name": "Bob"},
    "versionstamp": "00000000000000020000"
  }
]
----

**Exemplo:**

[source,bash]
----
# Listar todas as chaves com prefixo "users"
curl -X GET "http://localhost:4000/api/keyval/keys?prefix=users&limit=50"

# Listar em ordem reversa
curl -X GET "http://localhost:4000/api/keyval/keys?prefix=users&reverse=true"

# Listar com range (de "users/100" até "users/200")
curl -X GET "http://localhost:4000/api/keyval/keys?prefix=users&start=users/100&end=users/200"
----

==== POST /keys/list

Lista entradas com suporte a filtros `where` (use este endpoint quando precisar filtrar).

**Request Body:**

[source,typescript]
----
{
  "prefix": ["users"],           // opcional, prefixo de chave
  "start": ["users", "100"],     // opcional, chave inicial
  "end": ["users", "200"],       // opcional, chave final
  "limit": 100,                  // opcional, máximo de entradas
  "reverse": false,              // opcional, ordem reversa
  "where": {                     // opcional, filtro
    "status": { "$eq": "active" },
    "age": { "$gt": 18 }
  }
}
----

**Operadores de Filtro:**

===== Comparação

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$eq`
| Igual a
| `{ "status": { "$eq": "active" } }`

| `$ne`
| Diferente de
| `{ "status": { "$ne": "deleted" } }`

| `$gt`
| Maior que
| `{ "age": { "$gt": 18 } }`

| `$gte`
| Maior ou igual
| `{ "age": { "$gte": 18 } }`

| `$lt`
| Menor que
| `{ "price": { "$lt": 100 } }`

| `$lte`
| Menor ou igual
| `{ "price": { "$lte": 100 } }`

| `$between`
| Entre dois valores (inclusive)
| `{ "amount": { "$between": [100, 500] } }`

| `$now`
| Timestamp do servidor
| `{ "expiresAt": { "$gt": { "$now": true } } }`
|===

===== Array

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$in`
| Valor está no array
| `{ "status": { "$in": ["active", "pending"] } }`

| `$nin`
| Valor não está no array
| `{ "status": { "$nin": ["deleted"] } }`
|===

===== String (case-sensitive)

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$contains`
| Contém substring
| `{ "name": { "$contains": "Silva" } }`

| `$notContains`
| Não contém substring
| `{ "email": { "$notContains": "@temp" } }`

| `$startsWith`
| Começa com
| `{ "code": { "$startsWith": "BR_" } }`

| `$endsWith`
| Termina com
| `{ "email": { "$endsWith": "@company.com" } }`
|===

===== String (case-insensitive)

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$containsi`
| Contém (ignora maiúsculas)
| `{ "name": { "$containsi": "silva" } }`

| `$notContainsi`
| Não contém (ignora maiúsculas)
| `{ "name": { "$notContainsi": "test" } }`

| `$startsWithi`
| Começa com (ignora maiúsculas)
| `{ "code": { "$startsWithi": "br_" } }`

| `$endsWithi`
| Termina com (ignora maiúsculas)
| `{ "domain": { "$endsWithi": ".com.br" } }`
|===

===== Existência

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$null`
| Valor é null (true) ou não (false)
| `{ "deletedAt": { "$null": true } }`

| `$empty`
| Valor é vazio (string, array, ou null)
| `{ "tags": { "$empty": true } }`

| `$notEmpty`
| Valor não é vazio
| `{ "description": { "$notEmpty": true } }`
|===

===== Lógicos

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$or`
| Pelo menos uma condição verdadeira
| `{ "$or": [{ "a": 1 }, { "b": 2 }] }`

| `$and`
| Todas as condições verdadeiras
| `{ "$and": [{ "a": 1 }, { "b": 2 }] }`

| `$not`
| Inverte a condição
| `{ "$not": { "status": "deleted" } }`
|===

**Resposta (200):**

[source,typescript]
----
[
  {
    "key": ["users", "001"],
    "value": {"name": "Alice", "status": "active", "age": 25},
    "versionstamp": "00000000000000010000"
  }
]
----

**Exemplo:**

[source,bash]
----
# Listar usuários ativos
curl -X POST "http://localhost:4000/api/keyval/keys/list" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["users"],
    "where": {"status": {"$eq": "active"}}
  }'

# Listar com múltiplos filtros
curl -X POST "http://localhost:4000/api/keyval/keys/list" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["users"],
    "where": {
      "age": {"$gt": 18},
      "city": {"$eq": "SP"}
    }
  }'

# Listar com $or
curl -X POST "http://localhost:4000/api/keyval/keys/list" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["users"],
    "where": {
      "$or": [
        {"status": {"$eq": "active"}},
        {"status": {"$eq": "pending"}}
      ]
    }
  }'

# Sessões não expiradas (usando timestamp do servidor)
curl -X POST "http://localhost:4000/api/keyval/keys/list" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["sessions"],
    "where": {"expiresAt": {"$gt": {"$now": true}}}
  }'

# Posts publicados com range de datas e paginação
curl -X POST "http://localhost:4000/api/keyval/keys/list" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["posts"],
    "start": ["posts", "2024-01"],
    "end": ["posts", "2024-12"],
    "limit": 50,
    "reverse": true,
    "where": {
      "status": {"$eq": "published"},
      "likes": {"$gt": 100}
    }
  }'

# Busca case-insensitive com múltiplas condições
curl -X POST "http://localhost:4000/api/keyval/keys/list" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["products"],
    "where": {
      "name": {"$containsi": "phone"},
      "price": {"$between": [100, 500]},
      "inStock": {"$eq": true}
    }
  }'
----

==== GET /keys/count

Conta o número de entradas por prefixo.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| prefix
| string
| ""
| Prefixo de chave (vazio = todas as chaves)
|===

**Resposta (200):**

[source,json]
----
{
  "count": 42
}
----

**Exemplo:**

[source,bash]
----
# Contar todas as chaves
curl -X GET "http://localhost:4000/api/keyval/keys/count"

# Contar chaves com prefixo "users"
curl -X GET "http://localhost:4000/api/keyval/keys/count?prefix=users"
----

==== GET /keys/paginate

Paginação baseada em cursor para navegação eficiente.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| prefix
| string
| ""
| Prefixo de chave

| cursor
| string
| null
| Cursor da página anterior (base64)

| limit
| number
| 100
| Máximo de entradas (máximo: 1000)

| reverse
| boolean
| false
| Retornar em ordem reversa
|===

**Resposta (200):**

[source,typescript]
----
{
  "entries": [
    {
      "key": ["users", "001"],
      "value": {"name": "Alice"},
      "versionstamp": "00000000000000010000"
    }
  ],
  "cursor": "dXNlcnMvMDAy",  // null se não houver mais páginas
  "hasMore": true
}
----

**Exemplo:**

[source,bash]
----
# Primeira página
curl -X GET "http://localhost:4000/api/keyval/keys/paginate?prefix=users&limit=10"

# Próxima página (usando cursor retornado)
curl -X GET "http://localhost:4000/api/keyval/keys/paginate?prefix=users&limit=10&cursor=dXNlcnMvMDAy"
----

=== Atomic Operations

==== POST /atomic

Executa operações atômicas com controle de concorrência otimista.

**Request Body:**

[source,typescript]
----
{
  "checks": [
    {
      "key": ["users", "123"],
      "versionstamp": "00000000000000010000"  // ou null para verificar inexistência
    }
  ],
  "mutations": [
    {
      "type": "set",
      "key": ["users", "123"],
      "value": {"name": "João", "email": "joao@example.com"},
      "expiresIn": 3600000  // opcional
    },
    {
      "type": "sum",
      "key": ["counters", "visits"],
      "value": 1
    },
    {
      "type": "delete",
      "key": ["cache", "old-data"]
    }
  ]
}
----

**Tipos de Mutação:**

[cols="1,2,2"]
|===
| Tipo | Parâmetros | Descrição

| set
| key, value, expiresIn?
| Define um valor

| delete
| key
| Remove uma chave

| sum
| key, value (bigint)
| Soma ao valor existente

| max
| key, value (bigint)
| Define como máximo entre atual e novo valor

| min
| key, value (bigint)
| Define como mínimo entre atual e novo valor

| append
| key, value (array)
| Adiciona ao final de um array

| prepend
| key, value (array)
| Adiciona ao início de um array
|===

NOTE: Para operações `sum`, `max` e `min`, valores BigInt são automaticamente convertidos para Number. Os valores devem estar no range de `Number.MIN_SAFE_INTEGER` (-9007199254740991) a `Number.MAX_SAFE_INTEGER` (9007199254740991) para evitar perda de precisão.

**Resposta (200) - Sucesso:**

[source,typescript]
----
{
  "ok": true,
  "versionstamp": "00000000000000050000"
}
----

**Resposta (200) - Falha (check failed):**

[source,typescript]
----
{
  "ok": false
}
----

NOTE: Se `commit()` for chamado sem nenhum check nem mutation (requisição vazia ou arrays vazios), retorna `{ ok: true, versionstamp: <uuid> }`.

**Resposta (400) - Erro de validação:**

[source,json]
----
{
  "error": "append value must be an array"
}
----

**Exemplo:**

[source,bash]
----
# Incrementar contador atomicamente
curl -X POST "http://localhost:4000/api/keyval/atomic" \
  -H "Content-Type: application/json" \
  -d '{
    "mutations": [
      {"type": "sum", "key": ["counters", "visits"], "value": 1}
    ]
  }'

# Atualização condicional (somente se versionstamp corresponder)
curl -X POST "http://localhost:4000/api/keyval/atomic" \
  -H "Content-Type: application/json" \
  -d '{
    "checks": [
      {"key": ["users", "123"], "versionstamp": "00000000000000010000"}
    ],
    "mutations": [
      {"type": "set", "key": ["users", "123"], "value": {"name": "João Updated"}}
    ]
  }'

# Múltiplos checks em uma única requisição (variadic)
curl -X POST "http://localhost:4000/api/keyval/atomic" \
  -H "Content-Type: application/json" \
  -d '{
    "checks": [
      {"key": ["users", "123"], "versionstamp": "00000000000000010000"},
      {"key": ["users", "456"], "versionstamp": "00000000000000020000"},
      {"key": ["settings", "config"], "versionstamp": null}
    ],
    "mutations": [
      {"type": "set", "key": ["batch", "processed"], "value": true}
    ]
  }'

# Múltiplas operações atômicas
curl -X POST "http://localhost:4000/api/keyval/atomic" \
  -H "Content-Type: application/json" \
  -d '{
    "mutations": [
      {"type": "set", "key": ["posts", "123"], "value": {"title": "Hello"}},
      {"type": "append", "key": ["posts", "all"], "value": ["123"]},
      {"type": "sum", "key": ["stats", "total_posts"], "value": 1}
    ]
  }'
----

=== Queue API

==== POST /queue/enqueue

Adiciona uma mensagem à fila.

**Request Body:**

[source,typescript]
----
{
  "value": {
    "type": "send-email",
    "to": "user@example.com",
    "subject": "Welcome"
  },
  "options": {
    "delay": 5000,  // atrasar 5 segundos (opcional)
    "backoffSchedule": [1000, 5000, 10000],  // opcional
    "keysIfUndelivered": [["failed_jobs", "123"]]  // opcional
  }
}
----

**Resposta (200):**

[source,typescript]
----
{
  "ok": true,
  "id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"
}
----

**Exemplo:**

[source,bash]
----
# Enqueue simples
curl -X POST "http://localhost:4000/api/keyval/queue/enqueue" \
  -H "Content-Type: application/json" \
  -d '{"value": {"task": "send-email", "to": "user@example.com"}}'

# Enqueue com delay de 10 segundos
curl -X POST "http://localhost:4000/api/keyval/queue/enqueue" \
  -H "Content-Type: application/json" \
  -d '{
    "value": {"task": "reminder"},
    "options": {"delay": 10000}
  }'
----

==== GET /queue/listen

Stream SSE para receber mensagens continuamente.

**Resposta (SSE Stream):**

[source]
----
event: message
id: 01J9X3K2M5N7P8Q9R0S1T2V3W4
data: {"id":"01J9X3K2M5N7P8Q9R0S1T2V3W4","value":{"task":"send-email"},"attempts":1}

event: ping
data:

event: message
id: 01J9X3K2M5N7P8Q9R0S1T2V3W5
data: {"id":"01J9X3K2M5N7P8Q9R0S1T2V3W5","value":{"task":"another"},"attempts":1}
----

**Tipos de Eventos:**

- `message`: Nova mensagem disponível
- `ping`: Heartbeat para manter conexão ativa

**Exemplo:**

[source,bash]
----
# Escutar mensagens via SSE
curl -N "http://localhost:4000/api/keyval/queue/listen"
----

==== GET /queue/poll

Obtém uma única mensagem (polling mode).

**Resposta (200):**

[source,typescript]
----
{
  "message": {
    "id": "01J9X3K2M5N7P8Q9R0S1T2V3W4",
    "value": {"task": "send-email"},
    "attempts": 1
  }
}
----

**Resposta (200) - Fila vazia:**

[source,typescript]
----
{
  "message": null
}
----

**Exemplo:**

[source,bash]
----
curl -X GET "http://localhost:4000/api/keyval/queue/poll"
----

==== POST /queue/ack

Confirma o processamento bem-sucedido de uma mensagem.

**Request Body:**

[source,typescript]
----
{
  "id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"
}
----

**Resposta (200):**

[source,json]
----
{
  "ok": true
}
----

**Resposta (400):**

[source,json]
----
{
  "error": "id must be a non-empty string"
}
----

**Exemplo:**

[source,bash]
----
curl -X POST "http://localhost:4000/api/keyval/queue/ack" \
  -H "Content-Type: application/json" \
  -d '{"id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"}'
----

==== POST /queue/nack

Rejeita uma mensagem (será reprocessada ou enviada para DLQ).

**Request Body:**

[source,typescript]
----
{
  "id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"
}
----

**Resposta (200):**

[source,json]
----
{
  "ok": true
}
----

**Exemplo:**

[source,bash]
----
curl -X POST "http://localhost:4000/api/keyval/queue/nack" \
  -H "Content-Type: application/json" \
  -d '{"id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"}'
----

==== GET /queue/stats

Obtém estatísticas da fila.

**Resposta (200):**

[source,typescript]
----
{
  "pending": 10,      // mensagens aguardando processamento
  "processing": 3,    // mensagens sendo processadas
  "dlq": 2,          // mensagens na DLQ
  "total": 15        // total de mensagens
}
----

**Exemplo:**

[source,bash]
----
curl -X GET "http://localhost:4000/api/keyval/queue/stats"
----

=== Dead Letter Queue (DLQ) API

==== GET /queue/dlq

Lista mensagens na DLQ.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| limit
| number
| 100
| Máximo de mensagens (máximo: 1000)

| offset
| number
| 0
| Deslocamento para paginação
|===

**Resposta (200):**

[source,typescript]
----
[
  {
    "id": "...",
    "originalId": "...",
    "value": {...},
    "attempts": 3,
    "errorMessage": "Connection timeout",
    "originalCreatedAt": 1234567890000,
    "failedAt": 1234567900000
  }
]
----

**Exemplo:**

[source,bash]
----
# Listar primeiras 50 mensagens da DLQ
curl -X GET "http://localhost:4000/api/keyval/queue/dlq?limit=50"

# Segunda página (offset 50)
curl -X GET "http://localhost:4000/api/keyval/queue/dlq?limit=50&offset=50"
----

==== GET /queue/dlq/:id

Obtém uma mensagem específica da DLQ.

**Resposta (200):**

[source,typescript]
----
{
  "id": "...",
  "originalId": "...",
  "value": {...},
  "attempts": 3,
  "errorMessage": "Connection timeout",
  "originalCreatedAt": 1234567890000,
  "failedAt": 1234567900000
}
----

**Resposta (404):**

[source,json]
----
{
  "error": "Message not found in DLQ"
}
----

**Exemplo:**

[source,bash]
----
curl -X GET "http://localhost:4000/api/keyval/queue/dlq/01J9X3K2M5N7P8Q9R0S1T2V3W4"
----

==== POST /queue/dlq/:id/requeue

Reenvia uma mensagem da DLQ para processamento.

**Resposta (200) - Sucesso:**

[source,typescript]
----
{
  "ok": true,
  "newId": "01J9X3K2M5N7P8Q9R0S1T2V3W5"
}
----

**Resposta (404):**

[source,typescript]
----
{
  "ok": false,
  "error": "Message not found in DLQ"
}
----

**Exemplo:**

[source,bash]
----
curl -X POST "http://localhost:4000/api/keyval/queue/dlq/01J9X3K2M5N7P8Q9R0S1T2V3W4/requeue"
----

==== DELETE /queue/dlq/:id

Remove uma mensagem específica da DLQ.

**Resposta (200):**

[source,json]
----
{
  "ok": true
}
----

**Exemplo:**

[source,bash]
----
curl -X DELETE "http://localhost:4000/api/keyval/queue/dlq/01J9X3K2M5N7P8Q9R0S1T2V3W4"
----

==== DELETE /queue/dlq

Remove todas as mensagens da DLQ (purge).

**Resposta (200):**

[source,typescript]
----
{
  "deletedCount": 42
}
----

**Exemplo:**

[source,bash]
----
curl -X DELETE "http://localhost:4000/api/keyval/queue/dlq"
----

=== Watch API

==== GET /watch

Stream SSE para observar mudanças em chaves específicas.

**Parâmetros de Query:**

[cols="1,1,2"]
|===
| Parâmetro | Tipo | Descrição

| keys
| string
| Chaves separadas por vírgula (ex: "users/123,posts/456")

| initial
| boolean
| Emitir valores iniciais no primeiro evento (padrão: true)
|===

**Resposta (SSE Stream):**

[source]
----
event: change
data: [{"key":["users","123"],"value":{"name":"João"},"versionstamp":"00000000000000010000"}]

event: ping
data:

event: change
data: [{"key":["users","123"],"value":{"name":"João Updated"},"versionstamp":"00000000000000020000"}]
----

**Tipos de Eventos:**

- `change`: Uma ou mais chaves mudaram
- `ping`: Heartbeat (mantém conexão ativa)

**Exemplo:**

[source,bash]
----
# Observar uma chave
curl -N "http://localhost:4000/api/keyval/watch?keys=users/123"

# Observar múltiplas chaves (separadas por vírgula)
curl -N "http://localhost:4000/api/keyval/watch?keys=config,settings"

# Sem emissão inicial
curl -N "http://localhost:4000/api/keyval/watch?keys=users/123&initial=false"
----

==== GET /watch/poll

Modo polling para verificar mudanças em chaves.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| keys
| string
| (obrigatório)
| Chaves separadas por vírgula

| versionstamps
| string
| null
| Versionstamps conhecidos (separados por vírgula)
|===

**Resposta (200):**

[source,typescript]
----
{
  "entries": [
    {
      "key": ["users", "123"],
      "value": {"name": "João"},
      "versionstamp": "00000000000000020000"
    }
  ],
  "versionstamps": ["00000000000000020000", "00000000000000030000"]
}
----

NOTE: `entries` contém apenas chaves que mudaram desde os `versionstamps` fornecidos.

**Exemplo:**

[source,bash]
----
# Primeira verificação (retorna valores atuais)
curl -X GET "http://localhost:4000/api/keyval/watch/poll?keys=users/123,posts/456"

# Verificações subsequentes (passando versionstamps anteriores)
curl -X GET "http://localhost:4000/api/keyval/watch/poll?keys=users/123,posts/456&versionstamps=00000000000000010000,00000000000000020000"
----

==== GET /watch/prefix

Stream SSE para observar mudanças em chaves com um prefixo.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| prefix
| string
| (obrigatório)
| Prefixo de chave (ex: "users")

| initial
| boolean
| true
| Emitir valores iniciais no primeiro evento

| limit
| number
| 100
| Máximo de chaves observadas (máximo: 1000)
|===

**Resposta (SSE Stream):**

[source]
----
event: change
data: [{"key":["users","001"],"value":{"name":"Alice"},"versionstamp":"00000000000000010000"}]

event: ping
data:

event: change
data: [{"key":["users","002"],"value":{"name":"Bob"},"versionstamp":"00000000000000020000"},{"key":["users","001"],"value":null,"versionstamp":null}]
----

NOTE: Quando `value` é `null` e `versionstamp` é `null`, significa que a chave foi deletada.

**Exemplo:**

[source,bash]
----
# Observar todas as chaves com prefixo "users"
curl -N "http://localhost:4000/api/keyval/watch/prefix?prefix=users"

# Limitar a 50 chaves
curl -N "http://localhost:4000/api/keyval/watch/prefix?prefix=users&limit=50"
----

==== GET /watch/prefix/poll

Modo polling para verificar mudanças em chaves com prefixo.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| prefix
| string
| (obrigatório)
| Prefixo de chave

| versionstamps
| string
| null
| Mapa de versionstamps (formato: "key1:vs1,key2:vs2")

| limit
| number
| 100
| Máximo de chaves (máximo: 1000)
|===

**Resposta (200):**

[source,typescript]
----
{
  "entries": [
    {
      "key": ["users", "001"],
      "value": {"name": "Alice Updated"},
      "versionstamp": "00000000000000030000"
    },
    {
      "key": ["users", "003"],
      "value": null,
      "versionstamp": null
    }
  ],
  "versionstamps": "users/001:00000000000000030000,users/002:00000000000000020000"
}
----

**Exemplo:**

[source,bash]
----
# Primeira verificação
curl -X GET "http://localhost:4000/api/keyval/watch/prefix/poll?prefix=users"

# Verificação subsequente (passando versionstamps anteriores)
curl -X GET "http://localhost:4000/api/keyval/watch/prefix/poll?prefix=users&versionstamps=users/001:00000000000000010000,users/002:00000000000000020000"
----

=== Full-Text Search (FTS)

==== POST /indexes

Cria um índice FTS para busca textual em campos específicos.

**Request Body:**

[source,typescript]
----
{
  "prefix": ["products"],
  "options": {
    "fields": ["name", "description", "category"],
    "tokenize": "porter"  // opcional: "unicode61" (padrão), "porter", "ascii"
  }
}
----

**Tokenizers Disponíveis:**

[cols="1,2"]
|===
| Tokenizer | Descrição

| `unicode61`
| Tokenização Unicode (padrão) - suporta caracteres internacionais

| `porter`
| Aplica algoritmo Porter Stemming - normaliza palavras para raízes (ex: "running" → "run")

| `ascii`
| Tokenização ASCII - apenas caracteres ASCII básicos
|===

**Resposta (200):**

[source,json]
----
{
  "ok": true
}
----

**Resposta (400) - Validação:**

[source,json]
----
{
  "error": "options.fields must be a non-empty array"
}
----

IMPORTANT: Um índice FTS é necessário antes de realizar buscas. Cada prefixo pode ter apenas um índice. Criar um novo índice para o mesmo prefixo substitui o anterior.

**Exemplo:**

[source,bash]
----
# Criar índice simples para produtos
curl -X POST "http://localhost:4000/api/keyval/indexes" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["products"],
    "options": {
      "fields": ["name", "description", "category"]
    }
  }'

# Criar índice com Porter Stemming para posts
curl -X POST "http://localhost:4000/api/keyval/indexes" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["posts"],
    "options": {
      "fields": ["title", "content", "tags"],
      "tokenize": "porter"
    }
  }'
----

==== GET /indexes

Lista todos os índices FTS existentes.

**Resposta (200):**

[source,typescript]
----
[
  {
    "prefix": ["products"],
    "fields": ["name", "description", "category"],
    "tokenize": "unicode61"
  },
  {
    "prefix": ["posts"],
    "fields": ["title", "content", "tags"],
    "tokenize": "porter"
  }
]
----

**Exemplo:**

[source,bash]
----
curl -X GET "http://localhost:4000/api/keyval/indexes"
----

==== DELETE /indexes

Remove um índice FTS específico.

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| prefix
| string
| (obrigatório)
| Prefixo do índice a remover (formato: "part1/part2")
|===

**Resposta (200):**

[source,json]
----
{
  "ok": true
}
----

**Resposta (400):**

[source,json]
----
{
  "error": "Missing 'prefix' query parameter"
}
----

**Exemplo:**

[source,bash]
----
# Remover índice do prefixo "products"
curl -X DELETE "http://localhost:4000/api/keyval/indexes?prefix=products"
----

==== GET /search

Realiza busca textual usando parâmetros de query (modo simples).

**Parâmetros de Query:**

[cols="1,1,1,2"]
|===
| Parâmetro | Tipo | Padrão | Descrição

| prefix
| string
| (obrigatório)
| Prefixo do índice para buscar (formato: "part1/part2")

| query
| string
| (obrigatório)
| Texto de busca

| limit
| number
| 100
| Máximo de resultados
|===

**Resposta (200):**

[source,typescript]
----
[
  {
    "key": ["products", "123"],
    "value": {
      "name": "Smartphone XYZ",
      "description": "High-end smartphone with advanced features",
      "price": 999.99
    },
    "versionstamp": "00000000000000010000"
  },
  {
    "key": ["products", "456"],
    "value": {
      "name": "Phone Case",
      "description": "Protective case for smartphones",
      "price": 29.99
    },
    "versionstamp": "00000000000000020000"
  }
]
----

NOTE: Resultados são ordenados por relevância (ordem interna do SQLite FTS5).

**Resposta (400):**

[source,json]
----
{
  "error": "Missing 'query' query parameter"
}
----

**Exemplo:**

[source,bash]
----
# Buscar produtos contendo "smartphone"
curl -X GET "http://localhost:4000/api/keyval/search?prefix=products&query=smartphone"

# Buscar com limite de resultados
curl -X GET "http://localhost:4000/api/keyval/search?prefix=products&query=phone%20case&limit=10"

# Buscar posts
curl -X GET "http://localhost:4000/api/keyval/search?prefix=posts&query=tutorial%20react"
----

==== POST /search

Realiza busca textual com suporte a filtros `where` complexos (modo avançado).

**Request Body:**

[source,typescript]
----
{
  "prefix": ["products"],
  "query": "smartphone",
  "options": {
    "limit": 50,           // opcional, padrão: 100
    "where": {             // opcional, filtro adicional
      "price": { "$lt": 500 },
      "inStock": { "$eq": true }
    }
  }
}
----

**Resposta (200):**

[source,typescript]
----
[
  {
    "key": ["products", "789"],
    "value": {
      "name": "Budget Smartphone",
      "description": "Affordable smartphone for everyday use",
      "price": 299.99,
      "inStock": true
    },
    "versionstamp": "00000000000000030000"
  }
]
----

**Resposta (400):**

[source,json]
----
{
  "error": "prefix is required"
}
----

NOTE: A busca FTS é aplicada primeiro (usando o índice), depois o filtro `where` é aplicado aos resultados. Isso combina busca textual eficiente com filtragem estruturada.

**Exemplo:**

[source,bash]
----
# Buscar produtos baratos com "phone"
curl -X POST "http://localhost:4000/api/keyval/search" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["products"],
    "query": "phone",
    "options": {
      "where": {"price": {"$lt": 100}}
    }
  }'

# Buscar posts ativos sobre React
curl -X POST "http://localhost:4000/api/keyval/search" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["posts"],
    "query": "react hooks",
    "options": {
      "limit": 20,
      "where": {
        "status": {"$eq": "published"},
        "publishedAt": {"$gt": {"$now": true}}
      }
    }
  }'

# Buscar produtos em estoque com múltiplas condições
curl -X POST "http://localhost:4000/api/keyval/search" \
  -H "Content-Type: application/json" \
  -d '{
    "prefix": ["products"],
    "query": "laptop gaming",
    "options": {
      "where": {
        "$and": [
          {"inStock": {"$eq": true}},
          {"price": {"$between": [500, 2000]}},
          {"rating": {"$gte": 4}}
        ]
      }
    }
  }'
----

=== Metrics API

==== GET /metrics

Obtém métricas em formato JSON.

**Resposta (200):**

[source,typescript]
----
{
  "operations": {
    "get": { "count": 1234, "errors": 5 },
    "set": { "count": 567, "errors": 2 },
    "delete": { "count": 89, "errors": 0 },
    "list": { "count": 456, "errors": 1 },
    "atomic": { "count": 234, "errors": 3 }
  },
  "queue": {
    "pending": 10,
    "processing": 3,
    "dlq": 2,
    "total": 15
  },
  "storage": {
    "entries": 5432,       // total de entradas não expiradas
    "sizeBytes": 1048576   // tamanho total em bytes
  }
}
----

**Exemplo:**

[source,bash]
----
curl -X GET "http://localhost:4000/api/keyval/metrics"
----

==== GET /metrics/prometheus

Obtém métricas em formato Prometheus.

**Resposta (200):**

[source]
----
# HELP keyval_operations_total Total operations by type
# TYPE keyval_operations_total counter
keyval_operations_total{operation="get"} 1234
keyval_operations_total{operation="set"} 567
keyval_operations_total{operation="delete"} 89

# HELP keyval_operation_errors_total Total errors by operation type
# TYPE keyval_operation_errors_total counter
keyval_operation_errors_total{operation="get"} 5
keyval_operation_errors_total{operation="set"} 2

# HELP keyval_queue_pending Pending messages in queue
# TYPE keyval_queue_pending gauge
keyval_queue_pending 10

# HELP keyval_queue_processing Messages being processed
# TYPE keyval_queue_processing gauge
keyval_queue_processing 3

# HELP keyval_queue_dlq Messages in dead letter queue
# TYPE keyval_queue_dlq gauge
keyval_queue_dlq 2

# HELP keyval_queue_total Total messages in queue
# TYPE keyval_queue_total gauge
keyval_queue_total 15

# HELP keyval_entries_total Total entries in store
# TYPE keyval_entries_total gauge
keyval_entries_total 5432

# HELP keyval_storage_bytes Storage size in bytes
# TYPE keyval_storage_bytes gauge
keyval_storage_bytes 1048576
----

**Content-Type:** `text/plain; version=0.0.4`

**Exemplo:**

[source,bash]
----
curl -X GET "http://localhost:4000/api/keyval/metrics/prometheus"
----

=== Códigos de Erro

[cols="1,2,3"]
|===
| Código | Situação | Exemplo

| 400
| Validação falhou
| `{"error": "Key part must be string, number, bigint, boolean, or Uint8Array"}`

| 404
| Recurso não encontrado
| `{"error": "Key not found"}`

| 500
| Erro interno do servidor
| `{"error": "Internal server error"}`
|===

=== Limites e Validação

[cols="2,1,3"]
|===
| Item | Limite | Descrição

| Profundidade de chave
| 20 partes
| Máximo de partes em uma chave array

| Tipo de parte de chave
| Restritos
| string, number, bigint, boolean, ou Uint8Array

| Batch get (POST /keys/batch)
| 1000 chaves
| Máximo de chaves por requisição batch

| Limite de listagem
| 1000
| Máximo de entradas retornadas por vez (GET /keys, POST /keys/list)

| Limite padrão
| 100
| Valor padrão para `limit` em operações de listagem

| TTL máximo (expiresIn)
| 2147483647 ms
| Aproximadamente 24 dias

| Valor de bigint
| BigInt válido
| Para operações atômicas sum/max/min

| Operações atômicas
| Sem limite explícito
| Número de checks e mutations por transação

| Watch keys (GET /watch)
| 1000 chaves
| Máximo de chaves observadas simultaneamente

| Watch prefix (GET /watch/prefix)
| 1000 chaves
| Máximo de chaves retornadas por prefixo

| Queue DLQ limit
| 1000 mensagens
| Máximo de mensagens retornadas (GET /queue/dlq)
|===

**Validação de Tipos:**

- **Keys:** Devem ser arrays com partes válidas (string, number, bigint, boolean, Uint8Array)
- **Values:** Qualquer valor JSON serializável
- **expiresIn:** Número inteiro positivo em milissegundos
- **Where filters:** Objeto com operadores válidos ($eq, $gt, $in, etc.)

=== Server-Sent Events (SSE)

Os endpoints de watch e queue/listen usam SSE para streaming:

**Formato:**

[source]
----
event: event-type
id: optional-id
data: json-payload

----

**Tipos de Eventos:**

[cols="1,2"]
|===
| Evento | Uso

| `message`
| Nova mensagem da fila (queue/listen)

| `change`
| Mudança em chaves observadas (watch endpoints)

| `ping`
| Heartbeat para manter conexão ativa
|===

**Intervalo de Polling:** 100ms (entre verificações internas)

**Heartbeat:** Enviado quando não há mudanças para manter a conexão ativa

=== Exemplos Completos

==== Workflow de Fila Completo

[source,bash]
----
# 1. Adicionar mensagem à fila
curl -X POST "http://localhost:4000/api/keyval/queue/enqueue" \
  -H "Content-Type: application/json" \
  -d '{"value": {"task": "send-email", "to": "user@example.com"}}'

# Resposta: {"ok": true, "id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"}

# 2. Obter mensagem
curl -X GET "http://localhost:4000/api/keyval/queue/poll"

# Resposta: {"message": {"id": "01J9X3K2M5N7P8Q9R0S1T2V3W4", "value": {...}, "attempts": 1}}

# 3. Processar e confirmar sucesso
curl -X POST "http://localhost:4000/api/keyval/queue/ack" \
  -H "Content-Type: application/json" \
  -d '{"id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"}'

# Ou rejeitar em caso de erro
curl -X POST "http://localhost:4000/api/keyval/queue/nack" \
  -H "Content-Type: application/json" \
  -d '{"id": "01J9X3K2M5N7P8Q9R0S1T2V3W4"}'
----

==== Transação Atômica Complexa

[source,bash]
----
curl -X POST "http://localhost:4000/api/keyval/atomic" \
  -H "Content-Type: application/json" \
  -d '{
    "checks": [
      {"key": ["inventory", "item-123"], "versionstamp": "00000000000000010000"}
    ],
    "mutations": [
      {
        "type": "set",
        "key": ["orders", "order-456"],
        "value": {
          "items": [{"id": "item-123", "quantity": 2}],
          "total": 99.99
        }
      },
      {
        "type": "sum",
        "key": ["inventory", "item-123", "quantity"],
        "value": -2
      },
      {
        "type": "append",
        "key": ["orders", "recent"],
        "value": ["order-456"]
      },
      {
        "type": "sum",
        "key": ["stats", "total_orders"],
        "value": 1
      }
    ]
  }'
----

==== Watch com Cursor

[source,bash]
----
# Primeira verificação (obter estado atual)
RESPONSE=$(curl -s "http://localhost:4000/api/keyval/watch/poll?keys=users/123,posts/456")
echo "$RESPONSE"

# Extrair versionstamps para próxima verificação
VERSIONSTAMPS=$(echo "$RESPONSE" | jq -r '.versionstamps | join(",")')

# Verificar mudanças (retorna vazio se nada mudou)
curl -s "http://localhost:4000/api/keyval/watch/poll?keys=users/123,posts/456&versionstamps=$VERSIONSTAMPS"
----
