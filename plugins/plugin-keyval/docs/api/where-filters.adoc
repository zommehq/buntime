:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

== Where Filters

Where filters permitem filtrar entries em operações `list` e `delete` com base nos valores armazenados. A filtragem é executada no servidor usando funções JSON do SQLite.

=== Sintaxe Básica

Os filtros são objetos JSON onde as chaves são campos e os valores são operadores ou valores diretos:

[source,typescript]
----
// Sintaxe completa
{ campo: { $operador: valor } }

// Sintaxe shorthand (equivalente a $eq)
{ campo: valor }
----

=== Operadores de Comparação

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$eq`
| Igual a
| `{ status: { $eq: "active" } }`

| `$ne`
| Diferente de
| `{ status: { $ne: "deleted" } }`

| `$gt`
| Maior que
| `{ age: { $gt: 18 } }`

| `$gte`
| Maior ou igual
| `{ age: { $gte: 21 } }`

| `$lt`
| Menor que
| `{ price: { $lt: 100 } }`

| `$lte`
| Menor ou igual
| `{ price: { $lte: 50 } }`

| `$between`
| Entre dois valores (inclusivo)
| `{ age: { $between: [18, 65] } }`
|===

==== Exemplos de Comparação

[source,typescript]
----
// Usuários com idade maior que 30
for await (const entry of kv.list(["users"], {
  where: { age: { $gt: 30 } }
})) {
  console.log(entry.value);
}

// Produtos com preço entre 10 e 100
for await (const entry of kv.list(["products"], {
  where: { price: { $between: [10, 100] } }
})) {
  console.log(entry.value);
}
----

==== Exemplo de $between

[source,typescript]
----
// Produtos com preço entre 10 e 100 (inclusivo)
for await (const entry of kv.list(["products"], {
  where: { price: { $between: [10, 100] } }
})) {
  console.log(entry.value);
}

// Usuários com idade entre 18 e 65
for await (const entry of kv.list(["users"], {
  where: { age: { $between: [18, 65] } }
})) {
  console.log(entry.value);
}

// Eventos em um período de datas (timestamps)
for await (const entry of kv.list(["events"], {
  where: {
    startDate: { $between: [1704067200000, 1706745600000] }  // Jan 2024
  }
})) {
  console.log(entry.value);
}
----

==== Suporte a BigInt

Filtros suportam valores `bigint` para comparações numéricas precisas:

[source,typescript]
----
// Transações com valor alto (BigInt)
for await (const entry of kv.list(["transactions"], {
  where: { amount: { $gt: 9007199254740991n } }  // > Number.MAX_SAFE_INTEGER
})) {
  console.log(entry.value);
}
----

NOTE: BigInt é convertido para string internamente para comparação no banco de dados.

=== Operadores de Array

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$in`
| Valor está na lista
| `{ status: { $in: ["active", "pending"] } }`

| `$nin`
| Valor não está na lista
| `{ role: { $nin: ["admin", "moderator"] } }`
|===

==== Exemplos de Array

[source,typescript]
----
// Usuários com status active ou pending
for await (const entry of kv.list(["users"], {
  where: { status: { $in: ["active", "pending"] } }
})) {
  console.log(entry.value);
}

// Excluir administradores
for await (const entry of kv.list(["users"], {
  where: { role: { $nin: ["admin", "superadmin"] } }
})) {
  console.log(entry.value);
}
----

=== Operadores de String (Case-Sensitive)

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$contains`
| Contém substring
| `{ email: { $contains: "@gmail" } }`

| `$notContains`
| Não contém substring
| `{ name: { $notContains: "test" } }`

| `$startsWith`
| Começa com
| `{ name: { $startsWith: "John" } }`

| `$endsWith`
| Termina com
| `{ email: { $endsWith: ".com" } }`
|===

=== Operadores de String (Case-Insensitive)

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$containsi`
| Contém (ignora maiúsculas)
| `{ name: { $containsi: "john" } }`

| `$notContainsi`
| Não contém (ignora maiúsculas)
| `{ tag: { $notContainsi: "spam" } }`

| `$startsWithi`
| Começa com (ignora maiúsculas)
| `{ title: { $startsWithi: "the" } }`

| `$endsWithi`
| Termina com (ignora maiúsculas)
| `{ file: { $endsWithi: ".PDF" } }`
|===

==== Exemplos de String

[source,typescript]
----
// Emails do Gmail
for await (const entry of kv.list(["users"], {
  where: { email: { $contains: "@gmail.com" } }
})) {
  console.log(entry.value);
}

// Busca case-insensitive por nome
for await (const entry of kv.list(["users"], {
  where: { name: { $containsi: "john" } }
})) {
  // Encontra "John", "JOHN", "john", etc.
  console.log(entry.value);
}
----

==== Exemplos de $startsWith e $endsWith

NOTE: Estes operadores são **case-sensitive**. Use `$startsWithi` e `$endsWithi` para busca case-insensitive.

[source,typescript]
----
// Arquivos que começam com "report_"
for await (const entry of kv.list(["files"], {
  where: { filename: { $startsWith: "report_" } }
})) {
  console.log(entry.value);
}

// Emails com domínio específico
for await (const entry of kv.list(["users"], {
  where: { email: { $endsWith: "@company.com" } }
})) {
  console.log(entry.value);
}

// Versões case-insensitive
for await (const entry of kv.list(["files"], {
  where: { filename: { $endsWithi: ".PDF" } }  // Encontra .pdf, .PDF, .Pdf
})) {
  console.log(entry.value);
}
----

=== Operadores de Existência

[cols="1,2,2"]
|===
| Operador | Descrição | Exemplo

| `$null`
| Campo é null (`true`) ou não é null (`false`)
| `{ deletedAt: { $null: true } }`

| `$empty`
| Campo está vazio (null, "", ou [])
| `{ tags: { $empty: true } }`

| `$notEmpty`
| Campo não está vazio
| `{ description: { $notEmpty: true } }`
|===

==== Exemplos de Existência

[source,typescript]
----
// Usuários sem email
for await (const entry of kv.list(["users"], {
  where: { email: { $null: true } }
})) {
  console.log("Usuário sem email:", entry.value);
}

// Posts com tags
for await (const entry of kv.list(["posts"], {
  where: { tags: { $notEmpty: true } }
})) {
  console.log(entry.value);
}
----

==== Diferença entre $null e $empty

[cols="1,2,2"]
|===
| Operador | Condição | Exemplo de Match

| `$null: true`
| Campo é `null` ou não existe
| `{ name: null }` ou `{}`

| `$empty: true`
| Campo é `null`, string vazia `""`, ou array vazio `[]`
| `{ tags: [] }`, `{ bio: "" }`, `{ avatar: null }`

| `$notEmpty: true`
| Campo existe e tem valor não-vazio
| `{ tags: ["a"] }`, `{ bio: "Hello" }`
|===

[source,typescript]
----
// Usuários sem avatar definido (null ou não existe)
for await (const entry of kv.list(["users"], {
  where: { avatar: { $null: true } }
})) {
  console.log("Sem avatar:", entry.value.name);
}

// Usuários com bio vazia (null, "" ou não preenchida)
for await (const entry of kv.list(["users"], {
  where: { bio: { $empty: true } }
})) {
  console.log("Bio vazia:", entry.value.name);
}

// Produtos com tags preenchidas
for await (const entry of kv.list(["products"], {
  where: { tags: { $notEmpty: true } }
})) {
  console.log("Com tags:", entry.value.name, entry.value.tags);
}
----

=== Operadores Lógicos

==== $and

Combina condições com AND (todas devem ser verdadeiras):

[source,typescript]
----
for await (const entry of kv.list(["users"], {
  where: {
    $and: [
      { status: { $eq: "active" } },
      { age: { $gte: 18 } },
      { verified: { $eq: true } }
    ]
  }
})) {
  console.log(entry.value);
}
----

==== $or

Combina condições com OR (pelo menos uma deve ser verdadeira):

[source,typescript]
----
for await (const entry of kv.list(["users"], {
  where: {
    $or: [
      { role: { $eq: "admin" } },
      { role: { $eq: "moderator" } }
    ]
  }
})) {
  console.log(entry.value);
}
----

==== $not

Nega uma condição:

[source,typescript]
----
for await (const entry of kv.list(["users"], {
  where: {
    $not: { status: { $eq: "banned" } }
  }
})) {
  console.log(entry.value);
}
----

==== Combinando $not com $and/$or

[source,typescript]
----
// Usuários ativos que NÃO são administradores
for await (const entry of kv.list(["users"], {
  where: {
    $and: [
      { status: { $eq: "active" } },
      { $not: { role: { $eq: "admin" } } }
    ]
  }
})) {
  console.log(entry.value);
}

// Produtos que NÃO estão em promoção E NÃO estão esgotados
for await (const entry of kv.list(["products"], {
  where: {
    $and: [
      { $not: { onSale: { $eq: true } } },
      { $not: { stock: { $eq: 0 } } }
    ]
  }
})) {
  console.log(entry.value);
}
----

=== Campos Aninhados

Use notação de ponto para acessar campos aninhados:

[source,typescript]
----
// Dados
await kv.set(["products", 1], {
  name: "Laptop",
  details: {
    price: 1000,
    stock: 5,
    manufacturer: {
      country: "Japan"
    }
  }
});

// Filtrar por campo aninhado
for await (const entry of kv.list(["products"], {
  where: { "details.price": { $gte: 500 } }
})) {
  console.log(entry.value);
}

// Campos profundamente aninhados
for await (const entry of kv.list(["products"], {
  where: { "details.manufacturer.country": { $eq: "Japan" } }
})) {
  console.log(entry.value);
}
----

=== Placeholder $now

O método `kv.now()` retorna um placeholder que é resolvido no **servidor** para `Date.now()`. Isso evita discrepâncias de tempo entre cliente e servidor.

Você pode usar `.add()` e `.sub()` para calcular timestamps relativos:

[source,typescript]
----
// Tempo atual do servidor
kv.now()

// Servidor + 1 hora
kv.now().add("1h")

// Servidor - 24 horas
kv.now().sub("24h")

// Servidor + 1 hora - 30 minutos (encadeamento)
kv.now().add("1h").sub("30m")
----

[source,typescript]
----
// Sessões expiradas (expiresAt < tempo atual do servidor)
for await (const entry of kv.list(["sessions"], {
  where: { expiresAt: { $lt: kv.now() } }
})) {
  console.log("Sessão expirada:", entry.value);
}

// Posts publicados (publishedAt <= agora)
for await (const entry of kv.list(["posts"], {
  where: { publishedAt: { $lte: kv.now() } }
})) {
  console.log("Publicado:", entry.value.title);
}

// Eventos futuros (startDate > agora)
for await (const entry of kv.list(["events"], {
  where: { startDate: { $gt: kv.now() } }
})) {
  console.log("Evento futuro:", entry.value.name);
}
----

WARNING: `kv.now()` só está disponível no SDK cliente (`@buntime/keyval`). Para HTTP API, use `{ "$now": true }`.

=== Múltiplos Operadores no Mesmo Campo

Combine operadores no mesmo campo:

[source,typescript]
----
// Idade entre 18 e 65
for await (const entry of kv.list(["users"], {
  where: {
    age: { $gte: 18, $lte: 65 }
  }
})) {
  console.log(entry.value);
}
----

=== Delete com Where

Exclua entries que correspondem a um filtro:

[source,typescript]
----
// Excluir sessões expiradas
const result = await kv.delete(["sessions"], {
  where: { expiresAt: { $lt: kv.now() } }
});
console.log(`${result.deletedCount} sessões removidas`);

// Excluir usuários inativos há mais de 1 ano
await kv.delete(["users"], {
  where: {
    $and: [
      { status: { $eq: "inactive" } },
      { lastLogin: { $lt: kv.now().sub("1y") } }
    ]
  }
});
----

=== Filtros Complexos

Exemplo combinando vários operadores:

[source,typescript]
----
// Busca avançada de produtos
for await (const entry of kv.list(["products"], {
  where: {
    $and: [
      { "details.stock": { $gt: 0 } },
      { "details.price": { $between: [100, 500] } },
      {
        $or: [
          { category: { $eq: "electronics" } },
          { category: { $eq: "computers" } }
        ]
      },
      { name: { $notContainsi: "refurbished" } }
    ]
  },
  limit: 50
})) {
  console.log(entry.value);
}
----

=== Considerações de Performance

IMPORTANT: Where filters realizam table scan com filtragem via `json_extract()`. Para queries frequentes em datasets grandes, considere:

1. **Chaves compostas**: Inclua campos filtrados na chave
+
[source,typescript]
----
// Em vez de filtrar por status
await kv.set(["users_by_status", "active", odUserId], user);

// Liste diretamente pelo prefixo
for await (const entry of kv.list(["users_by_status", "active"])) {
  // Sem filtro necessário
}
----

2. **Índices FTS**: Para buscas de texto, use Full-Text Search
3. **Limite resultados**: Sempre use `limit` para evitar carregar muitos dados
