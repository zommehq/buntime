import DataEditor, {
  CompactSelection,
  type DrawHeaderCallback,
  type EditableGridCell,
  type GridCell,
  GridCellKind,
  type GridColumn,
  type GridSelection,
  type Item,
} from "@glideapps/glide-data-grid";
import "@glideapps/glide-data-grid/dist/index.css";
import {
  Badge,
  Button,
  cn,
  Icon,
  Input,
  ResizableHandle,
  ResizablePanel,
  ResizablePanelGroup,
  ScrollArea,
  Separator,
  Skeleton,
} from "@buntime/shadcn-ui";
import { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { api, type ColumnInfo, type TableInfo } from "../../helpers/api";

function createEmptySelection(): GridSelection {
  return {
    columns: CompactSelection.empty(),
    rows: CompactSelection.empty(),
  };
}

function formatCellValue(value: unknown): string {
  if (value === null || value === undefined) {
    return "NULL";
  }
  if (typeof value === "string") {
    return value.length > 100 ? `${value.slice(0, 100)}...` : value;
  }
  if (typeof value === "object") {
    const json = JSON.stringify(value);
    return json.length > 100 ? `${json.slice(0, 100)}...` : json;
  }
  return String(value);
}

export function DatabaseStudio() {
  // Sidebar state
  const [tables, setTables] = useState<TableInfo[]>([]);
  const [selectedTable, setSelectedTable] = useState<string>("");
  const [tableSearch, setTableSearch] = useState("");
  const [loadingTables, setLoadingTables] = useState(false);

  // Grid state
  const [columns, setColumns] = useState<ColumnInfo[]>([]);
  const [rows, setRows] = useState<Record<string, unknown>[]>([]);
  const [loading, setLoading] = useState(false);
  const [selection, setSelection] = useState<GridSelection>(createEmptySelection);

  // Pagination
  const [pageSize, setPageSize] = useState(50);
  const [currentPage, setCurrentPage] = useState(0);
  const [totalCount, setTotalCount] = useState(0);
  const [queryTime, setQueryTime] = useState(0);

  const gridRef = useRef<HTMLDivElement>(null);
  const portalRef = useRef<HTMLDivElement>(null);
  const [gridSize, setGridSize] = useState({ height: 500, width: 800 });

  // Observe grid container size
  useLayoutEffect(() => {
    const el = gridRef.current;
    if (!el) return;

    const updateSize = () => {
      const rect = el.getBoundingClientRect();
      const newWidth = Math.floor(rect.width);
      const newHeight = Math.floor(rect.height);
      if (newWidth > 0 && newHeight > 0) {
        setGridSize((prev) => {
          if (prev.width === newWidth && prev.height === newHeight) {
            return prev;
          }
          return { height: newHeight, width: newWidth };
        });
      }
    };

    requestAnimationFrame(updateSize);

    const observer = new ResizeObserver(() => {
      requestAnimationFrame(updateSize);
    });
    observer.observe(el);

    return () => observer.disconnect();
  }, []);

  // Load tables
  const loadTables = useCallback(async () => {
    setLoadingTables(true);
    try {
      const result = await api.getTables();
      setTables(result.tables);
    } catch (error) {
      console.error("Failed to load tables:", error);
    } finally {
      setLoadingTables(false);
    }
  }, []);

  // Load table data
  const loadTableData = useCallback(async () => {
    if (!selectedTable) return;

    setLoading(true);
    const startTime = performance.now();
    try {
      // Load schema and rows in parallel
      const [schemaResult, rowsResult] = await Promise.all([
        api.getTableSchema(selectedTable),
        api.getTableRows(selectedTable, {
          limit: pageSize,
          offset: currentPage * pageSize,
        }),
      ]);

      setColumns(schemaResult.columns);
      setRows(rowsResult.rows);
      setTotalCount(rowsResult.total);
      setQueryTime(Math.round(performance.now() - startTime));
    } catch (error) {
      console.error("Failed to load table data:", error);
    } finally {
      setLoading(false);
    }
  }, [selectedTable, pageSize, currentPage]);

  // Initial load
  useEffect(() => {
    loadTables();
  }, [loadTables]);

  // Load table data when selection or pagination changes
  useEffect(() => {
    if (selectedTable) {
      loadTableData();
    }
  }, [selectedTable, loadTableData]);

  const totalPages = Math.ceil(totalCount / pageSize);

  // Map column id -> type for custom header rendering
  const columnTypes = useMemo(
    () => new Map(columns.map((col) => [col.name, col.type.toLowerCase()])),
    [columns],
  );

  // Grid columns from schema
  const gridColumns: GridColumn[] = useMemo(
    () =>
      columns.map((col) => {
        const typeStr = col.type.toLowerCase();
        // Width based on name + type badge
        const baseWidth = Math.max(120, (col.name.length + typeStr.length + 2) * 8);

        return {
          grow: col.name === columns[columns.length - 1]?.name ? 1 : 0,
          id: col.name,
          title: col.name,
          width: baseWidth,
        };
      }),
    [columns],
  );

  // Custom header renderer with type badge
  const drawHeader: DrawHeaderCallback = useCallback(
    (args, draw) => {
      const { ctx, column, rect, theme } = args;
      const colType = columnTypes.get(column.id ?? "");

      // Draw default background first
      ctx.fillStyle = theme.bgHeader;
      ctx.fillRect(rect.x, rect.y, rect.width, rect.height);

      // Draw column name
      ctx.fillStyle = theme.textHeader;
      ctx.font = theme.headerFontStyle;
      const nameX = rect.x + 8;
      const nameY = rect.y + rect.height / 2 + 4;
      ctx.fillText(column.title, nameX, nameY);

      // Draw type badge if available
      if (colType) {
        const nameWidth = ctx.measureText(column.title).width;
        const badgeX = nameX + nameWidth + 6;
        const badgeY = rect.y + rect.height / 2 - 8;
        const badgeHeight = 16;
        const badgePadding = 6;

        // Measure badge text
        ctx.font = "10px ui-monospace, monospace";
        const typeWidth = ctx.measureText(colType).width;
        const badgeWidth = typeWidth + badgePadding * 2;

        // Draw badge background (rounded rect)
        const radius = 4;
        ctx.fillStyle = theme.bgBubble ?? "rgba(0,0,0,0.08)";
        ctx.beginPath();
        ctx.roundRect(badgeX, badgeY, badgeWidth, badgeHeight, radius);
        ctx.fill();

        // Draw badge text
        ctx.fillStyle = theme.textMedium ?? theme.textHeader;
        ctx.fillText(colType, badgeX + badgePadding, badgeY + 11);
      }

      return true; // We handled the drawing
    },
    [columnTypes],
  );

  // Determine cell kind based on column type
  const getCellKind = useCallback((colType: string): GridCellKind => {
    const type = colType.toLowerCase();
    if (
      type.includes("int") ||
      type.includes("real") ||
      type.includes("float") ||
      type.includes("double") ||
      type.includes("numeric") ||
      type.includes("decimal")
    ) {
      return GridCellKind.Number;
    }
    if (type.includes("bool")) {
      return GridCellKind.Boolean;
    }
    return GridCellKind.Text;
  }, []);

  const getCellContent = useCallback(
    ([col, row]: Item): GridCell => {
      const rowData = rows[row];
      const column = columns[col];
      if (!rowData || !column) {
        return {
          allowOverlay: false,
          data: "",
          displayData: "",
          kind: GridCellKind.Text,
        };
      }

      const value = rowData[column.name];
      const displayValue = formatCellValue(value);
      const cellKind = getCellKind(column.type);

      // Number cells
      if (cellKind === GridCellKind.Number) {
        const numValue = value === null ? undefined : Number(value);
        return {
          allowOverlay: true,
          copyData: value === null ? "" : String(value),
          data: numValue,
          displayData: value === null ? "NULL" : String(value),
          kind: GridCellKind.Number,
          readonly: column.pk, // Primary keys are read-only
        };
      }

      // Boolean cells
      if (cellKind === GridCellKind.Boolean) {
        return {
          allowOverlay: true,
          copyData: value === null ? "" : String(value),
          data: Boolean(value),
          kind: GridCellKind.Boolean,
          readonly: column.pk,
        };
      }

      // Text cells (default)
      const rawValue = value === null ? "" : String(value);
      return {
        allowOverlay: true,
        copyData: rawValue,
        data: rawValue, // Raw value for editing
        displayData: displayValue, // Formatted value for display
        kind: GridCellKind.Text,
        readonly: column.pk, // Primary keys are read-only
      };
    },
    [rows, columns, getCellKind],
  );

  // Handle cell edits
  const onCellEdited = useCallback(
    async ([col, row]: Item, newValue: EditableGridCell) => {
      const rowData = rows[row];
      const column = columns[col];
      if (!rowData || !column || column.pk) return;

      // Get the new value based on cell kind
      let value: unknown;
      if (newValue.kind === GridCellKind.Number) {
        value = newValue.data;
      } else if (newValue.kind === GridCellKind.Boolean) {
        value = newValue.data;
      } else if (newValue.kind === GridCellKind.Text) {
        value = newValue.data;
      } else {
        return;
      }

      // Find primary key column and value for WHERE clause
      const pkColumn = columns.find((c) => c.pk);
      if (!pkColumn) {
        console.warn("No primary key found, cannot update");
        return;
      }

      const pkValue = rowData[pkColumn.name];
      const escapedValue = typeof value === "string" ? `'${value.replace(/'/g, "''")}'` : value;
      const escapedPkValue =
        typeof pkValue === "string" ? `'${pkValue.replace(/'/g, "''")}'` : pkValue;

      const sql = `UPDATE "${selectedTable}" SET "${column.name}" = ${escapedValue} WHERE "${pkColumn.name}" = ${escapedPkValue}`;

      try {
        await api.executeQuery(sql);
        // Update local state optimistically
        setRows((prev) => {
          const updated = [...prev];
          updated[row] = { ...updated[row], [column.name]: value };
          return updated;
        });
      } catch (error) {
        console.error("Failed to update cell:", error);
        // Reload data on error
        loadTableData();
      }
    },
    [rows, columns, selectedTable, loadTableData],
  );

  const filteredTables = useMemo(() => {
    if (!tableSearch) return tables;
    return tables.filter((t) => t.name.toLowerCase().includes(tableSearch.toLowerCase()));
  }, [tables, tableSearch]);

  // Get computed CSS colors for glide-data-grid theme (convert oklch to rgb via canvas)
  const [colorsReady, setColorsReady] = useState(false);
  const [computedColors, setComputedColors] = useState<Record<string, string>>({
    accent: "#f4f4f5",
    background: "#ffffff",
    border: "#e4e4e7",
    foreground: "#09090b",
    muted: "#f4f4f5",
    mutedForeground: "#71717a",
    primary: "#6366f1",
  });

  useEffect(() => {
    // Use canvas to convert any CSS color to RGB format
    const canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const computeColor = (cssVar: string, fallback: string): string => {
      // Create element with the CSS variable as background
      const el = document.createElement("div");
      el.style.backgroundColor = `var(${cssVar})`;
      document.body.appendChild(el);
      const rawColor = getComputedStyle(el).backgroundColor;
      document.body.removeChild(el);

      // Use canvas to convert to RGB
      ctx.fillStyle = fallback; // Reset
      ctx.fillStyle = rawColor;
      ctx.fillRect(0, 0, 1, 1);
      const [r, g, b] = ctx.getImageData(0, 0, 1, 1).data;
      return `rgb(${r}, ${g}, ${b})`;
    };

    setComputedColors({
      accent: computeColor("--accent", "#f4f4f5"),
      background: computeColor("--background", "#ffffff"),
      border: computeColor("--border", "#e4e4e7"),
      foreground: computeColor("--foreground", "#09090b"),
      muted: computeColor("--muted", "#f4f4f5"),
      mutedForeground: computeColor("--muted-foreground", "#71717a"),
      primary: computeColor("--primary", "#6366f1"),
    });
    setColorsReady(true);
  }, []);

  const theme = useMemo(
    () => ({
      accentColor: computedColors.primary || "#6366f1",
      accentFg: "#ffffff",
      accentLight: "rgba(99, 102, 241, 0.1)",
      baseFontStyle: "13px",
      bgBubble: computedColors.muted || "#f4f4f5",
      bgBubbleSelected: computedColors.primary || "#6366f1",
      bgCell: computedColors.background || "#ffffff",
      bgCellMedium: computedColors.muted || "#f4f4f5",
      bgHeader: computedColors.muted || "#f4f4f5",
      bgHeaderHasFocus: computedColors.muted || "#f4f4f5",
      bgHeaderHovered: computedColors.accent || "#f4f4f5",
      bgIconHeader: computedColors.mutedForeground || "#71717a",
      bgSearchResult: "rgba(99, 102, 241, 0.2)",
      borderColor: computedColors.border || "rgba(0, 0, 0, 0.08)",
      cellHorizontalPadding: 8,
      cellVerticalPadding: 3,
      drilldownBorder: "rgba(0, 0, 0, 0)",
      editorFontSize: "13px",
      fgIconHeader: "#ffffff",
      fontFamily: "ui-monospace, monospace",
      headerFontStyle: "600 13px",
      headerIconSize: 18,
      horizontalBorderColor: computedColors.border || "rgba(0, 0, 0, 0.08)",
      lineHeight: 1.4,
      linkColor: computedColors.primary || "#6366f1",
      textBubble: computedColors.foreground || "#09090b",
      textDark: computedColors.foreground || "#09090b",
      textHeader: computedColors.mutedForeground || "#71717a",
      textHeaderSelected: "#ffffff",
      textLight: computedColors.mutedForeground || "#71717a",
      textMedium: computedColors.mutedForeground || "#71717a",
    }),
    [computedColors],
  );

  return (
    <ResizablePanelGroup className="h-full" direction="horizontal">
      {/* Sidebar */}
      <ResizablePanel defaultSize={20} maxSize={40} minSize={15}>
        <div className="flex h-full flex-col bg-muted/30">
          {/* Sidebar Header */}
          <div className="border-b border-border p-3">
            <div className="flex items-center gap-2 text-sm font-medium">
              <Icon className="size-4" icon="lucide:database" />
              Database Studio
            </div>
          </div>

          {/* Search */}
          <div className="flex items-center gap-1 border-b border-border p-2">
            <Input
              className="h-8 text-sm"
              placeholder="Search tables..."
              value={tableSearch}
              onChange={(e) => setTableSearch(e.target.value)}
            />
            <Button
              className="size-8 shrink-0"
              size="icon"
              title="Refresh"
              variant="ghost"
              onClick={loadTables}
            >
              <Icon
                className={cn("size-4", loadingTables && "animate-spin")}
                icon={loadingTables ? "lucide:loader-2" : "lucide:refresh-cw"}
              />
            </Button>
          </div>

          {/* Tables List */}
          <ScrollArea className="flex-1">
            <div className="p-1">
              {loadingTables ? (
                <div className="space-y-1 p-2">
                  {Array.from({ length: 5 }).map((_, i) => (
                    <Skeleton className="h-7 w-full" key={i} />
                  ))}
                </div>
              ) : filteredTables.length === 0 ? (
                <div className="p-4 text-center text-sm text-muted-foreground">No tables found</div>
              ) : (
                filteredTables.map((t) => (
                  <button
                    key={t.name}
                    className={cn(
                      "flex w-full items-center justify-between rounded-md px-2 py-1.5 text-left text-sm hover:bg-accent",
                      selectedTable === t.name && "bg-accent",
                    )}
                    type="button"
                    onClick={() => {
                      setSelectedTable(t.name);
                      setCurrentPage(0);
                    }}
                  >
                    <div className="flex items-center gap-2">
                      <Icon
                        className="size-4 text-muted-foreground"
                        icon={t.type === "view" ? "lucide:eye" : "lucide:table-2"}
                      />
                      <span className="truncate">{t.name}</span>
                    </div>
                    {t.type === "view" && (
                      <Badge size="sm" variant="outline">
                        view
                      </Badge>
                    )}
                  </button>
                ))
              )}
            </div>
          </ScrollArea>
        </div>
      </ResizablePanel>

      <ResizableHandle withHandle />

      {/* Main Content */}
      <ResizablePanel defaultSize={80}>
        <div className="flex h-full flex-col">
          {/* Toolbar */}
          <div className="flex items-center gap-2 border-b border-border px-3 py-2">
            {/* Table name */}
            {selectedTable && (
              <>
                <div className="flex items-center gap-2">
                  <Icon className="size-4 text-muted-foreground" icon="lucide:table-2" />
                  <span className="font-medium">{selectedTable}</span>
                </div>
                <Separator className="h-6" orientation="vertical" />
              </>
            )}

            {/* Navigation */}
            <Button
              className="h-8"
              disabled={currentPage === 0 || !selectedTable}
              size="sm"
              variant="ghost"
              onClick={() => setCurrentPage((p) => Math.max(0, p - 1))}
            >
              <Icon className="size-4" icon="lucide:chevron-left" />
            </Button>
            <Button
              className="h-8"
              disabled={currentPage >= totalPages - 1 || !selectedTable}
              size="sm"
              variant="ghost"
              onClick={() => setCurrentPage((p) => Math.min(totalPages - 1, p + 1))}
            >
              <Icon className="size-4" icon="lucide:chevron-right" />
            </Button>

            {/* Spacer */}
            <div className="flex-1" />

            {/* Stats */}
            {selectedTable && (
              <>
                <span className="text-sm text-muted-foreground">
                  {rows.length} of {totalCount} rows â€¢ {queryTime}ms
                </span>
                <Separator className="h-6" orientation="vertical" />
              </>
            )}

            {/* Page size */}
            <select
              className="h-8 rounded-md border bg-background px-2 text-sm"
              disabled={!selectedTable}
              value={pageSize}
              onChange={(e) => {
                setPageSize(Number(e.target.value));
                setCurrentPage(0);
              }}
            >
              <option value={25}>25</option>
              <option value={50}>50</option>
              <option value={100}>100</option>
              <option value={250}>250</option>
            </select>

            {/* Page indicator */}
            <span className="text-sm text-muted-foreground">
              {currentPage + 1} / {Math.max(1, totalPages)}
            </span>

            {/* Refresh */}
            <Button
              className="h-8"
              disabled={loading || !selectedTable}
              size="sm"
              variant="ghost"
              onClick={loadTableData}
            >
              <Icon
                className={cn("size-4", loading && "animate-spin")}
                icon={loading ? "lucide:loader-2" : "lucide:refresh-cw"}
              />
            </Button>
          </div>

          {/* Grid */}
          <div ref={gridRef} className="flex-1 overflow-hidden">
            {!selectedTable ? (
              <div className="flex h-full flex-col items-center justify-center text-muted-foreground">
                <Icon className="mb-4 size-12" icon="lucide:table-2" />
                <p>Select a table to view data</p>
              </div>
            ) : (loading && rows.length === 0) || !colorsReady ? (
              <div className="flex flex-col gap-1 p-4">
                {Array.from({ length: 10 }).map((_, i) => (
                  <Skeleton className="h-8 w-full" key={i} />
                ))}
              </div>
            ) : rows.length === 0 ? (
              <div className="flex h-full flex-col items-center justify-center text-muted-foreground">
                <Icon className="mb-4 size-12" icon="lucide:inbox" />
                <p>No rows in this table</p>
              </div>
            ) : (
              <>
                <div
                  ref={portalRef}
                  style={{
                    left: 0,
                    position: "fixed",
                    top: 0,
                    zIndex: 9999,
                  }}
                />
                <DataEditor
                  columns={gridColumns}
                  drawHeader={drawHeader}
                  getCellContent={getCellContent}
                  gridSelection={selection}
                  height={gridSize.height}
                  keybindings={{ search: true }}
                  portalElementRef={portalRef}
                  rowMarkers="number"
                  rows={rows.length}
                  smoothScrollX
                  smoothScrollY
                  theme={theme}
                  width={gridSize.width}
                  onCellEdited={onCellEdited}
                  onGridSelectionChange={setSelection}
                />
              </>
            )}
          </div>
        </div>
      </ResizablePanel>
    </ResizablePanelGroup>
  );
}
