= Sistema de Plugins
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

== Visão Geral

O sistema de plugins do Buntime permite extensibilidade modular do runtime através de componentes reutilizáveis. Plugins podem interceptar requests, modificar responses, fornecer APIs próprias, gerenciar workers e integrar-se ao ciclo de vida do servidor.

*Características Principais*:

* **Lifecycle Hooks**: Interceptação em diferentes estágios do request/response
* **Dependency Management**: Resolução automática de dependências entre plugins
* **Topological Ordering**: Execução ordenada baseada em dependências (via sort topológico)
* **Service Registry**: Compartilhamento de serviços entre plugins
* **Fragment Support**: Plugins podem fornecer UI embeddable no shell

== Arquitetura

== Componentes

[mermaid]
----
flowchart TD
    subgraph autodiscovery["Auto-Discovery"]
        D1["pluginDirs: ['./plugins']"]
        D2["plugins/plugin-*/manifest.jsonc<br/>enabled: true"]
    end

    subgraph loader["PluginLoader"]
        L1["Scan pluginDirs"]
        L2["Check enabled flag"]
        L3["Topological sort by dependencies"]
        L4["Initialize plugins in order"]
    end

    subgraph registry["PluginRegistry"]
        R1["Store loaded plugins"]
        R2["Run lifecycle hooks"]
        R3["Service registry"]
        R4["Route resolution"]
        R5["Public routes management"]
    end

    autodiscovery --> loader
    loader --> registry

    registry --> Metrics["Metrics<br/>onRequest"]
    registry --> AuthN["AuthN<br/>onRequest"]
    registry --> Gateway["Gateway<br/>onRequest"]
    registry --> KeyVal["KeyVal<br/>routes"]
----

== Resolução de Plugins

O `PluginLoader` resolve plugins em três estágios:

*1. Built-in Plugins (Auto-discovery)*:

Plugins são descobertos automaticamente através dos diretórios configurados em `pluginDirs`. O loader escaneia esses diretórios procurando por `manifest.jsonc` (manifesto do plugin):

[source,typescript]
----
// loader.ts - scanPluginDirs()
// Suporta múltiplas estruturas de diretório:
// 1. Direto: {pluginDir}/plugin.ts + manifest.jsonc
// 2. Subdiretório: {pluginDir}/{name}/plugin.ts + manifest.jsonc
// 3. Versionado: {pluginDir}/{name}/{version}/plugin.ts + manifest.jsonc
// 4. Scoped versionado: {pluginDir}/@scope/{name}/{version}/plugin.ts + manifest.jsonc

private async scanPluginDirs(pluginDirs: string[]): Promise<void> {
  for (const pluginDir of pluginDirs) {
    const entries = readdirSync(pluginDir);

    for (const entry of entries) {
      const entryPath = join(pluginDir, entry);
      const stat = statSync(entryPath);

      if (stat.isDirectory()) {
        if (entry.startsWith("@")) {
          // Scoped package: @scope/name/version/
          await this.scanScopedPackage(entryPath);
        } else {
          // Pode ser: {name}/plugin.ts OU {name}/{version}/
          const hasPluginFile = this.findPluginFile(entryPath);
          if (hasPluginFile) {
            await this.tryRegisterPlugin(hasPluginFile, entryPath);
          } else {
            await this.scanVersionedPackage(entryPath);
          }
        }
      }
    }
  }
}
----

*Manifesto do Plugin (manifest.jsonc)*:

Cada plugin deve ter um `manifest.jsonc` na raiz do diretório com metadata e configuração:

[source,jsonc]
----
// plugins/plugin-keyval/manifest.jsonc
{
  "name": "@buntime/plugin-keyval",  // Identificador unico (obrigatorio)
  "enabled": true,                    // Habilita/desabilita o plugin
  "base": "/keyval",                  // Base path para rotas (obrigatorio)
  "entrypoint": "dist/client/index.html",  // Entrypoint do cliente (se houver)
  "pluginEntry": "dist/plugin.js",    // Entrypoint do plugin (server-side)
  "dependencies": ["@buntime/plugin-database"],  // Dependencias obrigatorias
  "optionalDependencies": [],         // Dependencias opcionais
  "menus": [{ "title": "KeyVal", "icon": "lucide:database", "path": "/keyval" }]
}
----

[cols="1,1,1,2"]
|===
| Opção | Tipo | Default | Descrição

| `name`
| string
| -
| Identificador único do plugin (obrigatório). Formato: `@scope/plugin-name`

| `base`
| string
| -
| Base path para rotas do plugin (obrigatório). Formato: `/[a-zA-Z0-9_-]+`

| `enabled`
| boolean
| true
| Habilita ou desabilita o plugin. Se `false`, o plugin não é carregado.

| `entrypoint`
| string
| -
| Entrypoint do cliente para plugins com UI (ex: `dist/client/index.html`)

| `pluginEntry`
| string
| -
| Entrypoint do plugin (server-side: middlewares, hooks, rotas). Se não especificado, o loader tenta `plugin.{ts,js}` ou `index.{ts,js}` na raiz do diretório.

| `dependencies`
| string[]
| []
| Plugins que devem ser carregados antes deste (obrigatório)

| `optionalDependencies`
| string[]
| []
| Plugins opcionais (carregados se disponiveis)

| `menus`
| MenuItem[]
| -
| Items de menu para navegação no shell
|===

IMPORTANT: Plugins com `enabled: false` são ignorados pelo loader e pelo sistema de build. Isso permite ter plugins no diretório sem carregá-los.

=== Diferença entre `entrypoint` e `pluginEntry`

O manifest possui dois campos para especificar arquivos de entrada:

[cols="1,1,3"]
|===
| Campo | Propósito | Exemplo

| `entrypoint`
| Entrypoint da **aplicação** (client HTML ou server JS servido como app)
| `dist/client/index.html`

| `pluginEntry`
| Entrypoint do **plugin** (código server-side: middlewares, hooks, rotas)
| `dist/plugin.js`
|===

[source,jsonc]
----
{
  "name": "@buntime/plugin-example",
  "entrypoint": "dist/client/index.html",  // App client (HTML)
  "pluginEntry": "dist/plugin.js"          // Plugin server (JS)
}
----

**Comportamento do loader:**

1. Se `pluginEntry` está definido → usa esse caminho
2. Senão → fallback para `plugin.{ts,js}` ou `index.{ts,js}` na raiz do diretório

Lista completa de plugins builtin: authn, authz, database, deployments, durable, gateway, health, keyval, logs, metrics, proxy, vhosts.

*2. External Plugins (./plugins/)*:

Plugins locais no diretório `./plugins/`:

[source]
----
./plugins/
├── custom-auth.ts              # ./plugins/custom-auth.ts
└── company-metrics/
    └── index.ts                # ./plugins/company-metrics/index.ts
----

*3. Node Modules (Dev/Bundle Mode)*:

Plugins instalados via npm:

[source,bash]
----
bun add @company/buntime-plugin-sso
----

== Topological Sorting

Plugins são carregados em ordem baseada em dependências usando o algoritmo de Kahn:

[source,typescript]
----
// Plugins habilitados (cada um em seu manifest.jsonc)
// plugins/plugin-keyval/manifest.jsonc → enabled: true, dependencies: ["@buntime/plugin-database"]
// plugins/plugin-authn/manifest.jsonc → enabled: true, dependencies: []
// plugins/plugin-database/manifest.jsonc → enabled: true, dependencies: []

// Ordem de carregamento (após topological sort)
1. @buntime/plugin-database   (sem dependências)
2. @buntime/plugin-keyval     (depende de database)
3. @buntime/plugin-authn      (sem dependências)
----

*Tipos de Dependências*:

* **dependencies**: Obrigatórias, falha se não configurado
* **optionalDependencies**: Opcionais, carregadas se disponível

As dependências são declaradas no `manifest.jsonc` do plugin:

[source,jsonc]
----
// plugins/plugin-keyval/manifest.jsonc
{
  "name": "@buntime/plugin-keyval",
  "base": "/keyval",
  "dependencies": ["@buntime/plugin-database"],       // Obrigatório
  "optionalDependencies": ["@buntime/plugin-metrics"] // Opcional
}
----

O `plugin.ts` contém apenas a implementação:

[source,typescript]
----
// plugins/plugin-keyval/plugin.ts
export default function createPlugin(config: KeyValConfig): PluginImpl {
  return {
    routes: app,
    async onInit(ctx) { /* ... */ },
  };
}
----

== Version Management

O loader suporta plugins versionados em estrutura de diretório:

[source]
----
plugins/
├── @buntime/
│   └── plugin-keyval/
│       ├── 1.0.0/
│       │   ├── manifest.jsonc
│       │   └── plugin.ts
│       └── 2.0.0/
│           ├── manifest.jsonc
│           └── plugin.ts
----

*Métodos de Gerenciamento de Versão*:

[source,typescript]
----
// Listar versões disponíveis para um plugin
const versions = loader.getVersions("@buntime/plugin-keyval");
// ["2.0.0", "1.0.0"] (ordenado do mais recente para o mais antigo)

// Obter versão ativa
const active = loader.getActiveVersion("@buntime/plugin-keyval");
// "latest" ou "1.0.0"

// Definir versão ativa (efeito no próximo rescan)
loader.setActiveVersion("@buntime/plugin-keyval", "1.0.0");

// Listar todos os plugins com suas versões
const all = loader.list();
// [{ name: "@buntime/plugin-keyval", version: "2.0.0", versions: ["2.0.0", "1.0.0"] }]

// Rescan após instalar/remover plugins
await loader.rescan();
----

*Armazenamento de Versão*:

A versão ativa é armazenada no SQLite interno via `getPluginVersion`/`setPluginVersion`. Por padrão, a versão "latest" (mais recente) é usada.

== Lifecycle Hooks

== onInit

Chamado quando o plugin é inicializado, antes do servidor iniciar.

*Assinatura*:

[source,typescript]
----
onInit?: (ctx: PluginContext) => Promise<void> | void;
----

*Context*:

[source,typescript]
----
interface PluginContext {
  config: Record<string, unknown>;        // Configuração do plugin (campos extras do manifest)
  globalConfig: GlobalPluginConfig;       // Configuração global do runtime (workerDirs, poolSize)
  logger: PluginLogger;                   // Logger com contexto do plugin
  pool?: unknown;                         // WorkerPool instance
  registerService<T>(name: string, service: T): void;
  getService<T>(name: string): T | undefined;
}
----

*Timeout de Inicialização*:

O hook `onInit` possui um timeout de 30 segundos. Se a inicialização não completar nesse período, o plugin falha com erro de timeout. Isso previne que plugins mal configurados bloqueiem a inicialização do servidor indefinidamente.

*Exemplo*:

[source,typescript]
----
// plugins/plugin-keyval/plugin.ts
export default function createPlugin(config: KeyValConfig): PluginImpl {
  let db: DatabaseAdapter;
  let kv: Kv;

  return {
    async onInit(ctx) {
      // Obter serviço de outro plugin (definido via dependencies no manifest.jsonc)
      db = ctx.getService<DatabaseAdapter>("database")!;

      // Inicializar KV
      kv = new Kv({ db, logger: ctx.logger });
      await kv.init();

      // Registrar serviço para outros plugins
      ctx.registerService("kv", kv);

      ctx.logger.info("KeyVal initialized");
    },
  };
}
----

== Validação de Segurança

O `PluginLoader` valida plugins durante o carregamento para prevenir problemas de segurança.

*Validação de Base Path*:

O base path deve seguir o padrão `/[a-zA-Z0-9_-]+`:

[source,typescript]
----
// Válidos
"/metrics"
"/my-plugin"
"/auth_v2"

// Inválidos (causam erro)
"/my/nested/path"    // Múltiplos segmentos
"/../escape"         // Path traversal
"/my plugin"         // Espaços
----

*Paths Reservados*:

Os seguintes paths são reservados pelo runtime e não podem ser usados por plugins externos:

- `/api` - Rotas internas da API do runtime
- `/health` - Endpoint de health check (usado pelo plugin builtin `@buntime/plugin-health`)
- `/.well-known` - Recursos padrão web (ACME, etc.)

NOTE: Plugins builtin (como `@buntime/plugin-health`) podem usar paths reservados, pois são carregados antes da validação. Apenas plugins externos são bloqueados.

Tentativas de usar paths reservados resultam em erro durante o carregamento:

[source]
----
Error: Plugin "@company/my-plugin" cannot use reserved path "/health".
Reserved paths: /api, /health, /.well-known
----

== onRequest

Chamado para cada request antes de chegar ao worker.

*Assinatura*:

[source,typescript]
----
onRequest?: (
  req: Request,
  app?: AppInfo
) => Promise<Request | Response | undefined> | Request | Response | undefined;
----

*Retornos Possíveis*:

* **Request**: Request modificado (continua pipeline)
* **Response**: Short-circuit (retorna imediatamente)
* **undefined**: Continua com request original

*Exemplo (AuthN)*:

[source,typescript]
----
async onRequest(req: Request, app?: AppInfo) {
  const authHeader = req.headers.get("Authorization");

  if (!authHeader) {
    return new Response("Unauthorized", { status: 401 });
  }

  // Validar token
  const user = await validateToken(authHeader);

  if (!user) {
    return new Response("Invalid token", { status: 401 });
  }

  // Injetar usuário no request
  const newReq = new Request(req, {
    headers: {
      ...Object.fromEntries(req.headers),
      "x-user-id": user.id,
      "x-user-email": user.email,
    },
  });

  return newReq;
}
----

*Ordem de Execução*:

Plugins executam onRequest em ordem de registro (após sort topológico):

[mermaid]
----
flowchart TD
    Request --> Metrics["Metrics.onRequest<br/>(coleta métricas)"]
    Metrics --> Proxy["Proxy.onRequest<br/>(pode short-circuit)"]
    Proxy --> AuthN["AuthN.onRequest<br/>(injeta identidade)"]
    AuthN --> Gateway["Gateway.onRequest<br/>(rate limit)"]
    Gateway --> Worker["Worker.fetch"]
----

== onResponse

Chamado após o worker gerar a response, antes de enviar ao cliente.

*Assinatura*:

[source,typescript]
----
onResponse?: (res: Response, app: AppInfo) => Promise<Response> | Response;
----

*Exemplo (Metrics)*:

[source,typescript]
----
async onResponse(res: Response, app: AppInfo) {
  const duration = performance.now() - startTime;

  metrics.recordRequest({
    app: app.name,
    status: res.status,
    duration,
    method: req.method,
  });

  return res;  // Retorna response inalterado
}
----

== onWorkerSpawn

Chamado quando um worker é criado.

*Assinatura*:

[source,typescript]
----
onWorkerSpawn?: (worker: WorkerInstance, app: AppInfo) => void;
----

*Exemplo*:

[source,typescript]
----
onWorkerSpawn(worker, app) {
  logger.info(`Worker spawned: ${worker.id} for ${app.name}`);

  // Registrar worker em sistema de monitoramento
  monitoring.registerWorker(worker.id, app.name);
}
----

== onWorkerTerminate

Chamado quando um worker é terminado.

*Assinatura*:

[source,typescript]
----
onWorkerTerminate?: (worker: WorkerInstance, app: AppInfo) => void;
----

*Exemplo*:

[source,typescript]
----
onWorkerTerminate(worker, app) {
  logger.info(`Worker terminated: ${worker.id} (${worker.stats.requestCount} requests)`);

  monitoring.unregisterWorker(worker.id);
}
----

== onServerStart

Chamado após o `Bun.serve()` iniciar.

*Assinatura*:

[source,typescript]
----
onServerStart?: (server: Server<unknown>) => void;
----

*Uso*: Acesso ao server instance para WebSocket upgrades.

*Exemplo*:

[source,typescript]
----
// plugins/plugin-metrics/plugin.ts
let server: Server;

export default function createPlugin(): PluginImpl {
  return {
    onServerStart(srv) {
      server = srv;
      logger.info(`Server started on port ${server.port}`);
    },

    websocket: {
      open(ws) {
        logger.info("WebSocket connected");
      },
    },
  };
}
----

== onShutdown

Chamado quando o runtime está sendo encerrado.

*Assinatura*:

[source,typescript]
----
onShutdown?: () => Promise<void> | void;
----

*Ordem*: Plugins executam shutdown em ordem reversa (LIFO).

*Exemplo*:

[source,typescript]
----
async onShutdown() {
  logger.info("Shutting down KeyVal plugin");

  // Flush métricas pendentes
  await metrics.flush();

  // Fechar conexões DB
  await db.close();

  logger.info("KeyVal shutdown complete");
}
----

== Public Routes

Plugins e workers podem definir rotas públicas que pulam hooks `onRequest` (ex: autenticação).

== Formato de Configuração

*Array (todos métodos)*:

[source,typescript]
----
publicRoutes: ["/health", "/api/public/**"]
----

*Object (por método HTTP)*:

[source,typescript]
----
publicRoutes: {
  ALL: ["/health"],
  GET: ["/api/users/**"],
  POST: ["/api/webhook"]
}
----

== Wildcards

* **\*** - Match um segmento: `/api/*/health`
* **\**** - Match múltiplos segmentos: `/api/**`

== Plugin vs Worker Public Routes

*Plugin Public Routes*:

Paths absolutos, configuráveis em `manifest.jsonc`:

[source,jsonc]
----
// plugins/plugin-authn/manifest.jsonc
{
  "name": "@buntime/plugin-authn",
  "base": "/authn",
  "enabled": true,
  "publicRoutes": {
    "ALL": ["/health"],
    "POST": ["/api/authn/login", "/api/authn/register"]
  }
}
----

*Worker Public Routes*:

Paths relativos ao worker, configuráveis em `manifest.jsonc`:

[source,jsonc]
----
// apps/todos-kv/manifest.jsonc
{
  "publicRoutes": {
    "GET": ["/api/health", "/api/public/**"]
  }
}
----

Transformados em paths absolutos pelo runtime:

[source]
----
Worker: todos-kv
Base: /todos-kv

/api/health  →  /todos-kv/api/health
/api/public/** → /todos-kv/api/public/**
----

== Merge de Public Routes

Config routes são adicionadas às routes do plugin:

[source,typescript]
----
// Plugin define
publicRoutes: {
  POST: ["/api/authn/login"]
}

// Config adiciona
publicRoutes: {
  POST: ["/api/authn/register"]
}

// Resultado final
publicRoutes: {
  POST: ["/api/authn/login", "/api/authn/register"]
}
----

== Service Registry

Plugins podem registrar serviços para compartilhar funcionalidades.

== Registrando um Serviço

[source,typescript]
----
async onInit(ctx) {
  const db = await createDatabase(ctx.config);

  // Registrar serviço
  ctx.registerService("database", db);

  ctx.logger.info("Database service registered");
}
----

== Consumindo um Serviço

[source,typescript]
----
async onInit(ctx) {
  // Obter serviço de outro plugin
  const db = ctx.getService<DatabaseAdapter>("database");

  if (!db) {
    throw new Error("Database service not available");
  }

  // Usar serviço
  const kv = new Kv({ db });
}
----

== Exemplo Completo

[source,typescript]
----
// plugins/plugin-database/plugin.ts
export default function createDatabase(config: DbConfig): PluginImpl {
  let adapter: DatabaseAdapter;

  return {
    async onInit(ctx) {
      // Adapter configurado via manifest.jsonc do plugin
      adapter = new DatabaseAdapter(config.adapters);
      await adapter.connect();

      // Registrar serviço
      ctx.registerService("database", adapter);
    },

    async onShutdown() {
      await adapter.close();
    },
  };
}

// plugins/plugin-keyval/plugin.ts
// (manifest.jsonc define: dependencies: ["@buntime/plugin-database"])
export default function createKeyVal(): PluginImpl {
  let kv: Kv;

  return {
    async onInit(ctx) {
      // Consumir serviço (dependency definida no manifest.jsonc)
      const db = ctx.getService<DatabaseAdapter>("database")!;
      kv = new Kv({ db });

      // Registrar próprio serviço
      ctx.registerService("kv", kv);
    },
  };
}
----

== Registry Methods

A classe `PluginRegistry` gerencia plugins carregados e orquestra a execução de lifecycle hooks. A tabela abaixo documenta os métodos públicos disponíveis.

== Métodos de Lifecycle

[cols="2,3"]
|===
| Método | Descrição

| `runOnRequest(req: Request, app?: AppInfo): Promise<Request \| Response>`
| Executa todos os hooks `onRequest` em ordem de registro. Retorna o request modificado ou uma response para short-circuit. Se um plugin retornar `Response`, a execução para imediatamente.

| `runOnResponse(res: Response, app: AppInfo): Promise<Response>`
| Executa todos os hooks `onResponse` em ordem de registro. Cada plugin pode modificar a response antes de enviar ao cliente.

| `runOnServerStart(server: Server<unknown>): void`
| Notifica todos os plugins quando o servidor inicia via `Bun.serve()`. Plugins podem armazenar a referência do server para WebSocket upgrades.

| `runOnShutdown(): Promise<void>`
| Executa hooks de shutdown em ordem reversa (LIFO). Plugins carregados por último são encerrados primeiro, garantindo que dependências ainda estejam disponíveis durante cleanup.

| `runOnWorkerSpawn(worker: WorkerInstance, app: AppInfo): void`
| Chamado quando um novo worker é criado. Plugins podem registrar o worker em sistemas de monitoramento ou inicializar recursos específicos.

| `runOnWorkerTerminate(worker: WorkerInstance, app: AppInfo): void`
| Chamado quando um worker é terminado. Plugins podem coletar métricas finais ou limpar recursos associados ao worker.
|===

== Métodos de Resolução

[cols="2,3"]
|===
| Método | Descrição

| `getPluginBasePaths(): Set<string>`
| Retorna um `Set` com todos os base paths dos plugins registrados. Usado pelo app-shell para determinar quais paths devem ser interceptados.

| `resolvePluginApp(pathname: string): { dir: string; basePath: string } \| undefined`
| Resolve um pathname para o diretório e base path do plugin correspondente. Retorna `undefined` se nenhum plugin corresponder ao path.

| `collectServerRoutes(): Record<string, RouteHandler>`
| Coleta todas as rotas definidas em `server.routes` de cada plugin e aplica wrapper de autenticação. O resultado é usado diretamente em `Bun.serve({ routes })`.
|===

== Métodos de Serviço

[cols="2,3"]
|===
| Método | Descrição

| `registerService<T>(name: string, service: T): void`
| Registra um serviço para compartilhamento entre plugins. Se um serviço com o mesmo nome já existir, emite um warning e sobrescreve.

| `getService<T>(name: string): T \| undefined`
| Recupera um serviço registrado por outro plugin. Retorna `undefined` se o serviço não existir.
|===

== Métodos de Acesso

[cols="2,3"]
|===
| Método | Descrição

| `get(name: string): BuntimePlugin \| undefined`
| Retorna um plugin pelo nome.

| `getAll(): BuntimePlugin[]`
| Retorna todos os plugins em ordem de registro (após ordenação topológica).

| `has(name: string): boolean`
| Verifica se um plugin está registrado.

| `size: number`
| Propriedade que retorna o número de plugins registrados.

| `getPluginDir(name: string): string \| undefined`
| Retorna o diretório de um plugin (usado para spawning de workers).

| `getPluginsWithServerFetch(): BuntimePlugin[]`
| Retorna plugins que possuem `server.fetch` handlers.

| `getWebSocketHandler(): WebSocketHandler \| undefined`
| Retorna handler WebSocket combinado de todos os plugins. Se múltiplos plugins definem handlers, eles são combinados em um único handler.

| `getMountedPaths(): Map<string, string>`
| Retorna um `Map` com paths montados e seus plugins correspondentes. Usado para detecção de conflitos de rotas.

| `setMountedPaths(paths: Map<string, string>): void`
| Define os paths montados para detecção de conflitos. O mapa relaciona path com nome do plugin.
|===

== Exemplo de Uso

[source,typescript]
----
// Obtendo o registry do loader (retornado por load() ou rescan())
const registry = await loader.load();

// Verificar plugins carregados
console.log("Total:", registry.size);
console.log("Plugins:", registry.getAll().map((p) => p.name));

// Verificar base paths para routing
const bases = registry.getPluginBasePaths();
console.log("Plugin bases:", [...bases]);

// Resolver um path para plugin
const result = registry.resolvePluginApp("/keyval/api/entries");
if (result) {
  console.log("Plugin dir:", result.dir);
  console.log("Base path:", result.basePath);
}

// Obter serviço registrado por outro plugin
const kv = registry.getService<Kv>("kv");
----

== Plugin Server Module

Plugins podem servir arquivos estáticos e APIs diretamente no processo principal via `server.routes` e `server.fetch`.

== Server Routes

Routes são mapeadas para `Bun.serve({ routes })` com wrapper de autenticação.

[source,typescript]
----
// plugins/plugin-authn/plugin.ts
export default function createPlugin(): PluginImpl {
  return {
    server: {
      routes: {
        // Arquivo estático
        "/login": Bun.file("./public/login.html"),

        // Handler function
        "/api/health/*": () => new Response("OK"),

        // Handler async
        "/api/user": async (req) => {
          const user = await getUser(req);
          return Response.json(user);
        },
      },
    },

    publicRoutes: {
      GET: ["/login", "/api/health/**"],
    },
  };
}
----

== Server Fetch

Handler invocado após routes não matcharem, antes de routes Hono.

[source,typescript]
----
// plugins/plugin-api/plugin.ts
export default function createPlugin(): PluginImpl {
  const app = new Hono();

  app.get("/api/users", (c) => c.json({ users: [] }));

  return {
    server: {
      fetch: app.fetch,
    },
  };
}
----

== Ordem de Resolução

[mermaid]
----
flowchart TD
    Request --> BunRoutes{"Bun.serve routes<br/>(server.routes de todos plugins)"}
    BunRoutes --> Login["/login (plugin-authn)"]
    BunRoutes --> Health["/api/health/* (plugin-authn)"]
    BunRoutes -->|no match| ServerFetch{"server.fetch<br/>(de cada plugin em ordem)"}

    ServerFetch --> AuthnFetch["plugin-authn.server.fetch"]
    ServerFetch --> KeyvalFetch["plugin-keyval.server.fetch"]
    ServerFetch --> GatewayFetch["plugin-gateway.server.fetch"]
    ServerFetch -->|no match| HonoRoutes{"Hono app.routes<br/>(agregação de todos plugin.routes)"}

    HonoRoutes --> KeyvalAPI["/keyval/api/* (plugin-keyval)"]
    HonoRoutes --> MetricsAPI["/api/metrics/* (plugin-metrics)"]
----

== Middleware

Alternativa ao `onRequest` usando o padrão de middleware do Hono. O middleware é executado no contexto da aplicação Hono principal.

*Assinatura*:

[source,typescript]
----
middleware?: MiddlewareHandler;
----

*Exemplo*:

[source,typescript]
----
// plugins/request-logger/plugin.ts
import { createMiddleware } from "hono/factory";
import type { PluginImpl } from "@buntime/shared/types";

export default function createPlugin(): PluginImpl {
  return {
    middleware: createMiddleware(async (c, next) => {
      const start = Date.now();
      await next();
      const duration = Date.now() - start;
      console.log(`${c.req.method} ${c.req.path} - ${duration}ms`);
    }),
  };
}
----

*Diferença entre middleware e onRequest*:

[cols="1,2,2"]
|===
| Aspecto | middleware | onRequest

| Contexto
| Hono Context (c)
| Request + AppInfo

| Retorno
| Chama next() para continuar
| Retorna Request, Response ou undefined

| Posicionamento
| Executado dentro do Hono app
| Executado antes do Hono app
|===

== Micro-Frontend Support

Plugins com UI sao carregados no shell (C-Panel) via `<z-frame>` do pacote `@zomme/frame`.

=== Como Funciona

O shell usa o web component `<z-frame>` para carregar plugins em iframes isolados com comunicacao bidirecional via MessageChannel.

[source,tsx]
----
// Shell carrega plugin
<z-frame
  name="keyval"
  base="/keyval"
  src="http://localhost:8000/keyval"
/>
----

=== Configuracao do Plugin

Plugins com UI precisam de `entrypoint` (client) e `pluginEntry` (server) no manifest:

[source,jsonc]
----
// plugins/plugin-keyval/manifest.jsonc
{
  "name": "@buntime/plugin-keyval",
  "base": "/keyval",
  "entrypoint": "dist/client/index.html",
  "pluginEntry": "dist/plugin.js",
  "menus": [
    { "title": "KeyVal", "icon": "lucide:database", "path": "/keyval" }
  ]
}
----

=== Inicializando o SDK no Plugin

O client do plugin deve inicializar o `frameSDK`:

[source,tsx]
----
// plugins/plugin-keyval/client/index.tsx
import { frameSDK } from "@zomme/frame/sdk";

await frameSDK.initialize();

// Acessar props do shell
console.log(frameSDK.props.base); // "/keyval"

// Emitir eventos para o shell
frameSDK.emit("navigate", { path: "/keyval/details" });

// Registrar funcoes para o shell chamar
frameSDK.register("refresh", () => loadData());
----

=== Beneficios

- **Isolamento**: Iframes sandbox impedem acesso ao DOM do shell
- **Seguranca**: Cada plugin roda em contexto isolado
- **Comunicacao Tipada**: Props e eventos com TypeScript
- **RPC**: Funcoes podem ser chamadas entre shell e plugin

== Menu Items

Plugins definem items de menu para navegação no shell.

[source,typescript]
----
menus: [
  {
    title: "Logs",
    icon: "lucide:scroll-text",
    path: "/logs",
    priority: 10,
  },
  {
    title: "Reports",
    icon: "lucide:file-text",
    path: "/reports",
    items: [
      { title: "Daily", icon: "lucide:calendar", path: "/reports/daily" },
      { title: "Monthly", icon: "lucide:calendar-range", path: "/reports/monthly" },
    ],
  },
]
----

== Criando um Plugin Customizado

== Estrutura de Diretório

Um plugin customizado segue a estrutura:

[source]
----
plugins/my-plugin/
├── manifest.jsonc    # Metadata (name, base, dependencies, menus, etc.)
└── plugin.ts         # Implementação (hooks, routes, etc.)
----

== Manifesto (manifest.jsonc)

[source,jsonc]
----
// plugins/my-plugin/manifest.jsonc
{
  "name": "@company/my-plugin",
  "base": "/my-plugin",
  "enabled": true,
  "dependencies": [],
  "optionalDependencies": []
}
----

== Implementação (plugin.ts)

[source,typescript]
----
// plugins/my-plugin/plugin.ts
import type { PluginImpl, PluginContext } from "@buntime/shared/types";

export default function createMyPlugin(config: MyPluginConfig): PluginImpl {
  return {
    async onInit(ctx) {
      ctx.logger.info("Plugin initialized", { config: ctx.config });
    },

    async onRequest(req, app) {
      ctx.logger.debug("Request received", { url: req.url });
      return req;  // Continue pipeline
    },

    async onShutdown() {
      ctx.logger.info("Plugin shutdown");
    },
  };
}
----

== Factory Function

Plugins são factory functions que recebem configuração e retornam `PluginImpl`.

*Formato*:

[source,typescript]
----
export type PluginImplFactory = (
  config?: Record<string, unknown>
) => PluginImpl | Promise<PluginImpl>;
----

*Exemplos*:

[source,typescript]
----
// Sync factory
export default function createPlugin(config: MyConfig): PluginImpl {
  return { routes: app, onInit(ctx) { /* ... */ } };
}

// Async factory
export default async function createPlugin(config: MyConfig): Promise<PluginImpl> {
  const db = await initializeDb(config);
  return { routes: app, onInit(ctx) { /* ... */ } };
}
----

NOTE: Metadata (name, base, dependencies) vem do `manifest.jsonc`, não do retorno da factory function. O `plugin.ts` contém apenas a implementação (hooks, routes, middleware).

== Exemplo Completo: Rate Limiter

[source,typescript]
----
// plugins/rate-limiter/plugin.ts
import type { PluginImpl, PluginContext } from "@buntime/shared/types";

interface RateLimitConfig {
  maxRequests: number;
  windowMs: number;
}

interface RateLimitEntry {
  count: number;
  resetAt: number;
}

export default function createRateLimiter(config: RateLimitConfig): PluginImpl {
  const limits = new Map<string, RateLimitEntry>();
  const defaultConfig = { maxRequests: 100, windowMs: 60000 };
  const cfg = { ...defaultConfig, ...config };

  function getClientKey(req: Request): string {
    const forwarded = req.headers.get("x-forwarded-for");
    const ip = forwarded ? forwarded.split(",")[0] : "unknown";
    return ip || "unknown";
  }

  function checkRateLimit(key: string): boolean {
    const now = Date.now();
    const entry = limits.get(key);

    if (!entry || now > entry.resetAt) {
      limits.set(key, {
        count: 1,
        resetAt: now + cfg.windowMs,
      });
      return true;
    }

    if (entry.count >= cfg.maxRequests) {
      return false;
    }

    entry.count++;
    return true;
  }

  return {
    async onInit(ctx: PluginContext) {
      ctx.logger.info("Rate limiter initialized", {
        maxRequests: cfg.maxRequests,
        windowMs: cfg.windowMs,
      });

      // Cleanup expired entries every minute
      setInterval(() => {
        const now = Date.now();
        for (const [key, entry] of limits.entries()) {
          if (now > entry.resetAt) {
            limits.delete(key);
          }
        }
      }, 60000);
    },

    async onRequest(req: Request) {
      const key = getClientKey(req);
      const allowed = checkRateLimit(key);

      if (!allowed) {
        return new Response("Too Many Requests", {
          status: 429,
          headers: {
            "Retry-After": String(Math.ceil(cfg.windowMs / 1000)),
          },
        });
      }

      return req;
    },
  };
}
----

*Configuração*:

[source,jsonc]
----
// plugins/rate-limiter/manifest.jsonc
{
  "name": "@company/rate-limiter",
  "base": "/rate-limiter",
  "pluginEntry": "dist/plugin.js",
  "enabled": true,
  "maxRequests": 1000,
  "windowMs": 60000
}
----

== Exemplo Completo: Custom Logger

*Manifesto:*

[source,jsonc]
----
// plugins/custom-logger/manifest.jsonc
{
  "name": "@company/custom-logger",
  "base": "/logs",
  "enabled": true,
  "entrypoint": "dist/client/index.html",
  "menus": [
    { "title": "Logs", "icon": "lucide:scroll-text", "path": "/logs" }
  ]
}
----

*Implementação:*

[source,typescript]
----
// plugins/custom-logger/plugin.ts
import { Hono } from "hono";
import type { PluginImpl, PluginContext } from "@buntime/shared/types";

interface LogEntry {
  timestamp: string;
  level: string;
  message: string;
  meta?: Record<string, unknown>;
}

export default function createCustomLogger(): PluginImpl {
  const logs: LogEntry[] = [];
  const maxLogs = 1000;

  function addLog(level: string, message: string, meta?: Record<string, unknown>) {
    logs.push({
      timestamp: new Date().toISOString(),
      level,
      message,
      meta,
    });

    // Keep only last maxLogs entries
    if (logs.length > maxLogs) {
      logs.shift();
    }
  }

  const app = new Hono();

  // API para obter logs
  app.get("/api/logs", (c) => {
    const level = c.req.query("level");
    const limit = Number(c.req.query("limit")) || 100;

    let filtered = logs;
    if (level) {
      filtered = logs.filter((log) => log.level === level);
    }

    return c.json({
      logs: filtered.slice(-limit),
      total: filtered.length,
    });
  });

  return {
    routes: app,

    async onInit(ctx: PluginContext) {
      ctx.logger.info("Custom logger initialized");
    },

    async onRequest(req: Request, app) {
      addLog("info", "Request received", {
        url: req.url,
        method: req.method,
        app: app?.name,
      });

      return req;
    },

    async onResponse(res: Response, app) {
      addLog("info", "Response sent", {
        status: res.status,
        app: app.name,
      });

      return res;
    },
  };
}
----

== Best Practices

== Use Dependencies

Declare dependências explícitas no `manifest.jsonc` para garantir ordem de carregamento:

[source,jsonc]
----
// plugins/my-plugin/manifest.jsonc
{
  "name": "@company/my-plugin",
  "base": "/my-plugin",
  "dependencies": ["@buntime/plugin-database"],  // Obrigatório
  "optionalDependencies": ["@buntime/plugin-metrics"]  // Opcional
}
----

== Registre Serviços

Exponha funcionalidades para outros plugins via service registry:

[source,typescript]
----
async onInit(ctx) {
  const cache = new CacheService(ctx.config);
  ctx.registerService("cache", cache);
}
----

== Use Logger com Contexto

Use o logger fornecido para ter contexto automático:

[source,typescript]
----
async onRequest(req: Request, app) {
  ctx.logger.info("Processing request", { url: req.url, app: app?.name });
}
----

== Graceful Shutdown

Implemente `onShutdown` para cleanup de recursos:

[source,typescript]
----
async onShutdown() {
  await cache.flush();
  await db.close();
  clearInterval(cleanupTimer);
}
----

== Public Routes

Declare rotas públicas para evitar overhead de autenticação:

[source,typescript]
----
publicRoutes: {
  GET: ["/health", "/metrics"],
  POST: ["/webhook/**"],
}
----

== Error Handling

Trate erros gracefully nos hooks:

[source,typescript]
----
async onRequest(req: Request) {
  try {
    return await processRequest(req);
  } catch (error) {
    ctx.logger.error("Request processing failed", { error });
    return new Response("Internal Server Error", { status: 500 });
  }
}
----

== Debugging

== Logs

Use o logger do plugin para debugging:

[source,typescript]
----
ctx.logger.debug("Cache hit", { key, ttl });
ctx.logger.info("Request processed", { duration });
ctx.logger.warn("Rate limit approaching", { count, limit });
ctx.logger.error("Database error", { error });
----

== Plugin Registry

Inspecionar plugins carregados:

[source,typescript]
----
// registry é retornado por loader.load() ou loader.rescan()
console.log("Loaded plugins:", registry.getAll().map((p) => p.name));
console.log("Plugin count:", registry.size);
----

== Dependency Graph

Verificar ordem de carregamento:

[source,bash]
----
# Logs do PluginLoader mostram ordem
[PluginLoader] Loaded: @buntime/plugin-database
[PluginLoader] Loaded: @buntime/plugin-keyval
[PluginLoader] Loaded: @buntime/plugin-metrics
----

== Service Registry

Verificar serviços registrados:

[source,typescript]
----
const db = ctx.getService<DatabaseAdapter>("database");
if (!db) {
  ctx.logger.error("Database service not available");
}
----

== Utilitários

== getShortName

Função utilitária para extrair o nome curto de um plugin a partir do nome completo do pacote. Localizada em `runtime/src/utils/plugins.ts`.

*Assinatura*:

[source,typescript]
----
function getShortName(pluginName: string): string;
----

*Exemplos*:

[source,typescript]
----
import { getShortName } from "@/utils/plugins";

getShortName("@buntime/plugin-keyval");  // "keyval"
getShortName("@buntime/keyval");         // "keyval"
getShortName("@other/plugin-foo");       // "foo"
getShortName("@company/metrics");        // "metrics"
----

*Validação de Segurança*:

A função valida o resultado contra ataques de path traversal. Nomes resultantes devem conter apenas caracteres alfanuméricos e hifens (`[a-z0-9-]+`):

[source,typescript]
----
// Válidos
getShortName("@buntime/plugin-keyval");     // "keyval"
getShortName("@buntime/my-plugin");         // "my-plugin"

// Inválidos (lançam erro)
getShortName("@malicious/../../../etc");    // Error: invalid characters
getShortName("@bad/plugin with spaces");    // Error: invalid characters
----

== Worker Config Visibility

Workers podem definir uma propriedade `visibility` que controla como aparecem na UI de deployments.

== Tipos de Visibilidade

[cols="1,2,2"]
|===
| Valor | Descrição | Caso de Uso

| `public`
| Visível e editável na UI (padrão)
| Aplicações normais gerenciadas via UI

| `protected`
| Visível mas somente leitura
| Aplicações que não devem ser editadas acidentalmente

| `internal`
| Oculto da UI
| Serviços internos do runtime (authn, shell)
|===

== Configuração

*Em manifest.jsonc do app*:

[source,jsonc]
----
{
  "visibility": "internal"
}
----

*Exemplo de app interno*:

[source,jsonc]
----
// apps/authn-app@latest/manifest.jsonc
{
  "entrypoint": "server/index.ts",
  "visibility": "internal"
}
----

*Valor padrão*: Se não especificado, `visibility` é `"public"`.

== Limitações e Considerações

== Circular Dependencies

Dependências circulares são detectadas e causam erro:

[source]
----
Plugin A depends on B
Plugin B depends on A
→ Error: Circular dependency detected
----

== Service Availability

Serviços só estão disponíveis após o plugin que os registra ser inicializado:

[source,typescript]
----
// Plugin A (depende de B)
dependencies: ["plugin-b"]  // Garante que B carrega primeiro

async onInit(ctx) {
  const service = ctx.getService("service-b");  // Sempre disponível
}
----

== Hook Performance

Hooks `onRequest`/`onResponse` são chamados para cada request. Evite operações pesadas:

[source,typescript]
----
// Evite
async onRequest(req) {
  await heavyDatabaseQuery();  // Adiciona latência
}

// Prefira
async onRequest(req) {
  const cached = cache.get(key);  // Operação rápida
  if (cached) return cached;
}
----

== Public Routes Precedence

Public routes de plugins têm precedência sobre workers:

[source]
----
Plugin define: /api/health (public)
Worker define: /api/health

→ Plugin handler é executado, worker não recebe request
----
