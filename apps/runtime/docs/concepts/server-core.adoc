= Server Core
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

O núcleo do servidor Buntime é composto por três módulos principais que trabalham em conjunto para inicializar o runtime, carregar plugins e rotear requisições.

== Arquitetura

[source]
----
runtime/src/
├── index.ts              # Bun.serve entry point
├── api.ts                # Dependency initialization
├── app.ts                # Request resolution, CSRF, shell mode
├── config.ts             # Runtime configuration
├── constants.ts          # Environment variables
├── routes/
│   ├── apps-core.ts      # /api/core/apps (app management)
│   ├── config-core.ts    # /api/core/config (configuration management)
│   ├── health-core.ts    # /api/core/health (health checks)
│   ├── keys-core.ts      # /api/core/keys (API key management)
│   ├── plugins-core.ts   # /api/core/plugins (plugin management)
│   ├── plugins-info.ts   # /api/plugins (plugin metadata)
│   └── worker.ts         # /:app/* routes
└── utils/
    ├── request.ts        # Body cloning, size limits, URL rewriting
    ├── serve-static.ts   # Static file serving
    └── ...
----

== Fluxo de Inicialização

[source]
----
┌─────────────┐
│ constants.ts│ Valida env vars (PORT, NODE_ENV)
└──────┬──────┘
       │
┌──────▼──────┐
│   api.ts    │ Inicializa dependências:
│             │ 1. Logger global
│             │ 2. Inicializa config (env vars: workerDirs, poolSize)
│             │ 3. Cria WorkerPool
│             │ 4. Carrega plugins (PluginLoader)
│             │ 5. Cria rotas (apps-core, plugins-core, plugins-info, workers)
│             │ 6. Cria app (createApp)
└──────┬──────┘
       │
┌──────▼──────┐
│  index.ts   │ Inicia servidor:
│             │ 1. Bun.serve({ fetch: app.fetch })
│             │ 2. registry.runOnServerStart(server)
│             │ 3. Configura graceful shutdown
└─────────────┘
----

== Módulos

== constants.ts

Valida e exporta variáveis de ambiente usando Zod:

[source,typescript]
----
export const { DELAY_MS, NODE_ENV, PORT } = envSchema.parse(Bun.env);
export const IS_COMPILED = typeof BUNTIME_COMPILED !== "undefined" && BUNTIME_COMPILED;
export const IS_DEV = NODE_ENV === "development";
export const VERSION = version;  // from package.json
----

[cols="1,1,2"]
|===
| Variável | Padrão | Descrição

| `PORT`
| 8000
| Porta do servidor HTTP

| `NODE_ENV`
| development
| Ambiente de execução (development, production, staging, test)

| `DELAY_MS`
| 100
| Delay em ms antes de terminar worker (graceful shutdown)
|===

As seguintes constantes são derivadas no código (não são variáveis de ambiente):

[cols="1,1,2"]
|===
| Constante | Valor | Descrição

| `IS_COMPILED`
| false
| Se o runtime foi compilado para binário (detectado via `typeof BUNTIME_COMPILED`)

| `VERSION`
| package.json
| Versão do runtime (lido do package.json)

| `SHUTDOWN_TIMEOUT_MS`
| 30000
| Timeout de graceful shutdown (30s)
|===

Além das variáveis de ambiente, o módulo exporta constantes para uso interno:

[cols="1,2"]
|===
| Constante | Descrição

| `Headers`
| Headers HTTP customizados (x-base, x-buntime-internal, x-not-found, x-request-id, sec-fetch-dest, sec-fetch-mode)

| `MessageTypes`
| Tipos de mensagem IPC (READY, REQUEST, RESPONSE, ERROR, IDLE, TERMINATE)

| `BodySizeLimits`
| Limites de tamanho de body (DEFAULT: 10MB, MAX: 100MB)

| `WorkerState`
| Estados do worker (active, idle, ephemeral, offline)

| `APP_NAME_PATTERN`
| Regex para extrair nome do app do pathname (`/^\/([^/]+)/`)

| `ContentTypes`
| Content-types HTTP comuns (HTML, JSON, PLAIN)
|===

== config.ts

Carrega configuração do runtime a partir de variáveis de ambiente:

[source,typescript]
----
interface RuntimeConfig {
  bodySize: {
    default: number;       // Limite padrão de body (10MB)
    max: number;           // Limite máximo de body (100MB)
  };
  delayMs: number;         // Rate limit delay
  homepage?: string | HomepageConfig;  // App ou config de homepage
  isCompiled: boolean;     // Se é binário compilado
  isDev: boolean;          // Se está em modo dev
  nodeEnv: string;         // development|production|staging|test
  pluginDirs: string[];    // Diretórios de plugins externos
  poolSize: number;        // Tamanho do pool de workers
  port: number;            // Porta do servidor
  version: string;         // Versão do runtime
  workerDirs: string[];    // Diretórios de apps (obrigatório)
}
----

=== Inicialização

[source,typescript]
----
// Inicializa config a partir de variáveis de ambiente
const runtimeConfig = initConfig();

// Usa config
console.log(runtimeConfig.workerDirs);  // ["/path/to/apps"]
console.log(runtimeConfig.poolSize);    // 100
----

=== Variáveis de Ambiente

[cols="1,1,1"]
|===
| Campo | Env Var | Padrão

| `workerDirs`
| `WORKER_DIRS=/apps,/more`
| ERRO (obrigatório)

| `pluginDirs`
| `PLUGIN_DIRS=/plugins`
| `["./plugins"]`

| `poolSize`
| `POOL_SIZE=50`
| 500 (prod), 10 (dev), 50 (staging), 5 (test)

| `homepage`
| `HOMEPAGE_APP=cpanel`
| undefined
|===

Além das variáveis acima, `config.ts` também parseia estas variáveis de ambiente:

[cols="1,1,2"]
|===
| Variável | Padrão | Descrição

| `POOL_SIZE`
| Por ambiente (dev: 10, prod: 500, staging: 50, test: 5)
| Tamanho do pool de workers

| `HOMEPAGE_APP`
| undefined
| App para servir na raiz (formato string apenas via env var)

| `WORKER_DIRS`
| ERRO (obrigatório)
| Diretórios de apps (suporta valores separados por vírgula)
|===

=== Resolução de Caminhos

Caminhos relativos em `WORKER_DIRS` são resolvidos contra o diretório de trabalho atual:

[source]
----
# WORKER_DIRS=./apps,/abs/path
/project/
└── apps/
    └── todos/

Resultado: ["/project/apps", "/abs/path"]
----

Variáveis de ambiente podem ser usadas nos valores:

[source,bash]
----
WORKER_DIRS=${HOME}/apps,${PROJECT_DIR}/examples
----

== api.ts

Inicializa todas as dependências e exporta o app Hono pronto para uso.

IMPORTANT: Este módulo NÃO inicia o servidor. Ele apenas prepara o app para ser usado por `index.ts` (produção) ou `index.tsx` (dev com frontend).

=== Sequência de Inicialização

[source,typescript]
----
// 1. Logger global
const logger = createLogger({
  format: NODE_ENV === "production" ? "json" : "pretty",
  level: NODE_ENV === "production" ? "info" : "debug",
});
setLogger(logger);

// 2. Inicializa config do runtime (variáveis de ambiente)
const runtimeConfig = initConfig();

// 3. Cria pool de workers
const pool = new WorkerPool({ maxSize: runtimeConfig.poolSize });

// 4. Cria resolver de apps
const getWorkerDir = createAppResolver(runtimeConfig.workerDirs);

// 5. Carrega plugins
const loader = new PluginLoader({ pool });
const registry = await loader.load();

// 6. Cria rotas
const pluginsCoreRoutes = createPluginsCoreRoutes({ loader });
const pluginsInfoRoutes = createPluginsInfoRoutes({ registry });
const appsCoreRoutes = createAppsCoreRoutes();
const configCoreRoutes = createConfigCoreRoutes({ loader });
const healthCoreRoutes = createHealthCoreRoutes();
const keysCoreRoutes = createKeysCoreRoutes();
const workerRoutes = createWorkerRoutes({ config: runtimeConfig, getWorkerDir, pool, registry });

// 7. Cria app
const app = createApp({
  pluginsCoreRoutes,
  pluginsInfoRoutes,
  appsCoreRoutes,
  configCoreRoutes,
  healthCoreRoutes,
  keysCoreRoutes,
  workerRoutes,
  ...
});

// 8. Coleta recursos de plugins
const websocket = registry.getWebSocketHandler();
const pluginRoutes = registry.collectServerRoutes();
----

NOTE: Plugins sempre têm prioridade sobre apps regulares quando há conflito de rotas.

=== Exports

[cols="1,2"]
|===
| Export | Descrição

| `app`
| Hono app principal (fetch handler)

| `runtimeConfig`
| Configuração do runtime (via getConfig())

| `hasPluginRoutes`
| Se há rotas de plugins para Bun.serve

| `logger`
| Logger global instance

| `pluginRoutes`
| Rotas de `server.routes` dos plugins

| `pool`
| WorkerPool instance

| `registry`
| PluginRegistry instance

| `websocket`
| WebSocket handler de plugins (se houver)
|===

NOTE: `runtimeConfig` é acessado via `getConfig()` que retorna a configuração inicializada a partir das variáveis de ambiente.

== app.ts

Cria o app Hono principal e implementa a lógica de resolução de rotas, proteção CSRF e roteamento app-shell.

=== Segurança

==== CSRF Protection

O runtime valida requests que modificam estado (POST, PUT, PATCH, DELETE) para prevenir Cross-Site Request Forgery:

[mermaid]
----
flowchart TD
    A[Request state-changing] --> B{Origin header presente?}
    B -->|Não| C{X-Buntime-Internal: true?}
    B -->|Sim| D{Origin == Host?}
    C -->|Sim| E[OK]
    C -->|Não| F[403]
    D -->|Sim| G[OK]
    D -->|Não| H[403]
----

Validações realizadas:

1. **Origin obrigatório**: Requests sem Origin recebem 403, exceto se possuírem `X-Buntime-Internal: true` (comunicação worker-to-runtime)
2. **Origin válido**: URL parsing seguro, rejeita credenciais embutidas (`user:pass@host`)
3. **Protocolo válido**: Apenas `http:` e `https:` aceitos
4. **Host match**: `Origin.host` deve ser igual ao header `Host`

[source,typescript]
----
// Exemplo de request bloqueado
// Origin: https://evil.com
// Host: localhost:8000
// Result: 403 Forbidden

// Exemplo de request permitido (interno)
// Origin: (ausente)
// X-Buntime-Internal: true
// Result: Prossegue (comunicação interna worker-to-runtime)
----

==== Request Correlation

Toda request recebe um ID único para rastreamento:

[source,typescript]
----
// Geração do ID
const requestId = req.headers.get("x-request-id") ?? crypto.randomUUID();

// Incluído em todas as responses
response.headers.set("x-request-id", requestId);
----

O ID aparece em logs para correlacionar eventos:

[source]
----
INFO [app] Request received { requestId: "550e8400-e29b-41d4-a716-446655440000" }
WARN [csrf] Validation failed { requestId: "550e8400-e29b-41d4-a716-446655440000" }
----

==== Body Size Limits

Requests com body grande são rejeitados para prevenir DoS:

[source,typescript]
----
try {
  requestBody = await cloneRequestBody(req, maxBodySize);
} catch (err) {
  if (err instanceof BodyTooLargeError) {
    return new Response("Payload Too Large", { status: 413 });
  }
}
----

Limites configuráveis por worker (veja <<../deployment/configuration.adoc#body-size>>).

=== App-Shell Mode

O runtime suporta arquitetura micro-frontend onde um "shell" (cpanel) carrega plugins via `<z-frame>` (iframes com comunicacao bidirecional).

==== Configuracao

[source,bash]
----
# .env
HOMEPAGE_APP=cpanel
----

==== Fluxo

[mermaid]
----
sequenceDiagram
    participant B as Browser
    participant R as Runtime
    participant S as Shell Worker
    participant P as Plugin Worker

    B->>R: GET /metrics (navigate)
    Note over R: Sec-Fetch-Mode: navigate
    R->>S: Request para shell
    S->>B: HTML com z-frame

    Note over B: z-frame cria iframe
    B->>R: GET /metrics/ (iframe src)
    R->>P: Request para plugin-metrics
    P->>B: Plugin HTML
    Note over B: MessageChannel estabelecido
----

==== Decisao de Roteamento

A funcao `shouldRouteToShell` determina se uma request vai para o shell:

[cols="2,1,2"]
|===
| Condicao | Shell? | Motivo

| `Sec-Fetch-Mode: navigate` + path `/`
| Sim
| Homepage sempre via shell

| `Sec-Fetch-Mode: navigate` + path `/metrics`
| Sim
| Plugin base match

| Path contem `/api/`
| Nao
| APIs nao passam pelo shell

| Request de iframe (Sec-Fetch-Dest: iframe)
| Nao
| Plugin carrega diretamente
|===

==== Headers Injetados

O shell recebe headers especiais:

[cols="1,2"]
|===
| Header | Descricao

| `x-not-found`
| `true` se nenhum app foi resolvido (shell decide como exibir 404)

| `x-base`
| Base path do shell para assets
|===

=== Request Resolution Flow

O fluxo de resolução de requests ocorre em etapas ordenadas por prioridade:

[mermaid]
----
flowchart TD
    A[Request arrives] --> B{CSRF check<br/>POST/PUT/PATCH/DELETE}
    B -->|Fail| C[403 Forbidden]
    B -->|Pass| D{App-shell mode?<br/>Sec-Fetch-Mode: navigate}
    D -->|Sim| E[Serve via shell]
    D -->|Não| F["Run onRequest hooks<br/>(auth, metrics, etc.)"]
    F -->|Auth failed| G[401/403]
    F -->|Pass| G1{"/api/core/plugins?"}
    G1 -->|Sim| G2[Plugins core routes]
    G1 -->|Não| G3{"/api/core/apps?"}
    G3 -->|Sim| G4[Apps core routes]
    G3 -->|Não| H{"/api/plugins?"}
    H -->|Sim| I[Plugins info routes]
    H -->|Não| J["Plugin server.fetch"]
    J -->|404?| K["Plugin routes (Hono)"]
    K -->|404?| L["Plugin apps (pool)"]
    L -->|404?| M["Worker routes /:app/*"]
    M -->|404?| N{Shell disponível?}
    N -->|Sim| O[Shell com x-not-found: true]
    N -->|Não| P[404 Not Found]
----

Ordem de execução dentro do handler `app.all("*")`:

1. **CSRF Protection**: Valida requests state-changing (POST, PUT, PATCH, DELETE)
2. **Shell mode**: Se navegação (`Sec-Fetch-Mode: navigate`) e path é plugin base, roteia para shell
3. **onRequest hooks**: Plugins executam autenticação, métricas, rate limiting
4. **Plugins Core**: Rota `/api/core/plugins` para gerenciamento de plugins (upload, reload, etc.)
5. **Apps Core**: Rota `/api/core/apps` para gerenciamento de apps (upload, etc.)
6. **Plugins Info**: Rota `/api/plugins` para metadados de plugins
7. **Plugin server.fetch**: Handlers customizados de plugins
8. **Plugin routes (Hono)**: Rotas Hono montadas por plugins
9. **Plugin apps**: Apps de plugins via worker pool
10. **Worker routes**: Apps regulares em workerDirs (`/:app/*`)
11. **404 handling**: Shell exibe página de erro ou retorna 404

NOTE: As rotas públicas (configuradas em `publicRoutes`) são verificadas dentro dos hooks `onRequest`, permitindo acesso sem autenticação a endpoints específicos.

=== Resolução de Target App

O `resolveTargetApp` determina qual app irá processar a requisição:

[source,typescript]
----
async function resolveTargetApp(
  pathname: string,
  registry: PluginRegistry,
  getWorkerDir: (name: string) => string | undefined,
): Promise<ResolvedApp | undefined>
----

Retorna informações sobre o app resolvido:

[source,typescript]
----
interface ResolvedApp {
  type: "plugin" | "worker";     // Tipo do app
  name: string;                   // Nome do app
  dir: string;                    // Diretório do app
  basePath: string;               // Base path (ex: /todos)
  config: WorkerConfig;           // Configuração do worker
}
----

=== Ordem de Resolução

1. **Plugin apps** (via `registry.resolvePluginApp`)
   - Configurados em plugins com `app` option
   - Exemplo: `@buntime/plugin-proxy` com `{ app: "todos", base: "/todos" }`

2. **Worker apps regulares** (pattern `/:app/*`)
   - Apps em diretórios de `workerDirs`
   - Exemplo: `apps/todos/` responde em `/todos/*`

=== Semantic Versioning

O runtime suporta versionamento semântico completo de apps através do `createAppResolver`.

==== Formatos de Diretório

O resolver suporta dois formatos de organização:

*Flat (recomendado para deploy)*:

[source]
----
appDir/
├── todos@1.0.0/
├── todos@1.1.0/
├── todos@latest/
└── api@2.0.0/
----

*Nested (recomendado para desenvolvimento)*:

[source]
----
appDir/
├── todos/
│   ├── 1.0.0/
│   ├── 1.1.0/
│   └── latest/
└── api/
    └── 2.0.0/
----

O formato flat é verificado primeiro, permitindo deploy atômico via symlinks ou renames.

==== Resolução de Versão

[cols="2,3"]
|===
| Formato | Comportamento

| `app-name`
| Prefere `@latest` se existir, senão maior versão semver

| `app-name@latest`
| Versão especial "latest" (não-semver)

| `app-name@1`
| Maior versão compatível com 1.x.x

| `app-name@1.4`
| Maior versão compatível com 1.4.x

| `app-name@1.4.2`
| Versão exata

| `app-name@^1.0.0`
| Range semver (compatible)

| `app-name@~1.4.0`
| Range semver (patch updates)

| `app-name@>=2.0.0`
| Range semver (minimum)
|===

==== Pre-release Versions

Pre-releases são incluídos na resolução:

[source]
----
appDir/
├── api@2.0.0-rc.1/
├── api@2.0.0-beta.2/
└── api@2.0.0/

getWorkerDir("api@^2.0.0-rc")  → api@2.0.0-rc.1
getWorkerDir("api@2")          → api@2.0.0
----

==== Tag "latest"

O tag `@latest` tem prioridade especial sobre versões semver:

[mermaid]
----
flowchart TD
    A[getWorkerDir] --> B{version especificada?}
    B -->|"@latest"| C[Retorna diretório @latest]
    B -->|"@1.x"| D[maxSatisfying semver]
    B -->|nenhuma| E{"@latest existe?"}
    E -->|sim| C
    E -->|não| F[Maior versão semver]
----

==== Exemplo de Uso

[source,typescript]
----
const getWorkerDir = createAppResolver(["/apps", "/external"]);

// Busca em todos os workerDirs
getWorkerDir("todos");           // /apps/todos@latest ou maior semver
getWorkerDir("todos@1.4");       // /apps/todos@1.4.2 (maior 1.4.x)
getWorkerDir("api@^2.0.0");      // /external/api@2.1.0

// Retorna string vazia se não encontrar
getWorkerDir("nonexistent");     // ""
----

NOTE: AppDirs são pesquisados em ordem. O primeiro match prevalece, permitindo overlays de versão.

=== Base Path Injection

Apps servidos sob subpaths recebem o header `x-base` para configurar o router:

[source,typescript]
----
// Plugin app em /todos
const basePath = "/todos";
const newReq = new Request(new URL(pathname + url.search, req.url).href, req);
newReq.headers.set("x-base", basePath);

// Worker recebe:
// GET /todos/api/items
// x-base: /todos
//
// Processa internamente como:
// GET /api/items
----

O worker usa `x-base` para:

1. Configurar `<base href>` em HTML
2. Configurar `basepath` do TanStack Router
3. Gerar URLs absolutas corretas

Exemplo no worker:

[source,typescript]
----
// wrapper.ts injeta base no HTML
const baseTag = `<base href="${base}/">`;
html = html.replace("</head>", `${baseTag}</head>`);

// client/index.tsx lê base tag
const base = document.querySelector("base")?.getAttribute("href") || "/";
const router = createRouter({ basepath: base, ... });
----

=== Fragments

Micro-frontends sao servidos atraves do mecanismo de app-shell usando `<z-frame>` (pacote `@zomme/frame`). Quando uma navegacao ocorre para um path de plugin (ex: `/metrics`), o runtime:

1. Detecta `Sec-Fetch-Mode: navigate` indicando navegacao do browser
2. Roteia para o shell worker com headers especiais
3. O shell renderiza o layout com `<z-frame>` apontando para o plugin
4. O `<z-frame>` cria um iframe e estabelece comunicacao via MessageChannel

Exemplo:

[source,html]
----
<!-- Shell recebe navegacao para /metrics -->
<!-- Headers injetados: x-base: /cpanel -->

<!-- Shell HTML -->
<z-frame
  name="metrics"
  base="/metrics"
  src="http://localhost:8000/metrics"
  pathname="/"
></z-frame>

<!-- z-frame cria iframe com src -->
<!-- Iframe carrega plugin @buntime/plugin-metrics -->
<!-- MessageChannel estabelecido para comunicacao bidirecional -->
----

O `<z-frame>` e um web component que:

1. Cria um iframe sandbox com o src do plugin
2. Estabelece MessageChannel para comunicacao bidirecional
3. Sincroniza props e eventos entre shell e plugin
4. Permite chamadas RPC de funcoes registradas

=== Plugin Routes Priority

Plugin routes são montadas em ordem de especificidade (mais específica primeiro):

[source,typescript]
----
// Plugins:
// - @buntime/plugin-keyval: /keyval/api
// - @buntime/plugin-metrics: /api/metrics
// - @buntime/plugin-root: /

// Ordem de matching:
const sortedPaths = ["/keyval/api", "/api/metrics", "/"].sort(
  (a, b) => b.length - a.length
);

// Request: /keyval/api/get
// Match: /keyval/api (corresponde)
----

IMPORTANT: Se dois plugins tentarem montar no mesmo path, ocorre erro na inicialização.

== index.ts

Entry point de produção que inicia o servidor Bun.

=== Configuração do Servidor

O servidor é configurado dinamicamente baseado nos recursos disponíveis:

[source,typescript]
----
const server = Bun.serve({
  fetch: app.fetch,
  idleTimeout: 0,  // Desabilita timeout - necessário para SSE/WebSocket
  port: PORT,
  routes: { "/favicon.ico": new Response(null, { status: 204 }) },
  ...(isDev && { development: { hmr: true } }),
  ...(hasPluginRoutes && { routes: pluginRoutes }),
  ...(websocket && { websocket }),
});
----

[cols="1,2"]
|===
| Opção | Descrição

| `idleTimeout: 0`
| Desabilita timeout de conexões idle. Necessário para SSE (Server-Sent Events) e WebSocket que mantêm conexões de longa duração.

| `routes: { "/favicon.ico": ... }`
| Rota default para retornar 204 (No Content) para requisições de favicon, evitando logs desnecessários.

| `development.hmr`
| Ativa Hot Module Replacement em modo development.

| `routes` (plugin)
| Rotas nativas do Bun.serve (plugin `server.routes`).

| `websocket`
| Handler WebSocket de plugins.
|===

=== Plugin Routes vs Hono Routes

Existem dois tipos de rotas de plugins:

1. **Hono routes** (`plugin.routes`)
   - Hono app montado no app principal
   - Processado via `app.fetch` (sem worker pool)
   - Exemplo: `/keyval/api/*` (REST API)

2. **Server routes** (`plugin.server.routes`)
   - Pattern matching nativo do Bun.serve
   - Processado antes do fetch handler
   - Usado para WebSocket e file serving otimizado

[source,typescript]
----
// Coleta server.routes de todos os plugins
const pluginRoutes = registry.collectServerRoutes();

// Exemplo de server.routes:
{
  "/ws": {
    upgrade: (req, server) => server.upgrade(req),
  },
  "/public/*": {
    fetch: (req) => serveFile(req),
  },
}
----

NOTE: `server.routes` tem performance superior para WebSocket e static files, mas `plugin.routes` (Hono) é mais flexível e suporta autenticação via middleware.

=== Lifecycle Hooks

[source,typescript]
----
// Após servidor iniciar
const server = startServer();
registry.runOnServerStart(server);

// Graceful shutdown com timeout
process.on("SIGINT", async () => {
  logger.info("Shutting down...");

  // Force exit após timeout (30s) para plugins mal comportados
  const forceExitTimer = setTimeout(() => {
    logger.error("Shutdown timeout exceeded, forcing exit");
    process.exit(1);
  }, SHUTDOWN_TIMEOUT_MS);

  try {
    // 1. Notifica plugins
    await registry.runOnShutdown();

    // 2. Encerra workers
    pool.shutdown();

    // 3. Flush de logs
    await logger.flush();

    clearTimeout(forceExitTimer);
    process.exit(0);
  } catch (err) {
    logger.error("Error during shutdown", { error: err });
    clearTimeout(forceExitTimer);
    process.exit(1);
  }
});
----

O timeout de shutdown (30 segundos) previne que plugins mal comportados bloqueiem o encerramento indefinidamente.

=== Hot Module Replacement

Em modo development, HMR é ativado automaticamente:

[source,typescript]
----
const isDev = NODE_ENV === "development";

Bun.serve({
  fetch: app.fetch,
  port: PORT,
  ...(isDev && { development: { hmr: true } }),
});
----

NOTE: HMR funciona apenas para o código do runtime. Workers são recarregados via `pool.reload()`.

== Uso Programático

O runtime pode ser usado como biblioteca:

[source,typescript]
----
import { createApp } from "@buntime/runtime/app";
import { loadBuntimeConfig, PluginLoader } from "@buntime/runtime/plugins/loader";

// 1. Carrega config
const { config, baseDir } = await loadBuntimeConfig();

// 2. Carrega plugins
const loader = new PluginLoader({ pool });
const registry = await loader.load();

// 3. Cria app
const app = createApp({ ... });

// 4. Usa em servidor customizado
Bun.serve({ fetch: app.fetch, port: 3000 });
----

== Boas Práticas

== DO

* Use `getConfig()` para acessar configuração após inicialização
* Sempre aguarde `registry.shutdown()` antes de encerrar processo
* Use `logger.flush()` antes de sair para garantir que logs sejam escritos
* Configure `WORKER_DIRS` como lista para suportar múltiplos diretórios

[source,bash]
----
# .env
WORKER_DIRS=./apps,./examples,${HOME}/external-apps
----

== DON'T

* Não chame `initConfig()` múltiplas vezes (singleton)
* Não modifique `runtimeConfig` diretamente após inicialização
* Não use `console.log` - sempre use `logger`
* Não inicie `Bun.serve` diretamente em plugins (use hooks)

== Troubleshooting

== Conflito de Rotas

[source]
----
Error: Route collision: Plugin "plugin-b" cannot mount routes at "/api" -
       already used by "plugin-a"
----

Solução: Configure `base` diferente em um dos plugins:

[source,jsonc]
----
// plugins/plugin-a/manifest.jsonc
{
  "name": "@buntime/plugin-a",
  "base": "/api/a",
  "enabled": true
}

// plugins/plugin-b/manifest.jsonc
{
  "name": "@buntime/plugin-b",
  "base": "/api/b",
  "enabled": true
}
----

== workerDirs Not Found

[source]
----
Error: workerDirs is required: set WORKER_DIRS env var
----

Solução: Configure a variável de ambiente `WORKER_DIRS`:

[source,bash]
----
WORKER_DIRS=./apps,./examples
----

== Worker Pool Exhausted

[source]
----
Warning: Worker pool exhausted (100/100 workers active)
----

Solução: Aumente `POOL_SIZE`:

[source,bash]
----
POOL_SIZE=500
----
