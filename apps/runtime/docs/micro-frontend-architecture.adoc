= Arquitetura Micro-Frontend de Plugins
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

== Visao Geral

Este documento descreve a arquitetura micro-frontend para plugins do Buntime, utilizando o pacote `@zomme/frame` para comunicacao shell-frame via iframes.

=== Objetivos

- **Modularidade**: Cada plugin pode fornecer sua propria UI como um worker separado
- **Independencia**: UIs de plugins sao desenvolvidas, construidas e implantadas de forma independente
- **Agnostico de Framework**: Plugins podem usar React, Solid, Qwik, Vue, etc.
- **Isolamento de Seguranca**: Iframes com sandbox garantem isolamento completo
- **Comunicacao Bidirecional**: MessageChannel para comunicacao eficiente shell<->frame

=== Diagrama da Arquitetura

[mermaid]
----
flowchart TB
    subgraph Runtime["Buntime Runtime (Port 8000)"]
        subgraph Shell["Shell (C-Panel)"]
            S1["Layout"]
            S2["Nav"]
            S3["z-frame elements"]
        end

        Shell --> Deployments
        Shell --> MetricsFrag
        Shell --> LogsFrag

        subgraph Deployments["Deployments (Worker)"]
            DF1["File Mgmt"]
            DF2["Upload"]
            DF3["Deploy"]
        end

        subgraph MetricsFrag["Metrics (Worker)"]
            MF1["Charts"]
            MF2["Stats"]
            MF3["SSE"]
        end

        subgraph LogsFrag["Logs (Worker)"]
            LF1["Log Stream"]
            LF2["Filters"]
        end

        Shell <--> MessageChannel
        Deployments <--> MessageChannel
        MetricsFrag <--> MessageChannel
        LogsFrag <--> MessageChannel

        subgraph MessageChannel["MessageChannel (Comunicacao)"]
            MC1["Props sync"]
            MC2["Function calls (RPC)"]
            MC3["Custom events"]
        end
    end
----

== @zomme/frame

O pacote `@zomme/frame` fornece:

- **`<z-frame>`**: Web component para embeddar iframes com comunicacao bidirecional
- **`frameSDK`**: SDK para o app dentro do iframe se comunicar com o shell
- **`@zomme/frame-react`**: Bindings React com hooks (`useFrameSDK`, `useRouteSync`)

=== z-frame Web Component

Container que carrega um iframe com comunicacao via MessageChannel.

[source,html]
----
<z-frame
  name="deployments"
  base="/deployments"
  src="http://localhost:8000/deployments"
  pathname="/files"
  theme="dark"
></z-frame>
----

==== Atributos

[cols="1,1,2"]
|===
| Atributo | Tipo | Descricao

| `name`
| string
| Nome identificador do frame (obrigatorio)

| `src`
| string
| URL do app iframe (obrigatorio)

| `base`
| string
| Base path para routing (default: `/<name>`)

| `pathname`
| string
| Path inicial para o frame (default: `/`)

| `sandbox`
| string
| Permissoes do iframe sandbox
|===

==== API JavaScript

[source,typescript]
----
const frame = document.querySelector('z-frame');

// Propriedades dinamicas - sincronizadas automaticamente
frame.theme = 'dark';
frame.user = currentUser;
frame.apiUrl = 'https://api.example.com';

// Emitir eventos para o frame
frame.emit('route-change', { path: '/settings' });
frame.emit('data-refresh', { force: true });

// Chamar funcoes registradas pelo frame (RPC)
const stats = await frame.getStats();
await frame.refreshData();

// Escutar eventos do frame
frame.addEventListener('ready', () => console.log('Frame ready'));
frame.addEventListener('navigate', (e) => router.push(e.detail.path));
----

=== frameSDK

SDK para apps dentro do iframe se comunicarem com o shell.

[source,typescript]
----
import { frameSDK } from '@zomme/frame/sdk';

// Inicializar SDK (obrigatorio antes de usar)
await frameSDK.initialize();

// Acessar props do shell
console.log(frameSDK.props.name);      // 'deployments'
console.log(frameSDK.props.base);      // '/deployments'
console.log(frameSDK.props.theme);     // 'dark'

// Chamar funcoes passadas pelo shell
await frameSDK.props.onSuccess({ status: 'ok' });

// Emitir eventos para o shell
frameSDK.emit('navigate', { path: '/settings' });
frameSDK.emit('task-created', { id: 123 });

// Escutar eventos do shell
frameSDK.on('route-change', ({ path }) => {
  router.navigate(path);
});

// Registrar funcoes para o shell chamar
frameSDK.register('refreshData', async () => {
  await loadData();
});

frameSDK.register({
  getStats: () => ({ count: 42 }),
  export: async (format) => generateExport(format)
});

// Watch para mudancas de props
frameSDK.watch(['theme'], (changes) => {
  if ('theme' in changes) {
    const [newTheme, oldTheme] = changes.theme;
    applyTheme(newTheme);
  }
});
----

=== @zomme/frame-react

Bindings React para facilitar uso do frameSDK.

[source,tsx]
----
import { useFrameSDK, useRouteSync } from '@zomme/frame-react';
import { frameSDK } from '@zomme/frame/sdk';

function App() {
  // Hook que retorna props e estado de inicializacao
  const { props, isReady } = useFrameSDK();

  // Sincronizar rota com o shell
  useRouteSync({
    onRouteChange: (path) => router.navigate(path),
    getCurrentPath: () => router.currentPath
  });

  if (!isReady) {
    return <Loading />;
  }

  return (
    <div>
      <h1>Theme: {props.theme}</h1>
      <button onClick={() => frameSDK.emit('navigate', { path: '/' })}>
        Go Home
      </button>
    </div>
  );
}
----

== Registro de UI de Plugin

=== Extensao da Interface de Plugin

*Manifesto (manifest.jsonc)*:

[source,jsonc]
----
{
  "name": "@buntime/plugin-deployments",
  "base": "/deployments",
  "entrypoint": "dist/client/index.html",
  "menus": [
    {
      "title": "Deployments",
      "icon": "lucide:cloud-upload",
      "path": "/deployments",
      "priority": 10
    }
  ]
}
----

NOTE: O campo `fragment` foi removido. Plugins com `entrypoint` automaticamente tem UI disponivel.

=== Estrutura do Plugin com UI

[source]
----
plugins/plugin-deployments/
├── manifest.jsonc
├── plugin.ts                 # Plugin entry (server)
├── server/
│   ├── api.ts               # API routes
│   └── services.ts          # Business logic
├── client/
│   ├── index.tsx            # Client entry
│   ├── index.html           # HTML shell
│   └── components/
│       └── deployments-page.tsx
└── dist/
    └── client/
        └── index.html       # Built entrypoint
----

=== Exemplo de Plugin Client

*client/index.tsx:*

[source,tsx]
----
import { createRoot } from "react-dom/client";
import { frameSDK } from "@zomme/frame/sdk";
import { DeploymentsPage } from "./components/deployments-page";

// Inicializar SDK
await frameSDK.initialize();

// Registrar funcoes para o shell
frameSDK.register({
  refresh: () => window.location.reload(),
});

// Renderizar app
const root = createRoot(document.getElementById("root")!);
root.render(<DeploymentsPage />);
----

*client/components/deployments-page.tsx:*

[source,tsx]
----
import { useFrameSDK } from "@zomme/frame-react";

export function DeploymentsPage() {
  const { props, isReady } = useFrameSDK();

  if (!isReady) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>Deployments</h1>
      <p>Base path: {props.base}</p>
    </div>
  );
}
----

== Integracao com o Shell (C-Panel)

O shell principal (cpanel) usa `<z-frame>` para carregar plugins:

[source,tsx]
----
// cpanel/client/components/plugin-frame.tsx
import { useEffect, useRef } from "react";
import "@zomme/frame"; // Registra <z-frame>

interface PluginFrameProps {
  base: string;
  name: string;
  pathname?: string;
}

export function PluginFrame({ name, base, pathname = "/" }: PluginFrameProps) {
  const frameRef = useRef<HTMLElement>(null);

  useEffect(() => {
    const frame = frameRef.current;
    if (!frame) return;

    // Escutar eventos de navegacao
    const handleNavigate = (e: CustomEvent) => {
      window.history.pushState({}, "", e.detail.path);
    };

    frame.addEventListener("navigate", handleNavigate);
    return () => frame.removeEventListener("navigate", handleNavigate);
  }, []);

  return (
    <z-frame
      ref={frameRef}
      name={name}
      base={base}
      src={`${window.location.origin}${base}`}
      pathname={pathname}
    />
  );
}
----

[source,tsx]
----
// cpanel/client/routes/plugin.tsx
import { useParams } from "react-router";
import { PluginFrame } from "../components/plugin-frame";

export function PluginPage() {
  const { pluginName, "*": subpath } = useParams();

  return (
    <PluginFrame
      name={pluginName}
      base={`/${pluginName}`}
      pathname={subpath ? `/${subpath}` : "/"}
    />
  );
}
----

== Comunicacao Shell <-> Frame

=== Fluxo de Inicializacao

[mermaid]
----
sequenceDiagram
    participant S as Shell (z-frame)
    participant I as Iframe
    participant F as frameSDK

    S->>I: Cria iframe com src
    I->>I: Carrega pagina
    I->>F: frameSDK.initialize()
    S->>I: postMessage(INIT, props, [port2])
    F->>F: Recebe port2, deserializa props
    F->>S: port.postMessage(READY)
    S->>S: Emite evento 'ready'
----

=== Tipos de Mensagens

[cols="1,2"]
|===
| Mensagem | Descricao

| `INIT`
| Shell -> Frame: Props iniciais + MessagePort

| `READY`
| Frame -> Shell: Frame inicializado

| `PROPS_UPDATE`
| Shell -> Frame: Atualizacao de props

| `EVENT`
| Shell -> Frame: Evento customizado

| `CUSTOM_EVENT`
| Frame -> Shell: Evento customizado

| `FUNCTION_CALL`
| Chamada de funcao RPC

| `FUNCTION_RESPONSE`
| Resposta de funcao RPC
|===

=== Passando Funcoes

Funcoes podem ser passadas entre shell e frame via serializacao automatica:

[source,typescript]
----
// Shell: passar funcao como prop
const frame = document.querySelector('z-frame');
frame.onSave = async (data) => {
  await api.save(data);
  return { success: true };
};

// Frame: chamar funcao do shell
const result = await frameSDK.props.onSave({ id: 123 });
console.log(result.success); // true
----

[source,typescript]
----
// Frame: registrar funcao
frameSDK.register('getStats', () => ({ users: 42, requests: 1000 }));

// Shell: chamar funcao do frame
const stats = await frame.getStats();
console.log(stats.users); // 42
----

== Beneficios

- **Isolamento de Seguranca**: Iframes com sandbox impedem acesso ao DOM do shell
- **Implantacao Independente**: Atualizar UIs de plugins sem alterar o runtime
- **Liberdade Tecnologica**: Cada plugin pode usar frameworks diferentes
- **Comunicacao Tipada**: TypeScript para props e eventos
- **Lazy Loading**: Frames carregam sob demanda
- **Tratamento de Erros**: Erros no frame nao afetam o shell

== Migracao de @buntime/piercing

Se voce tinha plugins usando o antigo sistema de fragments/piercing:

1. Remova a secao `fragment` do `manifest.jsonc`
2. Substitua imports de `@buntime/piercing` por `@zomme/frame` ou `@zomme/frame-react`
3. Inicialize o SDK com `await frameSDK.initialize()` no entry do client
4. Use `useFrameSDK()` em vez de acessar diretamente o Shadow DOM
5. Simplifique `getApiBase()` para usar apenas o `<base>` tag

=== Antes (piercing)

[source,tsx]
----
// Antigo: acessar Shadow DOM
function getApiBase(): string {
  const rootNode = element.getRootNode();
  if (rootNode instanceof ShadowRoot) {
    const outlet = rootNode.host;
    const src = outlet?.getAttribute("src");
    // ... logica complexa
  }
  return "/plugin";
}
----

=== Depois (frame)

[source,tsx]
----
// Novo: simples base tag
function getApiBase(): string {
  const base = document.querySelector("base");
  return base?.getAttribute("href")?.replace(/\/$/, "") || "/plugin";
}

// Ou usando frameSDK
function getApiBase(): string {
  return frameSDK.props.base;
}
----
