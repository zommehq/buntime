== Cache
:order: 3

=== Gerenciamento de Cache

NOTE: A implementação atual do Leaf usa cache de sistema de arquivos através dos mecanismos de leitura de arquivos do Bun e cache do sistema operacional. Não há camada explícita de cache de API na versão atual.

=== Arquitetura de Cache

[mermaid]
----
flowchart TD
    Request[API Request]
    Parse[Parse AsciiDoc]
    OS[OS File System Cache]
    Disk[Disk Storage]

    Request --> Parse
    Parse --> OS
    OS -->|Cache Hit| Parse
    OS -->|Cache Miss| Disk
    Disk --> OS

    style OS fill:#F5A623
    style Disk fill:#95A5A6
----

=== Comportamento Atual

**Cache de Sistema de Arquivos:**

* Sistema operacional faz cache de arquivos acessados frequentemente
* Runtime Bun otimiza leituras de arquivo
* Sem necessidade de TTL ou invalidação explícita
* Cache atualiza automaticamente quando arquivos são modificados

**Características de Performance:**

1. **Primeira Requisição**: Lê do disco (~1-5ms para arquivos pequenos)
2. **Requisições Subsequentes**: Cache do SO (~0.1-1ms)
3. **Arquivo Modificado**: SO detecta mudança, cache invalidado automaticamente

=== Parse de AsciiDoc

Cada requisição processa o conteúdo AsciiDoc novamente (sem cache de HTML):

[mermaid]
----
sequenceDiagram
    participant C as Client
    participant A as API
    participant F as File Cache
    participant P as Parser

    C->>A: Request document
    A->>F: Read .adoc file
    Note over F: OS caches file content
    F-->>A: Raw AsciiDoc
    A->>P: Parse to HTML
    Note over P: No HTML caching
    P-->>A: Fresh HTML
    A-->>C: Response

    C->>A: Same request again
    A->>F: Read .adoc file
    Note over F: Returns from OS cache
    F-->>A: Raw AsciiDoc (fast)
    A->>P: Parse to HTML
    P-->>A: Fresh HTML
    A-->>C: Response
----

=== Monitoramento de Arquivos

A implementação atual não inclui monitoramento ativo de arquivos, mas se beneficia de:

* **Detecção de mudança em nível de SO**: Arquivos modificados são automaticamente relidos
* **Sem conteúdo obsoleto**: Cada requisição obtém o estado atual do arquivo
* **Amigável ao desenvolvimento**: Mudanças aparecem imediatamente na próxima requisição

=== Melhorias Futuras de Cache

Potenciais melhorias para cenários de alto tráfego:

[mermaid]
----
flowchart LR
    Current[Current: OS Cache Only]
    Future[Future Options]

    Future --> HTMLCache[HTML Cache with TTL]
    Future --> Redis[Redis for Multi-Instance]
    Future --> CDN[CDN for Static Content]
    Future --> FileWatch[Active File Watching]

    HTMLCache --> Benefit1[Faster responses]
    Redis --> Benefit2[Shared cache]
    CDN --> Benefit3[Global distribution]
    FileWatch --> Benefit4[Smart invalidation]

    style Current fill:#4A90E2
    style Future fill:#F5A623
----

**Considerações:**

* **Cache de HTML**: Fazer cache do HTML processado com invalidação em mudança de arquivo
* **Integração Redis**: Compartilhar cache entre múltiplas instâncias de servidor
* **Observadores de Arquivo**: Usar `fs.watch()` para detectar mudanças e invalidar cache
* **CDN**: Servir documentos acessados frequentemente de localizações edge de CDN

=== Gerenciamento de Memória

Abordagem atual tem pegada mínima de memória:

[cols="2,3"]
|===
| Aspecto | Implementação Atual

| Conteúdo de Arquivo
| SO gerencia cache, não no heap do Node

| HTML Processado
| Gerado por requisição, sem armazenamento

| Estrutura de Árvore
| Construída sob demanda, sem cache persistente

| Uso de Memória
| ~10-50MB para carga de trabalho típica
|===

=== Dicas de Performance

**Para performance ótima:**

1. **Mantenha arquivos pequenos**: Divida documentos grandes em múltiplos arquivos
2. **Otimize imagens**: Use imagens comprimidas, referencie externamente se grandes
3. **Minimize atributos**: Processe apenas atributos de front-matter necessários
4. **Use CDN**: Sirva assets estáticos de CDN em produção
