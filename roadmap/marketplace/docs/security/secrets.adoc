= Gerenciamento de Secrets

Este documento descreve a arquitetura do plugin-secrets para armazenamento e gerenciamento seguro de credenciais no marketplace.

== Visão Geral da Arquitetura

[mermaid]
----
flowchart TB
    subgraph Clients["Clientes"]
        Admin[Admin Dashboard]
        Worker[Worker Apps]
        Provisioner[Marketplace Provisioner]
    end

    subgraph SecretsPlugin["plugin-secrets"]
        API[Secrets API]
        Crypto[Encryption Engine]
        Audit[Audit Logger]
    end

    subgraph Storage["Camada de Armazenamento"]
        KV[(KeyVal Store)]
        AuditDB[(Audit Log DB)]
    end

    subgraph Keys["Hierarquia de Chaves"]
        MK[Master Key]
        DEK[Data Encryption Keys]
    end

    Admin --> API
    Worker --> API
    Provisioner --> API

    API --> Crypto
    API --> Audit

    Crypto --> KV
    Audit --> AuditDB

    MK --> DEK
    DEK --> Crypto
----

== Componentes

[cols="1,3"]
|===
| Componente | Descrição

| KV Store (LibSQL)
| Armazenamento persistente para valores de secret criptografados

| Encryption Engine
| Criptografia/descriptografia AES-256-GCM com derivação de chave

| Audit Log
| Log imutável de todos os acessos e modificações de secrets

| Key Hierarchy
| Master Key (MK) deriva Data Encryption Keys (DEK) por tenant
|===

== Caminhos de Secrets

Secrets são organizados em uma estrutura de caminhos hierárquica:

[source]
----
/{scope}/{tenant}/{app}/{key}
----

=== Exemplos de Caminhos

[source]
----
/platform/system/config/jwt-signing-key
/tenant/acme-corp/*/database-url
/app/acme-corp/crm/stripe-api-key
/app/acme-corp/crm/oauth/google-client-secret
----

== Scopes

[cols="1,1,3"]
|===
| Scope | Prefixo do Caminho | Descrição

| Platform
| `/platform/`
| Secrets de sistema (signing keys, credenciais master)

| Tenant
| `/tenant/{tenant}/`
| Secrets de tenant compartilhados entre todos os apps

| App
| `/app/{tenant}/{app}/`
| Secrets específicos de app para um único tenant
|===

=== Hierarquia de Scopes

[mermaid]
----
flowchart TD
    Platform["/platform/*<br/>Apenas System Admins"]
    Tenant["/tenant/{tenant}/*<br/>Tenant Admins"]
    App["/app/{tenant}/{app}/*<br/>App Developers"]

    Platform --> Tenant
    Tenant --> App
----

=== Matriz de Controle de Acesso

[cols="1,1,1,1"]
|===
| Papel | Platform | Tenant | App

| System Admin
| Read/Write
| Read/Write
| Read/Write

| Tenant Admin
| -
| Read/Write
| Read/Write

| App Developer
| -
| Read
| Read/Write

| Worker Runtime
| -
| Read
| Read
|===

== Hierarquia de Chaves

A hierarquia de chaves de criptografia garante isolamento de tenant e permite rotação de chaves sem re-criptografar todos os secrets.

[mermaid]
----
flowchart TB
    MK["Master Key (MK)<br/>Protegida por HSM/KMS"]

    subgraph TenantKeys["DEKs Por Tenant"]
        DEK1["DEK: tenant-abc<br/>Derivada da MK"]
        DEK2["DEK: tenant-xyz<br/>Derivada da MK"]
    end

    subgraph Secrets["Secrets Criptografados"]
        S1["api-key<br/>AES-256-GCM"]
        S2["db-password<br/>AES-256-GCM"]
        S3["oauth-secret<br/>AES-256-GCM"]
    end

    MK --> DEK1
    MK --> DEK2
    DEK1 --> S1
    DEK1 --> S2
    DEK2 --> S3
----

=== Derivação de Chave

[source,typescript]
----
import { hkdf } from "@noble/hashes/hkdf";
import { sha256 } from "@noble/hashes/sha256";

const deriveTenantKey = (masterKey: Uint8Array, tenantId: string): Uint8Array => {
  return hkdf(
    sha256,
    masterKey,
    tenantId,           // salt = identificador do tenant
    "buntime-secrets",  // info = contexto da aplicação
    32                  // key length = 256 bits
  );
};
----

=== Processo de Criptografia

[source,typescript]
----
import { gcm } from "@noble/ciphers/aes";
import { randomBytes } from "@noble/ciphers/webcrypto";

const encrypt = (dek: Uint8Array, plaintext: string): EncryptedValue => {
  const nonce = randomBytes(12);  // nonce de 96 bits para GCM
  const cipher = gcm(dek, nonce);
  const ciphertext = cipher.encrypt(new TextEncoder().encode(plaintext));

  return {
    algorithm: "aes-256-gcm",
    nonce: base64Encode(nonce),
    ciphertext: base64Encode(ciphertext),
    version: 1
  };
};
----

== Endpoints da API

=== Obter Secret

[source]
----
GET /secrets/api/v1/{path}
Authorization: Bearer {token}
----

Resposta:

[source,json]
----
{
  "path": "/app/acme-corp/crm/stripe-api-key",
  "value": "sk_live_...",
  "version": 3,
  "createdAt": "2024-01-15T10:30:00Z",
  "updatedAt": "2024-03-20T14:45:00Z"
}
----

=== Definir Secret

[source]
----
PUT /secrets/api/v1/{path}
Authorization: Bearer {token}
Content-Type: application/json

{
  "value": "sk_live_new_key_value"
}
----

Resposta:

[source,json]
----
{
  "path": "/app/acme-corp/crm/stripe-api-key",
  "version": 4,
  "updatedAt": "2024-03-21T09:00:00Z"
}
----

=== Deletar Secret

[source]
----
DELETE /secrets/api/v1/{path}
Authorization: Bearer {token}
----

Resposta:

[source,json]
----
{
  "path": "/app/acme-corp/crm/stripe-api-key",
  "deleted": true,
  "deletedAt": "2024-03-21T10:00:00Z"
}
----

=== Listar Secrets

[source]
----
GET /secrets/api/v1/{prefix}?list=true
Authorization: Bearer {token}
----

Resposta:

[source,json]
----
{
  "secrets": [
    {
      "path": "/app/acme-corp/crm/stripe-api-key",
      "version": 4,
      "updatedAt": "2024-03-21T09:00:00Z"
    },
    {
      "path": "/app/acme-corp/crm/oauth/google-client-secret",
      "version": 1,
      "updatedAt": "2024-02-10T15:30:00Z"
    }
  ]
}
----

NOTE: Operações de listagem retornam apenas metadados, não os valores dos secrets.

== Versionamento e Rollback

Todos os secrets são versionados para suportar rollback e trilhas de auditoria.

=== Armazenamento de Versões

[mermaid]
----
flowchart LR
    subgraph Versions["Versões do Secret"]
        V1["v1: sk_test_..."]
        V2["v2: sk_live_old..."]
        V3["v3: sk_live_current..."]
    end

    Current["Ponteiro Atual"] --> V3
    V3 --> V2
    V2 --> V1
----

=== Obter Versão Específica

[source]
----
GET /secrets/api/v1/{path}?version=2
----

=== Rollback para Versão

[source]
----
POST /secrets/api/v1/{path}/rollback
Content-Type: application/json

{
  "targetVersion": 2
}
----

=== Política de Retenção de Versões

[cols="1,3"]
|===
| Configuração | Descrição

| `maxVersions`
| Número máximo de versões a reter (padrão: 10)

| `minRetentionDays`
| Dias mínimos para manter versões antigas (padrão: 30)

| `deleteOnExpiry`
| Se deve excluir permanentemente versões expiradas (padrão: false)
|===

== Audit Log

Todas as operações de secret são registradas em uma trilha de auditoria imutável.

=== Campos do Audit Log

[cols="1,1,3"]
|===
| Campo | Tipo | Descrição

| id
| TEXT
| Identificador único do evento (UUIDv7)

| timestamp
| TIMESTAMP
| Timestamp do evento (UTC)

| action
| TEXT
| Tipo de operação (read, write, delete, list, rollback)

| path
| TEXT
| Caminho do secret acessado

| actor_id
| TEXT
| ID do usuário ou service account

| actor_type
| TEXT
| Tipo: user, service, provisioner

| tenant_id
| TEXT
| Contexto do tenant

| ip_address
| TEXT
| Endereço IP do cliente

| user_agent
| TEXT
| User agent do cliente

| result
| TEXT
| Resultado da operação (success, denied, error)

| metadata
| JSON
| Contexto adicional (versão, detalhes de erro)
|===

=== Schema do Audit Log

[source,sql]
----
CREATE TABLE secret_audit_log (
    id TEXT PRIMARY KEY,
    timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    action TEXT NOT NULL CHECK (action IN ('read', 'write', 'delete', 'list', 'rollback')),
    path TEXT NOT NULL,
    actor_id TEXT NOT NULL,
    actor_type TEXT NOT NULL CHECK (actor_type IN ('user', 'service', 'provisioner')),
    tenant_id TEXT,
    ip_address TEXT,
    user_agent TEXT,
    result TEXT NOT NULL CHECK (result IN ('success', 'denied', 'error')),
    metadata JSON
);

CREATE INDEX idx_audit_timestamp ON secret_audit_log(timestamp);
CREATE INDEX idx_audit_path ON secret_audit_log(path);
CREATE INDEX idx_audit_actor ON secret_audit_log(actor_id);
CREATE INDEX idx_audit_tenant ON secret_audit_log(tenant_id);
----

=== Política de Retenção

[cols="1,3"]
|===
| Configuração | Descrição

| `retentionDays`
| Dias para reter logs de auditoria (padrão: 365)

| `archiveEnabled`
| Se deve arquivar antes da exclusão (padrão: true)

| `archiveLocation`
| Caminho S3/GCS para logs arquivados
|===

== Integração com o Marketplace

=== Fluxo de Provisionamento

[mermaid]
----
sequenceDiagram
    participant MP as Marketplace
    participant Prov as Provisioner
    participant Secrets as plugin-secrets
    participant KV as KeyVal

    MP->>Prov: Tenant ativa app
    Prov->>Secrets: Criar namespace de secret do app
    Secrets->>KV: Inicializar /app/{tenant}/{app}/

    Prov->>Secrets: Armazenar credenciais provisionadas
    Secrets->>KV: Criptografar e armazenar

    Prov-->>MP: Ativação completa
----

=== Secrets de Ativação

Quando um tenant ativa um app, o provisioner cria automaticamente os secrets necessários:

[source,typescript]
----
const provisionAppSecrets = async (tenantId: string, appId: string, config: AppConfig) => {
  const secrets = await secretsClient.createNamespace(`/app/${tenantId}/${appId}/`);

  // Armazenar credenciais de banco se o app requer banco de dados
  if (config.requires.database) {
    await secrets.set("database-url", generateDatabaseUrl(tenantId, appId));
  }

  // Armazenar API keys se o app tem integrações
  for (const integration of config.integrations) {
    await secrets.set(`integrations/${integration.name}/api-key`, integration.apiKey);
  }

  return secrets;
};
----

=== Acesso em Runtime

Worker apps acessam secrets através do cliente injetado pelo runtime:

[source,typescript]
----
// Runtime fornece cliente pré-configurado
const secrets = __BUNTIME__.secrets;

// App só pode acessar seu próprio escopo
const apiKey = await secrets.get("stripe-api-key");
// Resolve para: /app/{current_tenant}/{current_app}/stripe-api-key

// Acesso cross-tenant é rejeitado
await secrets.get("/app/other-tenant/other-app/key");
// Erro: Acesso negado - acesso cross-tenant não permitido
----

=== Limpeza na Desativação

Quando um tenant desativa um app, os secrets são marcados para exclusão:

[mermaid]
----
sequenceDiagram
    participant MP as Marketplace
    participant Prov as Provisioner
    participant Secrets as plugin-secrets

    MP->>Prov: Tenant desativa app
    Prov->>Secrets: Marcar namespace para exclusão
    Note over Secrets: Soft delete com período de graça

    alt Período de graça expira
        Secrets->>Secrets: Hard delete de todas as versões
        Secrets->>Secrets: Registrar exclusão na auditoria
    else Tenant reativa
        Secrets->>Secrets: Restaurar namespace
    end
----

== Configuração

=== Manifest do Plugin

[source,jsonc]
----
// plugins/plugin-secrets/manifest.jsonc
{
  "name": "@buntime/plugin-secrets",
  "enabled": true,
  "base": "/secrets",
  "dependencies": ["@buntime/plugin-database", "@buntime/plugin-keyval"],
  "config": {
    "encryption": {
      "algorithm": "aes-256-gcm",
      "keyDerivation": "hkdf-sha256"
    },
    "versioning": {
      "maxVersions": 10,
      "minRetentionDays": 30
    },
    "audit": {
      "enabled": true,
      "retentionDays": 365,
      "archiveEnabled": true
    }
  }
}
----

=== Variáveis de Ambiente

[cols="1,1,3"]
|===
| Variável | Padrão | Descrição

| `SECRETS_MASTER_KEY`
| Obrigatório
| Master key de 256 bits codificada em Base64

| `SECRETS_KMS_PROVIDER`
| `local`
| Provedor KMS: local, aws-kms, gcp-kms

| `SECRETS_AUDIT_RETENTION`
| `365`
| Dias para reter logs de auditoria

| `SECRETS_VERSION_LIMIT`
| `10`
| Máximo de versões por secret
|===
