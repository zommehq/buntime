== Fragmentos

Fragmentos são micro-frontends independentes que podem ser integrados dinamicamente em uma aplicação host via Piercing.

=== Identificação de Fragmentos

Os fragmentos são identificados pela URL especificada no atributo `src` dos elementos `<fragment-outlet>` e `<fragment-host>`.

[source,html]
----
<!-- Cliente declara onde o fragmento deve aparecer -->
<fragment-outlet src="/metrics" />

<!-- Pre-piercing injeta o host com a mesma URL -->
<fragment-host src="/metrics">
  <!-- Conteúdo SSR do fragmento -->
</fragment-host>
----

IMPORTANT: Não é necessário registrar fragmentos via `registerFragment()`. A interface `FragmentConfig` foi removida. Os fragmentos são carregados dinamicamente a partir da URL especificada em `src`.

=== Como Funciona

==== No Cliente

O elemento `<fragment-outlet>` busca automaticamente o conteúdo do fragmento da URL especificada:

[source,html]
----
<!-- A aplicação cliente define onde o fragmento aparece -->
<div class="container">
  <fragment-outlet src="/metrics" />
</div>
----

O custom element `<fragment-outlet>`:

1. Faz um `fetch()` para a URL em `src`
2. Recebe o HTML do fragmento
3. Injeta o conteúdo no DOM
4. Inicializa o JavaScript do fragmento via `<fragment-host>`

==== Pre-Piercing

O pre-piercing é realizado pelo plugin `plugin-piercing` (um plugin do runtime Buntime), que:

1. Analisa o HTML da shell em busca de elementos `<fragment-outlet src="...">`
2. Para cada outlet encontrado, faz um fetch SSR da URL especificada
3. Substitui `<fragment-outlet>` por `<fragment-host>` com o conteúdo SSR injetado
4. Retorna o HTML completo com os fragmentos pré-renderizados

[source,typescript]
----
// O plugin-piercing faz automaticamente:
// <fragment-outlet src="/metrics" />
//   ↓ (pre-piercing SSR)
// <fragment-host src="/metrics">
//   <div class="metrics-dashboard">...</div>
// </fragment-host>
----

NOTE: O pre-piercing é opcional e configurado pelo runtime. Se desabilitado, os fragmentos serão carregados apenas no cliente via fetch dinâmico.

=== Uso no HTML

==== Fragmento Simples

[source,html]
----
<fragment-outlet src="/header" />
----

==== Múltiplos Fragmentos

[source,html]
----
<body>
  <fragment-outlet src="/header" />

  <main>
    <fragment-outlet src="/sidebar" />
    <div class="content">
      <!-- Conteúdo principal -->
    </div>
  </main>

  <fragment-outlet src="/footer" />
</body>
----

==== Fragmentos com Parâmetros

Os fragmentos recebem automaticamente os query parameters da URL:

[source,html]
----
<!-- Fragmento recebe ?theme=dark -->
<fragment-outlet src="/navigation?theme=dark" />
----

==== Fragmentos Condicionais

Use lógica no cliente para renderizar fragmentos condicionalmente:

[source,typescript]
----
// React
function Dashboard() {
  const user = useUser();

  return (
    <div>
      {user.role === "admin" && (
        <fragment-outlet src="/admin-panel" />
      )}
    </div>
  );
}
----

=== Implementação de Fragmentos

Um fragmento é simplesmente uma aplicação que responde com HTML em uma rota específica.

==== Fragmento Básico

[source,typescript]
----
// Fragment service running on /metrics
app.get("/", async (req) => {
  return new Response(
    `
    <div class="metrics-dashboard">
      <h2>Metrics</h2>
      <div id="metrics-root"></div>
      <script src="/metrics-client.js"></script>
    </div>
    `,
    { headers: { "Content-Type": "text/html" } }
  );
});
----

==== Fragmento com Estado Compartilhado

Os fragmentos podem receber estado da shell via headers do message bus:

[source,typescript]
----
app.get("/", async (req) => {
  // Lê estado compartilhado dos headers
  const userId = req.headers.get("x-mb-user-id");
  const theme = req.headers.get("x-mb-theme");

  const metrics = await fetchMetricsForUser(userId);

  return new Response(
    `
    <div class="metrics" data-theme="${theme}">
      <h2>Metrics for User ${userId}</h2>
      <pre>${JSON.stringify(metrics, null, 2)}</pre>
      <script>
        // Cliente pode ler o estado e sincronizar
        const theme = document.querySelector(".metrics").dataset.theme;
      </script>
    </div>
    `,
    { headers: { "Content-Type": "text/html" } }
  );
});
----

NOTE: Os headers do message bus (`x-mb-*`) são automaticamente propagados para as requisições de fragmentos durante o pre-piercing.

=== Estilos de Pre-Piercing

Para evitar flash de conteúdo não estilizado (FOUC), injete estilos mínimos no fragmento:

[source,typescript]
----
app.get("/", async (req) => {
  return new Response(
    `
    <style>
      .navigation {
        min-height: 64px;
        background: #fff;
        transition: opacity 0.3s ease;
      }
    </style>
    <nav class="navigation">
      <!-- Conteúdo do fragmento -->
    </nav>
    <script src="/nav-client.js"></script>
    `,
    { headers: { "Content-Type": "text/html" } }
  );
});
----

=== Exemplo Completo

==== Shell HTML

[source,html]
----
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>My App</title>
  </head>
  <body>
    <!-- Fragmento de navegação -->
    <fragment-outlet src="/navigation" />

    <!-- Conteúdo principal -->
    <main id="app"></main>

    <!-- Fragmento de métricas (condicional via JS) -->
    <div id="metrics-container"></div>

    <script type="module">
      import { FragmentClient } from "@buntime/piercing/client";

      const client = new FragmentClient();

      // Carrega fragmento de métricas dinamicamente
      const showMetrics = await shouldShowMetrics();
      if (showMetrics) {
        const outlet = document.createElement("fragment-outlet");
        outlet.setAttribute("src", "/metrics");
        document.getElementById("metrics-container").appendChild(outlet);
      }
    </script>
  </body>
</html>
----

==== Fragmento de Navegação

[source,typescript]
----
// Service em /navigation
import { Hono } from "hono";

const app = new Hono();

app.get("/", async (req) => {
  const theme = req.headers.get("x-mb-theme") || "light";

  return new Response(
    `
    <style>
      .nav {
        min-height: 64px;
        background: ${theme === "dark" ? "#1a1a1a" : "#fff"};
        padding: 1rem;
        transition: background 0.3s ease;
      }
    </style>
    <nav class="nav">
      <a href="/">Home</a>
      <a href="/dashboard">Dashboard</a>
      <a href="/settings">Settings</a>
    </nav>
    <script type="module">
      import { FragmentHost } from "@buntime/piercing/client";

      // Cliente do fragmento pode interagir com message bus
      customElements.whenDefined("fragment-host").then(() => {
        const host = document.querySelector("fragment-host[src='/navigation']");
        host.subscribe("theme-changed", (theme) => {
          document.querySelector(".nav").style.background =
            theme === "dark" ? "#1a1a1a" : "#fff";
        });
      });
    </script>
    `,
    { headers: { "Content-Type": "text/html" } }
  );
});

export default app;
----

==== Fragmento de Métricas

[source,typescript]
----
// Service em /metrics
import { Hono } from "hono";

const app = new Hono();

app.get("/", async (req) => {
  const userId = req.headers.get("x-mb-user-id");

  if (!userId) {
    return new Response("<div>Not authenticated</div>", {
      headers: { "Content-Type": "text/html" },
    });
  }

  const metrics = await fetchMetrics(userId);

  return new Response(
    `
    <div class="metrics-dashboard">
      <h2>Metrics Dashboard</h2>
      <div class="metrics-grid">
        <div class="metric">
          <span>Active Workers</span>
          <strong>${metrics.activeWorkers}</strong>
        </div>
        <div class="metric">
          <span>Requests/sec</span>
          <strong>${metrics.requestsPerSecond}</strong>
        </div>
      </div>
      <script type="module">
        import { FragmentHost } from "@buntime/piercing/client";

        // Atualiza métricas via SSE
        const evtSource = new EventSource("/metrics/stream");
        evtSource.onmessage = (event) => {
          const metrics = JSON.parse(event.data);
          const grid = document.querySelector(".metrics-grid");

          // Cria elementos DOM de forma segura
          grid.textContent = "";

          const activeMetric = document.createElement("div");
          activeMetric.className = "metric";
          activeMetric.innerHTML = "<span>Active Workers</span>";
          const activeValue = document.createElement("strong");
          activeValue.textContent = metrics.activeWorkers;
          activeMetric.appendChild(activeValue);

          const reqMetric = document.createElement("div");
          reqMetric.className = "metric";
          reqMetric.innerHTML = "<span>Requests/sec</span>";
          const reqValue = document.createElement("strong");
          reqValue.textContent = metrics.requestsPerSecond;
          reqMetric.appendChild(reqValue);

          grid.appendChild(activeMetric);
          grid.appendChild(reqMetric);
        };
      </script>
    </div>
    `,
    { headers: { "Content-Type": "text/html" } }
  );
});

export default app;
----
