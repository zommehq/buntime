== O que é Piercing?

Piercing é uma biblioteca para construção de micro-frontends que utiliza a arquitetura Fragment Piercing, inspirada na abordagem da Cloudflare. Diferente de outras soluções de micro-frontends, Piercing combina Server-Side Rendering (SSR) com composição dinâmica de fragmentos no cliente.

A técnica consiste em renderizar fragmentos de UI independentes no servidor e "perfurá-los" (pierce) na shell principal no momento certo, seja durante a resposta HTML inicial (pre-piercing) ou sob demanda no cliente (lazy loading).

== Conceitos Fundamentais

=== Gateway

O Gateway é o orquestrador central que intercepta requisições HTML e coordena a composição de fragmentos. Ele é responsável por:

* Buscar o HTML da shell (aplicação principal)
* Identificar quais fragmentos devem ser pré-carregados com base nas rotas
* Fazer fetch do conteúdo SSR dos fragmentos em paralelo
* Injetar scripts de inicialização (MessageBus, Web Components)
* Combinar shell e fragmentos em uma única resposta HTML streaming

[source,typescript]
----
const gateway = new PiercingGateway({
  getShellHtml: async (req) => shellWorker.fetch(req),
  generateMessageBusState: async (state, req) => ({
    ...state,
    theme: "dark",
    user: await getUserFromSession(req),
  }),
});

gateway.registerFragment({
  fragmentId: "logs",
  prePierceRoutes: ["/cpanel/logs*"],
  fetchFragment: async (req) => logsWorker.fetch(req),
});
----

O Gateway utiliza padrões glob para determinar quando um fragmento deve ser pré-carregado:

[cols="1,2"]
|===
| Padrão | Comportamento

| `/cpanel/logs`
| Match exato apenas

| `/cpanel/logs/*`
| Qualquer rota sob /cpanel/logs

| `/cpanel/*/edit`
| Qualquer página de edição
|===

=== Fragments

Fragmentos são unidades independentes de UI que podem ser renderizadas no servidor e integradas dinamicamente na shell. Cada fragmento possui:

* **ID único**: Identificador usado para registro e roteamento
* **Framework próprio**: React, Vue, Solid, ou qualquer framework
* **Ciclo de vida isolado**: Scripts, estilos e estado independentes
* **Função de fetch**: Retorna Response com HTML renderizado

[source,typescript]
----
// Fragment no plugin
export const plugin: BuntimePlugin = {
  name: "@buntime/plugin-deployments",

  fragment: {
    fragmentId: "deployments",
    prePierceRoutes: ["/cpanel/deployments*"],

    fetchFragment: async (req) => {
      // SSR do fragmento usando seu próprio framework
      const html = await renderDeploymentsApp(req);
      return new Response(html);
    },
  },
};
----

=== MessageBus

O MessageBus é um canal de comunicação isomórfico (funciona no servidor e cliente) que permite compartilhamento de estado e eventos entre shell e fragmentos. Ele é baseado em eventos nomeados e valores JSON-serializáveis.

==== Características

* **State inicial no servidor**: Gerado durante SSR e injetado no HTML
* **Comunicação bidirecional**: Shell e fragmentos podem dispatch/listen
* **Framework-agnostic**: Funciona com React, Vue, Solid, vanilla JS
* **Tipagem segura**: Valores devem ser JSON-serializáveis

==== Uso no Servidor

[source,typescript]
----
// Gateway gera state inicial
generateMessageBusState: async (state, req) => ({
  ...state,
  theme: "dark",
  user: { id: 1, name: "Alice" },
  permissions: ["read", "write"],
}),
----

O state é serializado e injetado no HTML como:

[source,html]
----
<script>
(function() {
  window.__PIERCING_MESSAGE_BUS_STATE__ = {
    "theme": "dark",
    "user": {"id": 1, "name": "Alice"},
    "permissions": ["read", "write"]
  };
})();
</script>
----

==== Uso no Cliente

Na shell:

[source,typescript]
----
import { getBus } from "@buntime/piercing/client";

const bus = getBus();

// Escutar eventos dos fragmentos
bus.listen("notification", (data) => {
  showToast(data.message, data.type);
});

// Dispatch para fragmentos
bus.dispatch("theme-changed", { theme: "light" });
----

Nos fragmentos:

[source,typescript]
----
import { getBus } from "@buntime/piercing/client";

function DeploymentsFragment() {
  const bus = getBus();

  // Ler state inicial
  const theme = bus.latestValue("theme");

  // Escutar mudanças
  useEffect(() => {
    return bus.listen("theme-changed", (data) => {
      updateTheme(data.theme);
    });
  }, []);

  // Notificar shell
  const handleDeploy = () => {
    bus.dispatch("notification", {
      type: "success",
      message: "Deploy realizado!",
    });
  };
}
----

==== API do MessageBus

[cols="2,3,2"]
|===
| Método | Descrição | Tipo

| `dispatch(name, value)`
| Envia evento com valor JSON
| `void`

| `listen(name, callback)`
| Escuta evento, retorna cleanup
| `() => void`

| `latestValue(name)`
| Retorna último valor
| `T \| undefined`

| `state`
| State completo (read-only)
| `MessageBusState`
|===

=== Sandbox

O Sandbox permite isolar fragmentos externos (de domínios diferentes) com diferentes níveis de isolamento. Existem três estratégias:

==== none (padrão)

Sem isolamento. Fragmento executa no mesmo contexto da shell.

[source,html]
----
<fragment-outlet fragment-id="logs" />
----

**Quando usar**: Fragmentos internos (plugins do Buntime)

==== patch

Intercepta APIs do navegador (History, Location) usando monkey patching. O fragmento roda no mesmo DOM mas navegação é redirecionada.

[source,html]
----
<fragment-outlet
  fragment-id="legacy"
  sandbox="patch"
/>
----

**Quando usar**: Fragmentos legados que usam navegação própria mas não precisam de isolamento total

**Limitações**:
- Compartilha global scope
- Estilos podem vazar

==== iframe

Isolamento completo em iframe. Fragmento carrega de origem externa.

[source,html]
----
<fragment-outlet
  fragment-id="external"
  sandbox="iframe"
  origin="https://external-app.com"
/>
----

**Quando usar**: Fragmentos externos que precisam isolamento total

**Características**:
- Isolamento de DOM, JS e CSS
- Comunicação via MessageBus (postMessage)
- Requer CORS configurado


== Como Funciona o SSR

O fluxo de SSR com Piercing envolve múltiplas etapas coordenadas pelo Gateway:

[source]
----
1. Browser: GET /cpanel/logs
        ↓
2. Gateway intercepta (middleware)
        ↓
3. Verifica prePierceRoutes:
   - "logs" tem match com /cpanel/logs*
        ↓
4. Busca em paralelo:
   - Shell HTML (getShellHtml)
   - Fragment SSR (fetchFragment de "logs")
        ↓
5. Processa shell:
   - Gera MessageBus state inicial
   - Injeta script de inicialização
        ↓
6. Combina shell + fragment:
   - Fragment envolto em <fragment-host>
   - Inserido antes de </body>
        ↓
7. Response streaming para browser:
   <html>
     <head>
       <script>
         window.__PIERCING_MESSAGE_BUS_STATE__ = {...};
       </script>
       <script type="module">
         import { registerPiercingComponents } from '/_piercing/client.js';
         registerPiercingComponents();
       </script>
     </head>
     <body>
       <nav>Shell navigation</nav>
       <main>
         <fragment-outlet fragment-id="logs">
         </fragment-outlet>
       </main>

       <!-- Pre-pierced fragment -->
       <fragment-host fragment-id="logs">
         <div>Logs UI rendered on server</div>
       </fragment-host>
     </body>
   </html>
        ↓
8. Browser executa:
   - Web components se registram
   - FragmentOutlet procura host
   - Host é "perfurado" no outlet (move DOM)
   - Fragment está visível!
----

=== Web Components

O Piercing utiliza dois Web Components customizados:

==== fragment-outlet

Placeholder que marca onde o fragmento deve aparecer. Pode buscar fragmento sob demanda ou receber pré-carregado.

[source,typescript]
----
class FragmentOutlet extends HTMLElement {
  async connectedCallback() {
    // 1. Procura host pre-pierced no DOM
    const host = document.querySelector(
      `fragment-host[fragment-id="${this.fragmentId}"]`
    );

    if (host) {
      // Pre-pierced: move host para dentro do outlet
      host.pierceInto(this);
    } else {
      // Lazy: busca fragmento do servidor
      const stream = await this.fetchFragment();
      await this.streamFragmentInto(stream);
    }
  }
}
----

==== fragment-host

Envolve o conteúdo SSR do fragmento. Gerencia ciclo de vida e MessageBus isolado.

[source,typescript]
----
class FragmentHost extends HTMLElement {
  pierceInto(outlet: Element) {
    // Move este elemento para dentro do outlet
    // Preserva foco e evita re-renders
    outlet.appendChild(this);
  }

  get messageBus() {
    // MessageBus isolado para este fragmento
    return this[MESSAGE_BUS_PROP];
  }
}
----

== Pre-piercing vs Lazy Loading

Piercing suporta duas estratégias de carregamento:

=== Pre-piercing

Fragmento é renderizado no servidor e incluído no HTML inicial.

**Vantagens**:
- Conteúdo visível imediatamente
- Melhor SEO
- Sem loading spinners
- Menos requisições HTTP

**Desvantagens**:
- HTML inicial maior
- Fragmento carrega mesmo se usuário não visualizar

**Quando usar**: Fragmentos visíveis no primeiro carregamento (conteúdo principal)

[source,typescript]
----
gateway.registerFragment({
  fragmentId: "logs",
  prePierceRoutes: ["/cpanel/logs*"], // Pre-pierce nestas rotas
  fetchFragment: async (req) => logsWorker.fetch(req),
});
----

=== Lazy Loading

Fragmento é buscado sob demanda quando o outlet aparece no DOM.

**Vantagens**:
- HTML inicial menor
- Fragmento só carrega se necessário
- Útil para tabs, modals, conteúdo condicional

**Desvantagens**:
- Loading spinner visível
- Requisição HTTP adicional
- Conteúdo não disponível para SEO

**Quando usar**: Fragmentos em tabs, modals, ou rotas menos frequentes

[source,typescript]
----
gateway.registerFragment({
  fragmentId: "settings",
  // SEM prePierceRoutes = lazy loading
  fetchFragment: async (req) => settingsWorker.fetch(req),
});
----

[source,html]
----
<!-- Fragment será buscado quando este elemento aparecer -->
<fragment-outlet fragment-id="settings" />
----

=== Híbrido

É possível combinar ambas estratégias:

[source,typescript]
----
gateway.registerFragment({
  fragmentId: "notifications",
  prePierceRoutes: ["/cpanel/dashboard"], // Pre-pierce no dashboard
  fetchFragment: async (req) => notificationsWorker.fetch(req),
});
----

[source,html]
----
<!-- Em /cpanel/dashboard: pre-pierced -->
<!-- Em outras rotas: lazy loading -->
<fragment-outlet fragment-id="notifications" />
----

== Estratégias de Isolamento de Fragmentos

=== Comparação de Estratégias

[cols="1,1,1,1,1"]
|===
| Estratégia | DOM | JS Global | CSS | Network

| none
| Compartilhado
| Compartilhado
| Compartilhado
| Shell context

| patch
| Compartilhado
| Compartilhado
| Compartilhado
| Interceptado

| iframe
| Isolado
| Isolado
| Isolado
| Fragment context
|===

=== Escolhendo a Estratégia

[source]
----
Fragmento interno (plugin)?
  ├─ Sim → none
  └─ Não → Fragmento externo
      ├─ Precisa isolamento total?
      │   ├─ Sim → iframe
      │   └─ Não → Precisa interceptar navegação?
      │       ├─ Sim → patch
      │       └─ Não → none
----

=== Comunicação entre Estratégias

Todas as estratégias suportam MessageBus:

* **none/patch**: MessageBus compartilhado (mesmo objeto)
* **iframe**: MessageBus via `postMessage` (serialização automática)

[source,typescript]
----
// Shell ou qualquer fragmento
getBus().dispatch("theme-changed", { theme: "dark" });

// Fragment em iframe recebe normalmente
getBus().listen("theme-changed", (data) => {
  // MessageBus abstrai postMessage
  updateTheme(data.theme);
});
----

== Quando Usar Piercing

=== Casos de Uso Ideais

**Multi-tenant com customização**

Cada tenant pode ter fragmentos customizados sem afetar a shell principal.

[source,typescript]
----
gateway.registerFragment({
  fragmentId: "tenant-dashboard",
  shouldBeIncluded: async (req) => {
    const tenant = await getTenantFromRequest(req);
    return tenant.hasCustomDashboard;
  },
  fetchFragment: async (req) => {
    const tenant = await getTenantFromRequest(req);
    return tenantWorkers.get(tenant.id).fetch(req);
  },
});
----

**Modernização gradual de monolitos**

Migrar partes de aplicação legada para micro-frontends sem reescrever tudo.

[source,html]
----
<!-- Shell moderna em React -->
<nav>Nova navegação</nav>
<main>
  <!-- Fragmento legado isolado em iframe -->
  <fragment-outlet
    fragment-id="legacy-billing"
    sandbox="iframe"
    origin="https://legacy.internal"
  />
</main>
----

**Admin dashboards modulares**

Plugins contribuem com suas próprias UIs de forma isolada.

[source,typescript]
----
// Plugin de logs
export const plugin: BuntimePlugin = {
  fragment: {
    fragmentId: "logs",
    prePierceRoutes: ["/cpanel/logs*"],
    fetchFragment: async (req) => logsApp.fetch(req),
  },
};

// Plugin de métricas
export const plugin: BuntimePlugin = {
  fragment: {
    fragmentId: "metrics",
    prePierceRoutes: ["/cpanel/metrics*"],
    fetchFragment: async (req) => metricsApp.fetch(req),
  },
};
----

**A/B testing de UIs**

Servir diferentes fragmentos com base em experimentos.

[source,typescript]
----
gateway.registerFragment({
  fragmentId: "checkout-v2",
  shouldBeIncluded: async (req) => {
    const user = await getUserFromRequest(req);
    return isInExperiment(user, "checkout-redesign");
  },
  fetchFragment: async (req) => checkoutV2.fetch(req),
});
----

=== Quando NÃO Usar

**Aplicação monolítica simples**

Se você tem uma única equipe e stack, um monolito é mais simples.

**Componentes reutilizáveis**

Para compartilhar componentes entre projetos, use bibliotecas de componentes (npm packages).

**Performance crítica**

Micro-frontends adicionam overhead. Para apps onde cada milissegundo conta, considere monolito otimizado.

**Equipe pequena**

Micro-frontends são úteis para múltiplas equipes. Equipe pequena gerencia melhor um monolito.

== Comparação com Outras Soluções

=== Piercing vs Iframes

[cols="2,3,3"]
|===
| Aspecto | Piercing | Iframes

| SSR
| Sim, streaming nativo
| Não, iframe carrega após HTML

| SEO
| Fragmentos indexáveis
| Conteúdo não indexado

| Performance
| Renderização única
| Múltiplos contextos

| Isolamento
| Configurável (none/iframe)
| Sempre isolado

| Comunicação
| MessageBus direto
| postMessage manual

| Estilos
| Compartilhados ou isolados
| Sempre isolados

| Roteamento
| Unificado na shell
| Cada iframe seu router
|===

=== Piercing vs Module Federation

[cols="2,3,3"]
|===
| Aspecto | Piercing | Module Federation

| Runtime
| Servidor + Cliente
| Apenas cliente

| SSR
| Streaming nativo
| Requer setup complexo

| Compartilhamento
| MessageBus (eventos)
| Módulos compartilhados

| Build
| Independente por fragmento
| Requer Webpack/Rspack

| Isolamento
| 4 estratégias
| Mesmo bundle context

| Versioning
| Por fragmento (URL)
| Por dependência (npm)

| Deploy
| Fragmentos independentes
| Requer sincronização
|===

=== Piercing vs Single-SPA

[cols="2,3,3"]
|===
| Aspecto | Piercing | Single-SPA

| Arquitetura
| SSR streaming
| Client-side mounting

| Carregamento inicial
| HTML completo
| Shell + JS bundles

| Framework
| Qualquer (SSR)
| Adaptadores necessários

| Roteamento
| Shell controla
| Cada app seu router

| Comunicação
| MessageBus isomórfico
| Custom events

| Learning curve
| Conceitos simples
| Lifecycle complexo
|===

=== Quando Escolher Cada Uma

**Use Piercing quando**:
- SSR é importante (SEO, performance)
- Fragmentos precisam ser independentes
- Quer diferentes níveis de isolamento
- Deploy independente é prioridade

**Use Iframes quando**:
- Isolamento total é obrigatório
- Fragmentos de terceiros não confiáveis
- Simplicidade de implementação

**Use Module Federation quando**:
- Compartilhamento de código é crítico
- Mesma stack em todos fragmentos
- Build-time optimization é prioridade

**Use Single-SPA quando**:
- Já usa client-side rendering
- Precisa suportar frameworks legados
- Roteamento por aplicação é necessário
