== Web Components

O Piercing utiliza dois Web Components customizados para gerenciar fragmentos no DOM: `<fragment-host>` e `<fragment-outlet>`. Estes componentes trabalham em conjunto para implementar o padrão de "piercing", permitindo que fragmentos sejam renderizados via SSR e posteriormente movidos para seus destinos finais no DOM.

=== FragmentHost

O `FragmentHost` é um elemento customizado que encapsula o conteúdo SSR de um fragmento. Ele gerencia o ciclo de vida do fragmento, incluindo limpeza de recursos, observação de estilos e integração com o message bus.

==== Atributos

[cols="1,1,3"]
|===
| Atributo | Tipo | Descrição

| `src`
| string
| URL de onde o fragmento foi originado (obrigatório)
|===

==== Propriedades

[cols="1,1,3"]
|===
| Propriedade | Tipo | Descrição

| `src`
| string
| URL do fragmento obtida do atributo `src`

| `messageBus`
| FragmentMessageBus
| Instância do message bus isolada para este fragmento

| `isPierced`
| boolean
| Indica se o fragmento está dentro de um outlet
|===

==== Métodos

[cols="1,3"]
|===
| Método | Descrição

| `pierceInto(outlet: Element): void`
| Move o fragment host para dentro de um elemento outlet, preservando foco e estado

| `onCleanup(handler: () => void): void`
| Registra um callback para ser executado quando o fragmento for removido do DOM
|===

==== Ciclo de Vida

[source,typescript]
----
// Conexão
connectedCallback(): void {
  // 1. Valida presença do atributo src
  // 2. Inicializa a propriedade src
  // 3. Se não pierced, inicia observador de estilos
}

// Desconexão
disconnectedCallback(): void {
  // 1. Limpa todos os handlers do message bus
  // 2. Executa callbacks registrados via onCleanup()
  // 3. Remove observadores de mutação
}
----

==== Exemplo de Uso

[source,html]
----
<!-- Fragment host gerado via SSR -->
<fragment-host src="/health">
  <div class="health-dashboard">
    <!-- Conteúdo do fragmento -->
  </div>
  <link rel="stylesheet" href="/health/styles.css">
  <script type="module" src="/health/client.js"></script>
</fragment-host>
----

==== Gerenciamento de Estilos

O `FragmentHost` converte automaticamente links de folhas de estilo externas em estilos inline quando o fragmento não está dentro de um outlet. Isso é necessário porque fragmentos podem ter CSS de diferentes origens.

[source,typescript]
----
// Processo automático de embedação de estilos
private embedExternalStyles(): void {
  const styleLinks = this.querySelectorAll('link[href][rel="stylesheet"]');

  for (const link of styleLinks) {
    if (link.sheet) {
      // Extrai CSS rules
      let cssText = "";
      for (const rule of link.sheet.cssRules) {
        cssText += `${rule.cssText}\n`;
      }

      // Substitui link por style inline
      const style = document.createElement("style");
      style.textContent = cssText;
      link.replaceWith(style);
    }
  }
}
----

==== Preservação de Foco

Durante o processo de piercing, o foco é preservado automaticamente:

[source,typescript]
----
pierceInto(outlet: Element): void {
  // Captura elemento com foco
  const activeElement = this.contains(document.activeElement)
    ? (document.activeElement as HTMLElement)
    : null;

  // Desabilita cleanup temporariamente
  this.cleanup = false;
  outlet.appendChild(this);
  this.cleanup = true;

  // Restaura foco
  activeElement?.focus();

  // Para observação de estilos
  this.removeStylesObserver();
}
----

=== FragmentOutlet

O `FragmentOutlet` é um elemento placeholder que marca onde um fragmento deve ser renderizado. Ele é responsável por buscar fragmentos sob demanda ou receber fragmentos pré-renderizados via piercing.

==== Atributos

[cols="1,1,3"]
|===
| Atributo | Tipo | Descrição

| `src`
| string
| URL do fragmento a ser carregado (obrigatório)

| `base`
| string
| Caminho base da shell para contexto de roteamento (opcional)

| `history`
| string
| Estratégia de isolamento de navegação: `"patch"` (intercepta History API) ou `"isolate"` (usa iframe). Padrão: sem isolamento
|===

==== Propriedades

[cols="1,1,3"]
|===
| Propriedade | Tipo | Descrição

| `piercingFragmentOutlet`
| boolean
| Marcador constante (`true`) para identificação como outlet

| `fragmentHost`
| FragmentHost \| null
| Referência ao fragment host atual
|===

==== Estratégias de Isolamento de Navegação

[cols="1,3"]
|===
| Estratégia | Descrição

| Sem atributo `history`
| Sem isolamento, compartilha contexto de navegação com aplicação principal

| `patch`
| Intercepta History API para isolar navegação do fragmento

| `isolate`
| Isolamento completo via iframe (carrega fragmento em contexto separado)
|===

==== Exemplos de Uso

[source,html]
----
<!-- Plugin interno sem isolamento -->
<fragment-outlet src="/logs" />

<!-- Plugin com contexto de roteamento -->
<fragment-outlet src="/metrics" base="/cpanel" />

<!-- Aplicação com patch de navegação -->
<fragment-outlet src="/metrics" base="/cpanel" history="patch" />

<!-- Aplicação externa isolada com iframe -->
<fragment-outlet src="/external" base="/cpanel" history="isolate" />

<!-- Fragmento customizado -->
<fragment-outlet src="/custom/fragment/path" />
----

==== Ciclo de Vida

[source,typescript]
----
async connectedCallback(): Promise<void> {
  // 1. Obtém atributos (src, base, history)
  // 2. Valida presença de src

  // Se history é isolate:
  if (history === "isolate") {
    // Inicializa iframe isolado (iframe gerencia próprio carregamento)
    await this.initIframe();
    return;
  }

  // Para outras estratégias:
  // 3. Inicializa patch de navegação se history="patch"
  // 4. Busca fragment host existente no DOM (pré-pierced)

  if (this.fragmentHost) {
    // 5a. Move fragment host para este outlet
    this.fragmentHost.pierceInto(this);
  } else {
    // 5b. Busca fragmento sob demanda via fetch
    const stream = await this.fetchFragment(url);
    await this.streamFragmentInto(stream);
  }
}

disconnectedCallback(): void {
  // 1. Limpa patch de navegação
  // 2. Registra fragmento como desmontado
  // 3. Remove referência ao fragment host
}
----

==== Busca de Fragmentos

O outlet busca fragmentos via fetch, enviando o estado atual do message bus:

[source,typescript]
----
private async fetchFragment(url: string): Promise<ReadableStream> {
  const state = getGlobalBus().state;

  const response = await fetch(url, {
    headers: {
      "x-message-bus-state": JSON.stringify(state),
    },
  });

  if (!response.body) {
    throw new Error(`Empty response when fetching fragment from "${url}"`);
  }

  return response.body;
}
----

==== Streaming HTML

O outlet utiliza `DOMParser` para processar HTML de forma segura:

[source,typescript]
----
private async streamFragmentInto(
  stream: ReadableStream
): Promise<void> {
  // 1. Lê todo o stream
  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();
  let html = "";

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    html += value;
  }

  // 2. Parse HTML via DOMParser
  const parser = new DOMParser();
  const doc = parser.parseFromString(html, "text/html");

  // 3. Move elementos do body para o outlet
  this.clearChildren();
  while (doc.body.firstChild) {
    this.appendChild(doc.body.firstChild);
  }

  // 4. Re-executa scripts de módulo se fragmento foi desmontado antes
  const src = this.getAttribute("src");
  if (src && unmountedFragmentIds.has(src)) {
    this.rerunModuleScripts();
  }
}
----

==== Re-execução de Scripts

Quando um fragmento é desmontado e remontado, seus scripts de módulo são re-executados:

[source,typescript]
----
private rerunModuleScripts(): void {
  const scripts = this.querySelectorAll('script[type="module"][src]');

  for (const script of scripts) {
    const src = (script as HTMLScriptElement).src;
    import(/* @vite-ignore */ src).then((module) => module.default?.());
  }
}
----

IMPORTANT: Scripts de módulo devem exportar uma função `default` para serem re-executáveis.

=== Registro de Componentes

A função `registerPiercingComponents()` registra ambos os Web Components no custom elements registry. Deve ser chamada uma única vez no início da aplicação.

[source,typescript]
----
import { registerPiercingComponents } from "@buntime/piercing/client";

// No entry point da aplicação
registerPiercingComponents();
----

==== Implementação

[source,typescript]
----
export function registerPiercingComponents(): void {
  if (typeof window === "undefined") return;

  if (!customElements.get("fragment-host")) {
    customElements.define("fragment-host", FragmentHost);
  }

  if (!customElements.get("fragment-outlet")) {
    customElements.define("fragment-outlet", FragmentOutlet);
  }
}
----

==== Suporte TypeScript

Para usar os componentes em JSX/TSX, adicione as seguintes declarações ao seu projeto:

[source,typescript]
----
declare global {
  namespace JSX {
    interface IntrinsicElements {
      "fragment-host": {
        "src": string;
      } & Record<string, unknown>;

      "fragment-outlet": {
        "src": string;
        "base"?: string;
        "history"?: "patch" | "isolate";
      } & Record<string, unknown>;
    }
  }
}
----

=== FragmentMessageBus

Cada `FragmentHost` possui uma instância isolada de `FragmentMessageBus`, que é um wrapper do message bus global com rastreamento de cleanup.

==== Métodos

[cols="1,3"]
|===
| Método | Descrição

| `dispatch(eventName: string, value: JSONValue): void`
| Envia evento para o message bus global

| `listen<T>(eventName: string, callback: MessageBusCallback<T>): () => void`
| Escuta eventos do message bus, registrando cleanup automático

| `latestValue<T>(eventName: string): T \| undefined`
| Obtém o último valor publicado em um evento

| `clearAllHandlers(): void`
| Remove todos os listeners registrados via este bus
|===

==== Acesso via Fragment Client

[source,typescript]
----
import { getBus } from "@buntime/piercing/fragment-client";

const bus = getBus();

// Enviar evento
bus.dispatch("user:updated", { id: 123, name: "João" });

// Escutar evento
const unsubscribe = bus.listen("user:updated", (data) => {
  console.log("User updated:", data);
});

// Cleanup é automático quando fragment é desmontado
// Mas pode limpar manualmente se necessário
unsubscribe();
----

==== Symbol Compartilhado

O message bus é acessível via symbol global:

[source,typescript]
----
const MESSAGE_BUS_PROP = Symbol.for("piercing:fragment-message-bus");

// No fragment host
[MESSAGE_BUS_PROP] = new FragmentMessageBus();

// No fragment client
const host = document.querySelector("fragment-host");
const bus = host?.[MESSAGE_BUS_PROP];
----

=== Fluxo Completo de Renderização

==== Pre-Piercing (SSR)

[source]
----
1. Servidor renderiza HTML com fragment-host
   ↓
2. HTML contém <fragment-host src="/logs">
   ↓
3. Browser registra componentes via registerPiercingComponents()
   ↓
4. Fragment host conecta e inicializa message bus
----

==== Piercing

[source]
----
5. Outlet conecta: <fragment-outlet src="/logs">
   ↓
6. Outlet encontra fragment-host no DOM
   ↓
7. Outlet chama fragmentHost.pierceInto(outlet)
   ↓
8. Fragment host move-se para dentro do outlet
   ↓
9. Foco e estado preservados
----

==== Lazy Loading

[source]
----
5. Outlet conecta: <fragment-outlet src="/metrics">
   ↓
6. Fragment não encontrado no DOM
   ↓
7. Outlet busca via fetch(/metrics)
   ↓
8. Stream HTML via DOMParser
   ↓
9. Fragment-host criado e inserido no outlet
----

=== Gerenciamento de Estado

==== Fragmentos Desmontados

O outlet mantém um set de URLs de fragmentos desmontados:

[source,typescript]
----
private static unmountedFragmentIds = new Set<string>();

disconnectedCallback(): void {
  const src = this.getAttribute("src");
  if (src && this.fragmentHost) {
    // Registra fragmento como desmontado
    FragmentOutlet.unmountedFragmentIds.add(src);
  }
}
----

Quando um fragmento é remontado, seus scripts de módulo são re-executados:

[source,typescript]
----
const src = this.getAttribute("src");
if (src && FragmentOutlet.unmountedFragmentIds.has(src)) {
  this.rerunModuleScripts();
}
----

==== Cleanup Condicional

O fragment host desabilita cleanup durante movimentação no DOM:

[source,typescript]
----
pierceInto(outlet: Element): void {
  this.cleanup = false;  // Desabilita cleanup
  outlet.appendChild(this);
  this.cleanup = true;   // Reabilita cleanup
}

disconnectedCallback(): void {
  if (this.cleanup) {
    // Só limpa se não está sendo movido
    this[MESSAGE_BUS_PROP].clearAllHandlers();
  }
}
----

Isso previne limpeza acidental de recursos durante operações de piercing.
