== Setup Básico

Este exemplo demonstra como configurar micro-frontends com Piercing. A arquitetura é simples: use web components no HTML e opcionalmente habilite pre-piercing via plugin.

=== HTML Shell com Web Components

O HTML shell deve incluir os elementos `<fragment-outlet>` onde os fragmentos serão injetados:

[source,html]
----
<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8">
    <title>Dashboard</title>
  </head>
  <body>
    <!-- Navegação do shell -->
    <nav>
      <a href="/dashboard">Dashboard</a>
      <a href="/deployments">Deployments</a>
      <a href="/metrics">Metrics</a>
    </nav>

    <!-- Área principal -->
    <main>
      <!-- Outlet: marca onde o fragmento será renderizado -->
      <fragment-outlet src="/p/deployments" base="/dashboard">
        <!-- Loading placeholder (opcional) -->
        <div class="loading">Carregando...</div>
      </fragment-outlet>
    </main>

    <!-- Script do cliente que registra os web components -->
    <script type="module">
      import { registerPiercingComponents } from '@buntime/piercing/client';

      // Registrar <fragment-outlet> e <fragment-host>
      registerPiercingComponents();
    </script>
  </body>
</html>
----

=== Atributos do fragment-outlet

[cols="1,1,3"]
|===
| Atributo | Tipo | Descrição

| `src`
| string (required)
| URL para buscar o fragmento (ex: `/p/metrics`)

| `base`
| string
| Base path do shell para contexto de roteamento

| `history`
| "patch" \| "isolate"
| Estratégia de isolamento de histórico
|===

=== Client Shell Setup

Configure o shell client para escutar eventos dos fragmentos:

[source,typescript]
----
import { registerPiercingComponents, getBus } from "@buntime/piercing/client";

// Registrar os web components
registerPiercingComponents();

// Obter o bus global
const bus = getBus();

// Escutar eventos de navegação dos fragmentos
bus.listen("navigate", (payload) => {
  const { url, replace } = payload;

  if (replace) {
    window.history.replaceState(null, "", url);
  } else {
    window.history.pushState(null, "", url);
  }
});

// Escutar notificações dos fragmentos
bus.listen("notification", (payload) => {
  const { type, message } = payload;
  showNotification(type, message);
});

// Despachar evento de tema quando usuário mudar
document.getElementById("theme-toggle")?.addEventListener("click", () => {
  const newTheme = bus.latestValue("theme") === "dark" ? "light" : "dark";
  bus.dispatch("theme:changed", newTheme);
  document.documentElement.setAttribute("data-theme", newTheme);
});
----

=== Pre-Piercing (Server-Side)

Para habilitar pre-piercing (server-side rendering do fragmento dentro do shell), adicione o plugin `@buntime/plugin-piercing` ao runtime:

[source,jsonc]
----
// buntime.jsonc
{
  "plugins": [
    "@buntime/plugin-piercing"
  ]
}
----

O plugin automaticamente:

1. Detecta `<fragment-outlet src="...">` no HTML
2. Busca o conteúdo de cada fragmento em paralelo
3. Injeta `<fragment-host src="...">` com o conteúdo antes de `</body>`

=== Fluxo de Renderização

==== Sem Pre-Piercing (Client-Side Only)

1. Servidor retorna HTML shell com `<fragment-outlet src="/p/metrics">`
2. Browser renderiza shell e registra web components
3. `<fragment-outlet>` faz fetch para `/p/metrics`
4. Conteúdo é injetado no Shadow DOM via streaming

==== Com Pre-Piercing (SSR)

1. Plugin intercepta a resposta HTML
2. Encontra todos os `<fragment-outlet src="...">`
3. Busca fragmentos em paralelo
4. Injeta `<fragment-host>` antes de `</body>`
5. Browser recebe HTML completo
6. `<fragment-outlet>` detecta host existente e move para Shadow DOM
7. Zero fetches adicionais no cliente

=== Exemplo de Fragmento

Um fragmento é uma aplicação que responde com HTML:

[source,typescript]
----
// plugins/plugin-deployments/plugin.ts
import { Hono } from "hono";

const app = new Hono();

app.get("/", async (req) => {
  return new Response(
    `
    <div id="deployments-root">
      <h1>Deployments</h1>
      <!-- Conteúdo SSR -->
    </div>
    <script type="module" src="./client.js"></script>
    `,
    { headers: { "Content-Type": "text/html" } }
  );
});

export default {
  name: "deployments",
  app,
};
----

=== Comunicação entre Fragmentos

Use o MessageBus para comunicação:

[source,typescript]
----
// No fragmento
import { getFragmentBus } from "@buntime/piercing/client";

const bus = getFragmentBus();

// Emitir evento para o shell
bus.dispatch("deployment:created", { id: "deploy-123", name: "v1.2.0" });

// Escutar eventos do shell
bus.listen("theme:changed", (theme) => {
  document.body.setAttribute("data-theme", theme);
});
----
