== Fragmento React

Este exemplo demonstra como criar um fragmento React completo com comunicação via PiercingClient, hooks personalizados e gerenciamento de ciclo de vida.

=== Componente React com PiercingClient

[source,tsx]
----
import { useEffect, useRef, useState } from "react";
import { getPiercingClient, getFragmentHost } from "@buntime/piercing/client";

interface DeploymentItem {
  id: string;
  name: string;
  status: "pending" | "success" | "failed";
  timestamp: number;
}

function DeploymentsFragment() {
  // Obter cliente piercing
  const piercing = getPiercingClient();

  // Estado local do fragmento
  const [deployments, setDeployments] = useState<DeploymentItem[]>([]);
  const [theme, setTheme] = useState(piercing.state.theme || "light");

  // Ref para registrar cleanup
  const containerRef = useRef<HTMLDivElement>(null);

  // Sincronizar tema do shell
  useEffect(() => {
    return piercing.onStateChange((state) => {
      if (state.theme !== theme) {
        setTheme(state.theme);
      }
    });
  }, [piercing, theme]);

  // Escutar eventos de outros fragmentos
  useEffect(() => {
    const cleanup = piercing.on<{ id: string }>("deployment:triggered", (payload) => {
      // Adicionar novo deployment à lista
      setDeployments((prev) => [
        {
          id: payload.id,
          name: `Deploy ${payload.id}`,
          status: "pending",
          timestamp: Date.now(),
        },
        ...prev,
      ]);
    });

    return cleanup;
  }, [piercing]);

  // Registrar cleanup quando fragmento for removido
  useEffect(() => {
    const host = getFragmentHost(containerRef.current);

    if (host) {
      host.onCleanup(() => {
        console.log("Fragment cleanup: deployments");
        // Limpar estado, cancelar subscriptions, etc.
      });
    }
  }, []);

  const handleDeploy = async () => {
    const newDeployment: DeploymentItem = {
      id: crypto.randomUUID(),
      name: `Deploy ${Date.now()}`,
      status: "pending",
      timestamp: Date.now(),
    };

    setDeployments((prev) => [newDeployment, ...prev]);

    // Notificar shell
    piercing.dispatch("notification", {
      type: "info",
      message: "Deployment iniciado",
    });

    try {
      // Simular deploy
      await new Promise((resolve) => setTimeout(resolve, 2000));

      setDeployments((prev) =>
        prev.map((d) =>
          d.id === newDeployment.id ? { ...d, status: "success" } : d,
        ),
      );

      piercing.dispatch("notification", {
        type: "success",
        message: "Deployment concluído com sucesso",
      });
    } catch (error) {
      setDeployments((prev) =>
        prev.map((d) =>
          d.id === newDeployment.id ? { ...d, status: "failed" } : d,
        ),
      );

      piercing.dispatch("notification", {
        type: "error",
        message: "Falha no deployment",
      });
    }
  };

  const handleNavigateToDetails = (id: string) => {
    // Navegar dentro do fragmento
    piercing.navigate(`/deployments/${id}`);
  };

  return (
    <div ref={containerRef} className={`deployments-fragment theme-${theme}`}>
      <header>
        <h2>Deployments</h2>
        <button onClick={handleDeploy}>New Deploy</button>
      </header>

      <div className="deployments-list">
        {deployments.length === 0 ? (
          <p>Nenhum deployment encontrado</p>
        ) : (
          deployments.map((deployment) => (
            <div key={deployment.id} className={`deployment-item status-${deployment.status}`}>
              <h3>{deployment.name}</h3>
              <span className="status">{deployment.status}</span>
              <span className="timestamp">
                {new Date(deployment.timestamp).toLocaleString("pt-BR")}
              </span>
              <button onClick={() => handleNavigateToDetails(deployment.id)}>
                Ver Detalhes
              </button>
            </div>
          ))
        )}
      </div>
    </div>
  );
}

export default DeploymentsFragment;
----

=== Hook Customizado para Estado Piercing

[source,tsx]
----
import { useEffect, useState } from "react";
import { getPiercingClient } from "@buntime/piercing/client";
import type { MessageBusState } from "@buntime/piercing";

/**
 * Hook para sincronizar estado do shell com componente React
 */
export function usePiercingState<T = MessageBusState>(): T {
  const piercing = getPiercingClient();
  const [state, setState] = useState<T>(piercing.state as T);

  useEffect(() => {
    return piercing.onStateChange((newState) => {
      setState(newState as T);
    });
  }, [piercing]);

  return state;
}

/**
 * Hook para sincronizar uma chave específica do estado
 */
export function usePiercingValue<T>(key: string): T | undefined {
  const state = usePiercingState();
  return state[key] as T | undefined;
}

/**
 * Hook para despachar eventos com callback memorizado
 */
export function usePiercingDispatch() {
  const piercing = getPiercingClient();

  return {
    dispatch: piercing.dispatch.bind(piercing),
    navigate: piercing.navigate.bind(piercing),
  };
}

/**
 * Hook para escutar eventos do bus
 */
export function usePiercingEvent<T>(
  eventName: string,
  callback: (payload: T) => void,
) {
  const piercing = getPiercingClient();

  useEffect(() => {
    return piercing.on(eventName, callback);
  }, [piercing, eventName, callback]);
}
----

=== Usando os Hooks Customizados

[source,tsx]
----
import { usePiercingState, usePiercingValue, usePiercingDispatch, usePiercingEvent } from "./hooks/usePiercing";

function UserProfile() {
  // Obter valor específico do estado
  const user = usePiercingValue<{ name: string; email: string }>("user");
  const theme = usePiercingValue<string>("theme");

  // Obter dispatch
  const { dispatch } = usePiercingDispatch();

  // Escutar evento
  usePiercingEvent("profile:updated", (payload) => {
    console.log("Profile updated:", payload);
  });

  const handleLogout = () => {
    dispatch("auth:logout", { userId: user?.id });
  };

  if (!user) {
    return <div>Carregando usuário...</div>;
  }

  return (
    <div className={`user-profile theme-${theme}`}>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
      <button onClick={handleLogout}>Logout</button>
    </div>
  );
}

export default UserProfile;
----

=== Entry Point do Fragmento

[source,tsx]
----
import React from "react";
import { createRoot, hydrateRoot } from "react-dom/client";
import DeploymentsFragment from "./DeploymentsFragment";
import "./styles.css";

// Verificar se é SSR ou client-side
const container = document.getElementById("app");

if (!container) {
  throw new Error("Container #app não encontrado");
}

// Se já tem conteúdo SSR, fazer hydrate
// Caso contrário, render normal
if (container.hasChildNodes()) {
  hydrateRoot(container, <DeploymentsFragment />);
} else {
  const root = createRoot(container);
  root.render(<DeploymentsFragment />);
}
----

=== Configuração TypeScript para o Fragmento

[source,json]
----
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "react-jsx",
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "strict": true,
    "skipLibCheck": true,
    "types": ["bun-types"]
  },
  "include": ["src/**/*"]
}
----

=== Build do Fragmento

[source,typescript]
----
// build.ts
await Bun.build({
  entrypoints: ["./src/index.tsx"],
  outdir: "./dist",
  target: "browser",
  format: "esm",
  splitting: true,
  minify: true,
  sourcemap: "external",
  external: ["react", "react-dom"], // Se compartilhados pelo shell
});

console.log("Fragment built successfully!");
----

=== Resultado

O fragmento React agora pode:

1. Ler estado compartilhado do shell (tema, usuário, etc.)
2. Sincronizar automaticamente quando o estado mudar
3. Despachar eventos para o shell e outros fragmentos
4. Navegar internamente notificando o shell
5. Limpar recursos quando for removido da DOM
6. Funcionar tanto com SSR quanto client-side rendering
