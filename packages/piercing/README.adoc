= @buntime/piercing
:toc: left
:toclevels: 3
:sectnums:
:icons: font

Micro-frontend library for Buntime plugins using Fragment Piercing architecture.

== Overview

This library enables plugins to serve their own UI as independent fragments that get "pierced" into the main dashboard shell. Inspired by https://blog.cloudflare.com/fragment-piercing/[Cloudflare's Fragment Piercing].

=== Key Features

- **SSR Streaming**: Fragments are server-rendered and streamed to the client
- **Pre-piercing**: Fragments can be embedded in the initial HTML response
- **Lazy Loading**: Fragments not pre-pierced are fetched on demand
- **MessageBus**: Framework-agnostic communication between fragments
- **Style Isolation**: External stylesheets are embedded to avoid CORS issues

== Installation

[source,bash]
----
bun add @buntime/piercing
----

== Quick Start

=== Server (Gateway)

[source,typescript]
----
import { Hono } from "hono";
import { PiercingGateway } from "@buntime/piercing";

const app = new Hono();

const gateway = new PiercingGateway({
  getShellHtml: async (req) => {
    // Return your shell/dashboard HTML
    return `<!DOCTYPE html>
      <html>
        <head><title>Dashboard</title></head>
        <body>
          <nav>...</nav>
          <main id="content"></main>
        </body>
      </html>`;
  },
  generateMessageBusState: async (state, req) => ({
    ...state,
    theme: "dark",
    user: { name: "John" },
  }),
});

// Register fragments
gateway.registerFragment({
  fragmentId: "deployments",
  prePierceRoutes: ["/dashboard/deployments*"],
  fetchFragment: async (req) => {
    // Fetch SSR content from fragment worker
    return fragmentWorker.fetch(req);
  },
});

// Add middleware
app.use("*", gateway.middleware());
----

=== Client (Shell)

[source,typescript]
----
import { registerPiercingComponents, getBus } from "@buntime/piercing/client";

// Register web components
registerPiercingComponents();

// Listen for events from fragments
getBus().listen("navigate", (path) => {
  router.push(path);
});
----

=== Client (Fragment)

[source,tsx]
----
import { getBus } from "@buntime/piercing/client";

function DeploymentsFragment() {
  const handleDeploy = () => {
    getBus().dispatch("notification", {
      type: "success",
      message: "Deployed!",
    });
  };

  return <button onClick={handleDeploy}>Deploy</button>;
}
----

== API Reference

=== Server Exports

[source,typescript]
----
import {
  PiercingGateway,
  ServerMessageBus,
  MESSAGE_BUS_STATE_HEADER,
  // Stream utilities
  concatenateStreams,
  wrapStreamInText,
  transformStream,
  stringToStream,
} from "@buntime/piercing";
----

==== PiercingGateway

Main gateway class that handles fragment routing and HTML injection.

[source,typescript]
----
interface PiercingGatewayConfig {
  getShellHtml: (request: Request) => Promise<string>;
  generateMessageBusState?: (
    state: MessageBusState,
    request: Request,
  ) => MessageBusState | Promise<MessageBusState>;
  shouldPiercingBeEnabled?: (request: Request) => boolean | Promise<boolean>;
}

class PiercingGateway {
  constructor(config: PiercingGatewayConfig);
  registerFragment(config: FragmentConfig): void;
  getFragments(): FragmentConfig[];
  middleware(): MiddlewareHandler;
}
----

==== FragmentConfig

[source,typescript]
----
interface FragmentConfig {
  fragmentId: string;
  framework?: "react" | "qwik" | "solid" | "vue";
  prePiercingStyles?: string;
  prePierceRoutes?: string[];
  fetchFragment: (request: Request) => Promise<Response>;
  serveAssets?: (request: Request) => Promise<Response>;
}
----

=== Client Exports

[source,typescript]
----
import {
  registerPiercingComponents,
  PiercingFragmentHost,
  PiercingFragmentOutlet,
  getBus,
  dispatch,
  subscribe,
} from "@buntime/piercing/client";
----

==== MessageBus API

[source,typescript]
----
const bus = getBus();

// Dispatch an event
bus.dispatch("eventName", { data: "value" });

// Listen for events
const cleanup = bus.listen("eventName", (value) => {
  console.log("Received:", value);
});

// Get latest value
const latest = bus.latestValue("eventName");

// Cleanup when done
cleanup();
----

==== Web Components

Use in your JSX/HTML:

[source,html]
----
<!-- Outlet where fragment will be pierced -->
<piercing-fragment-outlet fragment-id="deployments"></piercing-fragment-outlet>

<!-- Host wraps the fragment content (usually generated by gateway) -->
<piercing-fragment-host fragment-id="deployments">
  <!-- Fragment SSR content here -->
</piercing-fragment-host>
----

== How It Works

[source]
----
1. Browser requests /dashboard/deployments
                    │
                    ▼
2. Gateway intercepts HTML request
   - Fetches shell HTML
   - Checks prePierceRoutes for matching fragments
   - Fetches fragment SSR content in parallel
   - Injects MessageBus state script
   - Combines shell + fragments
                    │
                    ▼
3. Browser receives combined HTML
   <html>
     <head>
       <script>window.__PIERCING_MESSAGE_BUS_STATE__ = {...}</script>
     </head>
     <body>
       <nav>...</nav>
       <main>
         <piercing-fragment-outlet fragment-id="deployments">
         </piercing-fragment-outlet>
       </main>
       <!-- Pre-pierced fragment -->
       <piercing-fragment-host fragment-id="deployments">
         <div>Deployments UI</div>
       </piercing-fragment-host>
     </body>
   </html>
                    │
                    ▼
4. Web components initialize
   - PiercingFragmentOutlet finds matching host
   - Moves host content into outlet ("piercing")
   - Fragment is now in place!
----

== Route Patterns

The `prePierceRoutes` option supports glob patterns:

[cols="1,2"]
|===
| Pattern | Matches

| `/dashboard/deployments`
| Exact match only

| `/dashboard/deployments/*`
| Any path under deployments

| `/dashboard/*/edit`
| Any edit page under dashboard
|===

== Buntime Plugin Integration

Buntime plugins can define fragments via the `fragment` field:

[source,typescript]
----
import type { BuntimePlugin } from "@buntime/shared/types";

const plugin: BuntimePlugin = {
  name: "@buntime/plugin-deployments",
  version: "1.0.0",

  // Fragment configuration
  fragment: {
    // Optional: defaults to plugin short name ("deployments")
    fragmentId: "deployments",

    // Routes that should pre-pierce this fragment
    prePierceRoutes: ["/cpanel/deployments*"],

    // Fetch SSR content for the fragment
    fetchFragment: async (req) => {
      // Return the fragment's rendered HTML
      return deploymentsWorker.fetch(req);
    },

    // Optional: serve static assets for the fragment
    serveAssets: async (req) => {
      return serveStatic(req);
    },
  },

  // ... other plugin config
};
----

The runner automatically:

1. Collects fragments from all plugins
2. Creates a PiercingGateway when fragments are registered
3. Enables piercing middleware for the shell routes
