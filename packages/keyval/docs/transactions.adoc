== Transações Atômicas

=== Visão Geral

O KeyVal suporta **transações atômicas** com controle de concorrência otimista usando **versionstamps**. Isso permite:

* Múltiplas operações em uma única transação
* Verificações de versão para evitar conflitos
* Garantia de atomicidade (tudo ou nada)

=== Conceitos Fundamentais

==== Versionstamp

Cada entrada no KeyVal possui um **versionstamp** - um identificador único que muda a cada modificação:

[source,typescript]
----
const entry = await kv.get(["users", 123]);
console.log(entry.versionstamp); // "018d5e2a3b4c5d6e"
----

* **Formato**: String hexadecimal de 16 caracteres
* **Geração**: Timestamp + random suffix
* **Uso**: Detectar modificações concorrentes

==== Controle de Concorrência Otimista

Em vez de bloquear recursos (pessimista), o KeyVal usa abordagem otimista:

1. Ler a entrada e seu versionstamp
2. Preparar as modificações
3. Ao commitar, verificar se versionstamp ainda é válido
4. Se mudou, a transação falha e você pode tentar novamente

=== API de Transações

==== Criar Operação Atômica

[source,typescript]
----
const atomic = kv.atomic();
----

==== Métodos Disponíveis

[cols="1,3"]
|===
| Método | Descrição

| `.check(...checks)`
| Adiciona verificações de versão

| `.set(key, value, options?)`
| Adiciona operação de set

| `.delete(key)`
| Adiciona operação de delete

| `.sum(key, value)`
| Soma atômica (contadores)

| `.max(key, value)`
| Define o máximo entre valor atual e novo

| `.min(key, value)`
| Define o mínimo entre valor atual e novo

| `.append(key, values)`
| Adiciona elementos ao final de um array

| `.prepend(key, values)`
| Adiciona elementos ao início de um array

| `.commit()`
| Executa a transação
|===

==== Resultado do Commit

[source,typescript]
----
interface KvCommitResult {
  ok: true;
  versionstamp: string;
}

interface KvCommitError {
  ok: false;
}
----

=== Exemplos Básicos

==== Transação Simples

[source,typescript]
----
// Múltiplas operações atômicas
const result = await kv.atomic()
  .set(["users", 123], { name: "Alice" })
  .set(["users", 123, "profile"], { bio: "Developer" })
  .set(["users", 123, "settings"], { theme: "dark" })
  .commit();

if (result.ok) {
  console.log("Transação bem-sucedida:", result.versionstamp);
} else {
  console.log("Transação falhou");
}
----

==== Transação com Verificação

[source,typescript]
----
// Ler valor atual
const user = await kv.get(["users", 123]);

// Modificar apenas se não mudou
const result = await kv.atomic()
  .check({ key: ["users", 123], versionstamp: user.versionstamp })
  .set(["users", 123], { ...user.value, lastLogin: new Date().toISOString() })
  .commit();

if (!result.ok) {
  console.log("Conflito detectado - outro processo modificou o usuário");
}
----

==== Verificar que Chave Não Existe

[source,typescript]
----
// Criar apenas se não existe (versionstamp null = não existe)
const result = await kv.atomic()
  .check({ key: ["users", "alice@example.com"], versionstamp: null })
  .set(["users", "alice@example.com"], { name: "Alice", createdAt: Date.now() })
  .commit();

if (!result.ok) {
  console.log("Usuário já existe");
}
----

=== Padrões Comuns

==== Contador Atômico (com sum)

O método `.sum()` permite incrementar/decrementar valores numéricos atomicamente, sem necessidade de read-modify-write:

[source,typescript]
----
// Incrementar contador - SEM retry, SEM read prévio
await kv.atomic()
  .sum(["counters", "page-visits"], 1n)
  .commit();

// Decrementar estoque
await kv.atomic()
  .sum(["products", productId, "stock"], -1n)
  .commit();

// Múltiplos contadores em uma operação
await kv.atomic()
  .sum(["stats", "total_views"], 1n)
  .sum(["stats", "unique_visitors"], 1n)
  .sum(["users", oderId, "view_count"], 1n)
  .commit();
----

NOTE: O `.sum()` usa `bigint` para evitar problemas de precisão com números grandes.

==== High Score (com max)

O método `.max()` define o valor apenas se for maior que o atual:

[source,typescript]
----
// Atualizar high score apenas se for maior
await kv.atomic()
  .max(["games", oderId, "highscore"], score)
  .commit();

// Rastrear pico de usuários simultâneos
await kv.atomic()
  .max(["stats", "peak_concurrent_users"], BigInt(currentUsers))
  .commit();
----

==== Preço Mínimo (com min)

O método `.min()` define o valor apenas se for menor que o atual:

[source,typescript]
----
// Rastrear menor preço histórico
await kv.atomic()
  .min(["products", productId, "lowest_price"], BigInt(currentPrice))
  .commit();

// Rastrear menor tempo de resposta
await kv.atomic()
  .min(["metrics", "fastest_response_ms"], BigInt(responseTime))
  .commit();
----

==== Arrays Atômicos (append/prepend)

Os métodos `.append()` e `.prepend()` permitem adicionar elementos a arrays sem read-modify-write:

[source,typescript]
----
// Adicionar ao final do array (append)
await kv.atomic()
  .append(["orders", orderId, "history"], [
    { event: "created", timestamp: Date.now() }
  ])
  .commit();

// Adicionar múltiplos eventos
await kv.atomic()
  .append(["users", oderId, "activity_log"], [
    "Logged in",
    "Viewed dashboard",
    "Updated profile",
  ])
  .commit();

// Adicionar ao início do array (prepend) - atividades recentes primeiro
await kv.atomic()
  .prepend(["users", oderId, "recent_activity"], [
    { action: "login", timestamp: Date.now() }
  ])
  .commit();
----

==== Combinando Operações

Todas as operações podem ser combinadas em uma única transação:

[source,typescript]
----
await kv.atomic()
  // Contadores
  .sum(["stats", "total_orders"], 1n)
  .sum(["users", oderId, "order_count"], 1n)

  // Atualizar pico
  .max(["stats", "largest_order_value"], BigInt(orderValue))

  // Log de eventos
  .append(["orders", orderId, "events"], [
    { type: "created", timestamp: Date.now() }
  ])

  // Dados do pedido
  .set(["orders", orderId], orderData)

  .commit();
----

==== Contador Atômico (método legado)

Para casos onde você precisa do valor atual após incrementar, use o padrão read-modify-write com retry:

[source,typescript]
----
async function atomicIncrement(counterId: string): Promise<number> {
  const key = ["counters", counterId];

  while (true) {
    const entry = await kv.get<number>(key);
    const currentValue = entry.value ?? 0;
    const newValue = currentValue + 1;

    const result = await kv.atomic()
      .check({ key, versionstamp: entry.versionstamp })
      .set(key, newValue)
      .commit();

    if (result.ok) {
      return newValue;
    }

    // Conflito - tentar novamente
    console.log("Retry increment...");
  }
}

// Uso
const visits = await atomicIncrement("page-visits");
console.log(`Total de visitas: ${visits}`);
----

==== Transferência de Saldo

[source,typescript]
----
interface Account {
  balance: number;
}

async function transfer(
  fromId: string,
  toId: string,
  amount: number
): Promise<boolean> {
  const fromKey = ["accounts", fromId];
  const toKey = ["accounts", toId];

  while (true) {
    // Ler ambas as contas
    const [from, to] = await kv.getMany<Account>([fromKey, toKey]);

    if (!from.value || !to.value) {
      throw new Error("Conta não encontrada");
    }

    if (from.value.balance < amount) {
      throw new Error("Saldo insuficiente");
    }

    // Transferir atomicamente
    const result = await kv.atomic()
      .check({ key: fromKey, versionstamp: from.versionstamp })
      .check({ key: toKey, versionstamp: to.versionstamp })
      .set(fromKey, { balance: from.value.balance - amount })
      .set(toKey, { balance: to.value.balance + amount })
      .commit();

    if (result.ok) {
      return true;
    }

    // Conflito - tentar novamente
  }
}
----

==== Create If Not Exists

[source,typescript]
----
async function createUser(email: string, data: object): Promise<{ created: boolean; user: object }> {
  const key = ["users", email];

  // Verificar se existe
  const existing = await kv.get(key);
  if (existing.value) {
    return { created: false, user: existing.value };
  }

  // Criar atomicamente
  const result = await kv.atomic()
    .check({ key, versionstamp: null }) // Garantir que ainda não existe
    .set(key, data)
    .commit();

  if (result.ok) {
    return { created: true, user: data };
  }

  // Race condition - outro processo criou primeiro
  const user = await kv.get(key);
  return { created: false, user: user.value };
}
----

==== Update with Retry

[source,typescript]
----
async function updateWithRetry<T>(
  key: KvKey,
  updater: (current: T | null) => T,
  maxRetries = 5
): Promise<T> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const entry = await kv.get<T>(key);
    const newValue = updater(entry.value);

    const result = await kv.atomic()
      .check({ key, versionstamp: entry.versionstamp })
      .set(key, newValue)
      .commit();

    if (result.ok) {
      return newValue;
    }

    // Backoff exponencial
    await new Promise(r => setTimeout(r, Math.pow(2, attempt) * 10));
  }

  throw new Error(`Failed after ${maxRetries} retries`);
}

// Uso
const user = await updateWithRetry(
  ["users", 123],
  (current) => ({
    ...current,
    loginCount: (current?.loginCount ?? 0) + 1,
    lastLogin: new Date().toISOString(),
  })
);
----

==== Batch Delete

[source,typescript]
----
async function batchDelete(keys: KvKey[]): Promise<void> {
  let atomic = kv.atomic();

  for (const key of keys) {
    atomic = atomic.delete(key);
  }

  await atomic.commit();
}

// Uso
await batchDelete([
  ["temp", "file1"],
  ["temp", "file2"],
  ["temp", "file3"],
]);
----

==== Move (Delete + Create)

[source,typescript]
----
async function moveEntry(fromKey: KvKey, toKey: KvKey): Promise<boolean> {
  const entry = await kv.get(fromKey);
  if (!entry.value) {
    return false;
  }

  const result = await kv.atomic()
    .check({ key: fromKey, versionstamp: entry.versionstamp })
    .check({ key: toKey, versionstamp: null }) // Destino não existe
    .delete(fromKey)
    .set(toKey, entry.value)
    .commit();

  return result.ok;
}
----

=== Limitações

==== Tamanho da Transação

Não há limite explícito, mas transações muito grandes podem:

* Aumentar latência
* Maior chance de conflito
* Consumir mais memória

**Recomendação**: Mantenha transações com menos de 100 operações.

==== Sem Read-Your-Writes

Dentro de uma transação, você **não pode** ler valores que acabou de escrever:

[source,typescript]
----
// ❌ Isso NÃO funciona como esperado
const atomic = kv.atomic()
  .set(["a"], 1)
  .set(["b"], /* valor de ["a"] + 1 */); // Não tem acesso a ["a"]

// ✅ Calcule antes
const valueA = 1;
const valueB = valueA + 1;

await kv.atomic()
  .set(["a"], valueA)
  .set(["b"], valueB)
  .commit();
----

==== Conflitos Frequentes

Em cenários de alta concorrência:

[source,typescript]
----
// ⚠️ Hot key - muitos conflitos
await atomicIncrement("global-counter");

// ✅ Sharding para reduzir conflitos
const shard = Math.floor(Math.random() * 10);
await atomicIncrement(`counter-shard-${shard}`);

// Ler total
let total = 0;
for (let i = 0; i < 10; i++) {
  const entry = await kv.get<number>(["counters", `counter-shard-${i}`]);
  total += entry.value ?? 0;
}
----

=== Boas Práticas

==== Minimize o Escopo da Transação

[source,typescript]
----
// ❌ Ruim: operações desnecessárias na transação
const result = await kv.atomic()
  .set(["users", 123], userData)
  .set(["logs", Date.now()], logEntry) // Log não precisa ser atômico
  .commit();

// ✅ Bom: apenas o essencial
await kv.atomic()
  .set(["users", 123], userData)
  .commit();

await kv.set(["logs", Date.now()], logEntry); // Separado
----

==== Use Backoff em Retries

[source,typescript]
----
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await new Promise(r => setTimeout(r, Math.pow(2, i) * 100));
    }
  }
  throw new Error("Unreachable");
}
----

==== Documente Invariantes

[source,typescript]
----
/**
 * Cria um pedido atomicamente.
 *
 * Invariantes garantidos:
 * - Pedido só é criado se produto existe
 * - Estoque é decrementado junto com criação do pedido
 * - ID do pedido é único
 */
async function createOrder(productId: string, quantity: number) {
  // ... implementação
}
----

=== Commit Versionstamp

O método `commitVersionstamp()` retorna um **placeholder** que será resolvido para o versionstamp real no momento do commit. Isso permite criar referências cruzadas consistentes.

==== Quando Usar

* Índices secundários ordenados por tempo de criação
* Audit logs com timestamp garantidamente único
* Event sourcing com ordenação global

==== API

[source,typescript]
----
const vs = kv.commitVersionstamp();

await kv.atomic()
  .set(["posts", postId], post)
  .set(["posts_by_time", vs, postId], postId) // vs será o versionstamp do commit
  .commit();
----

==== Exemplos

===== Índice por Tempo de Criação

[source,typescript]
----
interface Post {
  title: string;
  content: string;
  authorId: string;
}

async function createPost(post: Post): Promise<string> {
  const postId = crypto.randomUUID();
  const vs = kv.commitVersionstamp();

  await kv.atomic()
    // Dados do post
    .set(["posts", postId], post)
    // Índice ordenado por tempo de criação
    .set(["posts_by_time", vs, postId], postId)
    // Índice por autor, também ordenado por tempo
    .set(["posts_by_author", post.authorId, vs, postId], postId)
    .commit();

  return postId;
}

// Listar posts em ordem cronológica
async function* getRecentPosts(limit = 10): AsyncIterableIterator<Post> {
  for await (const entry of kv.list<string>({
    prefix: ["posts_by_time"],
    limit,
    reverse: true, // Mais recentes primeiro
  })) {
    const postId = entry.value;
    const post = await kv.get<Post>(["posts", postId]);
    if (post.value) yield post.value;
  }
}
----

===== Audit Log

[source,typescript]
----
interface AuditEntry {
  action: string;
  entityId: string;
  entityType: string;
  metadata: Record<string, unknown>;
  timestamp: number;
  userId: string;
}

async function auditedUpdate<T>(
  key: KvKey,
  newValue: T,
  userId: string
): Promise<void> {
  const vs = kv.commitVersionstamp();
  const entry = await kv.get<T>(key);

  await kv.atomic()
    .check({ key, versionstamp: entry.versionstamp })
    .set(key, newValue)
    .set(["audit_log", vs], {
      action: entry.value ? "update" : "create",
      entityType: key[0],
      entityId: String(key[1]),
      userId,
      timestamp: Date.now(),
      metadata: { before: entry.value, after: newValue },
    } satisfies AuditEntry)
    .commit();
}

// Listar audit log em ordem
for await (const entry of kv.list<AuditEntry>({ prefix: ["audit_log"] })) {
  console.log(entry.key[1], entry.value.action, entry.value.entityType);
}
----

===== Event Sourcing

[source,typescript]
----
interface Event {
  aggregateId: string;
  payload: unknown;
  timestamp: number;
  type: string;
}

async function appendEvent(aggregateId: string, type: string, payload: unknown): Promise<void> {
  const vs = kv.commitVersionstamp();

  await kv.atomic()
    // Evento global (ordenação total)
    .set(["events", vs], {
      type,
      aggregateId,
      payload,
      timestamp: Date.now(),
    } satisfies Event)
    // Evento por aggregate (ordenação por entidade)
    .set(["events_by_aggregate", aggregateId, vs], { type, payload })
    .commit();
}

// Reconstruir estado de um aggregate
async function getAggregateEvents(aggregateId: string): Promise<Event[]> {
  const events: Event[] = [];
  for await (const entry of kv.list<Event>({
    prefix: ["events_by_aggregate", aggregateId],
  })) {
    events.push(entry.value);
  }
  return events;
}
----

==== Por que Não Usar Date.now()?

O `commitVersionstamp()` oferece vantagens sobre `Date.now()`:

[cols="1,1,1"]
|===
| Aspecto | Date.now() | commitVersionstamp()

| Unicidade
| Pode colidir (mesmo ms)
| Sempre único

| Ordenação
| Aproximada
| Global e determinística

| Consistência
| Pode divergir entre operações
| Mesmo valor para todo o commit

| Concorrência
| Race conditions
| Sem race conditions
|===

[source,typescript]
----
// ❌ Problema com Date.now()
const timestamp = Date.now();
await kv.atomic()
  .set(["posts", postId], post)
  .set(["posts_by_time", timestamp, postId], postId) // Pode colidir!
  .commit();

// ✅ Correto com commitVersionstamp()
const vs = kv.commitVersionstamp();
await kv.atomic()
  .set(["posts", postId], post)
  .set(["posts_by_time", vs, postId], postId) // Sempre único
  .commit();
----

==== Limitações

* **Apenas em atomic()**: O placeholder só pode ser usado dentro de transações atômicas
* **Apenas em chaves**: Não pode ser usado como valor
* **Resolução no servidor**: O plugin resolve o placeholder; o client não conhece o valor até o commit retornar
