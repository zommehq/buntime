== Expiração de Chaves

=== Visão Geral

O KeyVal suporta **TTL (Time-To-Live)** nativo, permitindo que entradas expirem automaticamente após um período especificado. Isso é útil para:

* Sessões de usuário
* Cache temporário
* Tokens de autenticação
* Rate limiting
* Dados temporários

=== Definindo Expiração

==== Sintaxe Básica

[source,typescript]
----
await kv.set(key, value, { expireIn: milliseconds });
----

O parâmetro `expireIn` especifica o tempo de vida em **milissegundos** a partir do momento do `set`.

==== Exemplos

[source,typescript]
----
// Expirar em 1 hora
await kv.set(["sessions", sessionId], sessionData, {
  expireIn: 60 * 60 * 1000, // 1 hora = 3.600.000 ms
});

// Expirar em 24 horas
await kv.set(["tokens", token], tokenData, {
  expireIn: 24 * 60 * 60 * 1000, // 24 horas
});

// Expirar em 5 minutos
await kv.set(["cache", cacheKey], cachedData, {
  expireIn: 5 * 60 * 1000, // 5 minutos
});

// Expirar em 30 segundos
await kv.set(["otp", phone], otpCode, {
  expireIn: 30 * 1000, // 30 segundos
});
----

=== Comportamento de Expiração

==== Leitura de Entradas Expiradas

Entradas expiradas **não são retornadas** em operações `get` ou `list`:

[source,typescript]
----
// Definir com expiração de 1 segundo
await kv.set(["temp", "key"], "value", { expireIn: 1000 });

// Leitura imediata - funciona
const entry1 = await kv.get(["temp", "key"]);
console.log(entry1.value); // "value"

// Esperar 2 segundos
await new Promise(resolve => setTimeout(resolve, 2000));

// Leitura após expiração - retorna null
const entry2 = await kv.get(["temp", "key"]);
console.log(entry2.value); // null
console.log(entry2.versionstamp); // null
----

==== Limpeza Automática

O KeyVal executa limpeza periódica de entradas expiradas:

* **Intervalo**: A cada 60 segundos
* **Processo**: Remove fisicamente entradas com `expires_at <= now`
* **Impacto**: Mínimo, executado em background

[NOTE]
====
Mesmo antes da limpeza física, entradas expiradas não são visíveis nas operações de leitura. A limpeza apenas libera espaço de armazenamento.
====

=== Casos de Uso

==== Sessões de Usuário

[source,typescript]
----
const SESSION_TTL = 7 * 24 * 60 * 60 * 1000; // 7 dias

async function createSession(userId: string): Promise<string> {
  const sessionId = crypto.randomUUID();

  await kv.set(
    ["sessions", sessionId],
    {
      userId,
      createdAt: new Date().toISOString(),
      lastActivity: new Date().toISOString(),
    },
    { expireIn: SESSION_TTL }
  );

  return sessionId;
}

async function getSession(sessionId: string) {
  const entry = await kv.get(["sessions", sessionId]);
  return entry.value; // null se expirou
}

async function refreshSession(sessionId: string) {
  const entry = await kv.get(["sessions", sessionId]);
  if (!entry.value) return false;

  // Renovar sessão com novo TTL
  await kv.set(
    ["sessions", sessionId],
    {
      ...entry.value,
      lastActivity: new Date().toISOString(),
    },
    { expireIn: SESSION_TTL }
  );

  return true;
}
----

==== Cache com TTL

[source,typescript]
----
const CACHE_TTL = 5 * 60 * 1000; // 5 minutos

async function getCached<T>(
  key: string,
  fetcher: () => Promise<T>,
  ttl = CACHE_TTL
): Promise<T> {
  const cacheKey = ["cache", key];
  const cached = await kv.get<T>(cacheKey);

  if (cached.value !== null) {
    return cached.value;
  }

  const freshData = await fetcher();
  await kv.set(cacheKey, freshData, { expireIn: ttl });

  return freshData;
}

// Uso
const users = await getCached("all-users", async () => {
  return await db.query("SELECT * FROM users");
});
----

==== Rate Limiting

[source,typescript]
----
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minuto
const MAX_REQUESTS = 100;

async function checkRateLimit(clientId: string): Promise<boolean> {
  const key = ["ratelimit", clientId];
  const entry = await kv.get<number>(key);

  const currentCount = entry.value ?? 0;

  if (currentCount >= MAX_REQUESTS) {
    return false; // Limite excedido
  }

  // Incrementar contador
  // Se é primeira requisição, definir TTL
  // Se já existe, manter o TTL original (não renovar)
  if (entry.value === null) {
    await kv.set(key, 1, { expireIn: RATE_LIMIT_WINDOW });
  } else {
    // Aqui idealmente usaríamos atomic para evitar race conditions
    await kv.set(key, currentCount + 1, { expireIn: RATE_LIMIT_WINDOW });
  }

  return true;
}
----

==== Códigos OTP

[source,typescript]
----
const OTP_TTL = 5 * 60 * 1000; // 5 minutos

function generateOTP(): string {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

async function sendOTP(phone: string): Promise<void> {
  const otp = generateOTP();

  await kv.set(["otp", phone], { code: otp, attempts: 0 }, { expireIn: OTP_TTL });

  // Enviar SMS com o código
  await sendSMS(phone, `Seu código é: ${otp}`);
}

async function verifyOTP(phone: string, code: string): Promise<boolean> {
  const key = ["otp", phone];
  const entry = await kv.get<{ code: string; attempts: number }>(key);

  if (!entry.value) {
    return false; // Expirado ou não existe
  }

  if (entry.value.attempts >= 3) {
    await kv.delete(key); // Muitas tentativas
    return false;
  }

  if (entry.value.code !== code) {
    // Incrementar tentativas
    await kv.set(key, { ...entry.value, attempts: entry.value.attempts + 1 }, { expireIn: OTP_TTL });
    return false;
  }

  // Sucesso - remover OTP
  await kv.delete(key);
  return true;
}
----

==== Locks Temporários

[source,typescript]
----
const LOCK_TTL = 30 * 1000; // 30 segundos

async function acquireLock(resource: string): Promise<string | null> {
  const lockId = crypto.randomUUID();
  const key = ["locks", resource];

  // Verificar se já existe lock
  const existing = await kv.get(key);
  if (existing.value !== null) {
    return null; // Recurso já bloqueado
  }

  // Criar lock com TTL (auto-release)
  await kv.set(key, { lockId, acquiredAt: Date.now() }, { expireIn: LOCK_TTL });

  return lockId;
}

async function releaseLock(resource: string, lockId: string): Promise<boolean> {
  const key = ["locks", resource];
  const entry = await kv.get<{ lockId: string }>(key);

  if (!entry.value || entry.value.lockId !== lockId) {
    return false; // Lock não pertence a este processo
  }

  await kv.delete(key);
  return true;
}

// Uso
const lockId = await acquireLock("critical-section");
if (lockId) {
  try {
    // Executar operação crítica
    await performCriticalOperation();
  } finally {
    await releaseLock("critical-section", lockId);
  }
}
----

=== Considerações

==== Precisão do TTL

* O TTL é calculado no momento do `set`
* A expiração tem precisão de **segundos** (não milissegundos)
* Entradas podem persistir até ~1 minuto após expiração (até próxima limpeza)

==== Renovação de TTL

Para renovar o TTL, faça um novo `set` com o mesmo valor:

[source,typescript]
----
async function renewTTL(key: KvKey, newTTL: number): Promise<boolean> {
  const entry = await kv.get(key);
  if (entry.value === null) {
    return false; // Já expirou
  }

  await kv.set(key, entry.value, { expireIn: newTTL });
  return true;
}
----

==== Sem Expiração

Para remover a expiração de uma entrada, faça `set` sem o parâmetro `expireIn`:

[source,typescript]
----
// Tornar permanente
const entry = await kv.get(["temp", "key"]);
if (entry.value) {
  await kv.set(["temp", "key"], entry.value); // Sem expireIn
}
----

=== Monitoramento

==== Verificar se Entrada Está Próxima de Expirar

[source,typescript]
----
// O KeyVal não expõe o expires_at diretamente
// Para isso, inclua a informação no valor:

interface CacheEntry<T> {
  data: T;
  expiresAt: number;
}

async function setWithMeta<T>(key: KvKey, data: T, ttl: number) {
  const entry: CacheEntry<T> = {
    data,
    expiresAt: Date.now() + ttl,
  };
  await kv.set(key, entry, { expireIn: ttl });
}

async function getWithMeta<T>(key: KvKey): Promise<{ data: T; remainingTTL: number } | null> {
  const entry = await kv.get<CacheEntry<T>>(key);
  if (!entry.value) return null;

  return {
    data: entry.value.data,
    remainingTTL: entry.value.expiresAt - Date.now(),
  };
}
----
