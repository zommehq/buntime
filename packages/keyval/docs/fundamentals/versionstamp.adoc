== Versionstamp: Controle de Concorrência

O **versionstamp** é um identificador único que garante a integridade de operações concorrentes em sistemas distribuídos, prevenindo race conditions e lost updates.

=== Race Conditions

Em operações concorrentes, múltiplas modificações podem ocorrer simultaneamente:

[source]
----
Tempo    Processo A                   Processo B
─────────────────────────────────────────────────────
  1      Lê documento (v1)
  2                                   Lê documento (v1)
  3      Modifica conteúdo
  4      Salva documento
  5                                   Modifica conteúdo
  6                                   Salva documento

Resultado: Modificação de A foi perdida (Lost Update)
----

Este padrão de **lost update** ocorre quando a última escrita sobrescreve alterações anteriores sem detectar o conflito.

=== Funcionamento

Toda entrada no KeyVal tem um **versionstamp** que muda a cada modificação:

[source,typescript]
----
const entry = await kv.get(["documents", docId]);

console.log(entry.key);          // ["documents", "doc_001"]
console.log(entry.value);        // { title: "Meu Doc", content: "..." }
console.log(entry.versionstamp); // "00000000000000010042"
----

O versionstamp é:

* **Único**: Cada versão tem um versionstamp diferente
* **Ordenável**: Versionstamps mais recentes são "maiores"
* **Opaco**: Você não precisa entender o formato, apenas comparar

=== Optimistic Locking

O padrão de uso consiste em:

1. **Leitura**: Obtém o dado e seu versionstamp atual
2. **Modificação**: Processa a alteração
3. **Escrita**: Salva apenas se o versionstamp não mudou

Se houver modificação concorrente entre os passos 1 e 3, a operação falha.

==== Exemplo: Atualização Segura

[source,typescript]
----
// ERRADO - Pode perder atualizações
const entry = await kv.get<User>(["users", oderId]);
await kv.set(["users", oderId], {
  ...entry.value,
  name: "Novo Nome"
});
// Se alguém modificou entre get e set, perdemos essa modificação!

// CORRETO - Usa check para verificar versionstamp
const entry = await kv.get<User>(["users", oderId]);
const result = await kv.atomic()
  .check(entry)  // Verifica se versionstamp ainda é o mesmo
  .set(["users", oderId], {
    ...entry.value,
    name: "Novo Nome"
  })
  .commit();

if (!result.ok) {
  // Modificação concorrente detectada
  console.log("Conflito detectado");
}
----

==== O que `check()` faz?

O método `check()` recebe uma entrada (ou um objeto com `key` e `versionstamp`) e verifica se o dado no banco ainda tem o mesmo versionstamp:

[source,typescript]
----
// Forma 1: Passa a entrada completa
const entry = await kv.get(["users", oderId]);
await kv.atomic()
  .check(entry)
  .set(["users", oderId], newValue)
  .commit();

// Forma 2: Passa key + versionstamp
await kv.atomic()
  .check({ key: ["users", oderId], versionstamp: "00000000000000010042" })
  .set(["users", oderId], newValue)
  .commit();

// Forma 3: Verifica que NÃO existe (versionstamp null)
await kv.atomic()
  .check({ key: ["users", oderId], versionstamp: null })
  .set(["users", oderId], newValue)
  .commit();
// Falha se a chave já existir
----

=== Quando Usar

==== Use versionstamp quando

* **Atualizando dados existentes**: Evita lost updates
* **Criando com unicidade**: Garante que não existe antes de criar
* **Operações read-modify-write**: Qualquer leitura seguida de escrita

==== Não precisa de versionstamp quando

* **Operações idempotentes**: Resultado é o mesmo independente de quantas vezes executa
* **Sobrescrita intencional**: Você quer que a última escrita ganhe
* **Contadores atômicos**: Use `sum()`, `max()`, `min()` em vez de read-modify-write

=== Unicidade na Criação

Para garantir que um registro não existe antes da criação:

[source,typescript]
----
async function createUser(user: User): Promise<string> {
  const id = crypto.randomUUID();

  // Verifica que email não existe
  const existingEmail = await kv.get(["users_by_email", user.email]);
  if (existingEmail.value) {
    throw new Error("Email já cadastrado");
  }

  // Cria atomicamente, verificando que:
  // 1. O email ainda não existe (race condition protection)
  // 2. O ID não existe (improvável com UUID, mas seguro)
  const result = await kv.atomic()
    .check({ key: ["users_by_email", user.email], versionstamp: null })
    .check({ key: ["users", id], versionstamp: null })
    .set(["users", id], { ...user, id })
    .set(["users_by_email", user.email], id)
    .commit();

  if (!result.ok) {
    throw new Error("Email já cadastrado (conflito)");
  }

  return id;
}
----

=== Retry Automático com `transaction()`

O método `transaction()` implementa retry automático em caso de conflito:

[source,typescript]
----
// transaction() faz o check automaticamente e retry se houver conflito
const result = await kv.transaction(async (tx) => {
  const user = await tx.get<User>(["users", oderId]);

  if (!user.value) {
    throw new Error("Usuário não encontrado");
  }

  // Modifica
  tx.set(["users", oderId], {
    ...user.value,
    loginCount: user.value.loginCount + 1,
    lastLogin: Date.now()
  });

  return user.value.loginCount + 1;
}, { maxRetries: 5 });

if (result.ok) {
  console.log("Novo login count:", result.value);
} else {
  console.log("Falhou após 5 tentativas");
}
----

A diferença entre `atomic()` e `transaction()`:

[cols="1,1,1"]
|===
| Aspecto | atomic() | transaction()

| Check
| Manual (você chama `.check()`)
| Automático (todas as leituras são verificadas)

| Retry
| Manual (você implementa o loop)
| Automático (configurável com `maxRetries`)

| Leituras
| Fora do atomic
| Dentro do callback, cacheadas

| Uso típico
| Operações simples, controle total
| Read-modify-write complexo
|===

=== commitVersionstamp: Referências Consistentes

Para criar referências entre entradas na mesma operação, o versionstamp não é conhecido até o commit.

[source,typescript]
----
// Problema: indexar posts por data usando timestamp do cliente
const postId = crypto.randomUUID();
const timestamp = Date.now(); // Timestamp do cliente, sujeito a dessincronia

await kv.atomic()
  .set(["posts", postId], { title: "Hello" })
  .set(["posts_by_date", timestamp, postId], postId)
  .commit();
// Timestamp pode não refletir a ordem real de commit
----

Solução com `kv.commitVersionstamp()`:

[source,typescript]
----
const postId = crypto.randomUUID();
const vs = kv.commitVersionstamp(); // Placeholder que será substituído

await kv.atomic()
  .set(["posts", postId], { title: "Hello" })
  .set(["posts_by_date", vs, postId], postId)  // vs será o versionstamp real
  .commit();

// Resultado: ["posts_by_date", "00000000000000010042", "post_123"]
// O versionstamp é garantidamente o mesmo do commit
----

Isso garante que:

* O timestamp é do servidor, não do cliente
* A ordem dos posts reflete a ordem real de criação
* Não há race conditions no timestamp

=== Versionstamp vs Timestamp

[cols="1,1,1"]
|===
| Aspecto | Versionstamp | Timestamp (Date.now())

| Gerado por
| Servidor (no commit)
| Cliente

| Precisão
| Global, único por transação
| Pode colidir, depende do relógio

| Uso
| Controle de concorrência
| Dados de negócio (createdAt, updatedAt)

| Comparável
| Sim, ordem total
| Sim, mas relógios podem divergir
|===

Use versionstamp para ordenação de sistema e controle de concorrência.
Use timestamp para dados de negócio visíveis ao usuário.
