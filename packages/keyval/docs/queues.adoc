== Filas de Mensagens

=== Visão Geral

O KeyVal suporta **filas de mensagens** com API compatível com Deno KV. Isso permite processar tarefas de forma assíncrona com:

* Entrega garantida (at-least-once)
* Retentativas automáticas com backoff exponencial
* Fallback para chaves KV se todas as tentativas falharem
* Delay para agendamento de tarefas futuras

=== API Básica

==== Enfileirar Mensagem

[source,typescript]
----
await kv.enqueue(value, options?);
----

**Parâmetros:**

[cols="1,1,3"]
|===
| Parâmetro | Tipo | Descrição

| `value`
| `unknown`
| O valor a ser enfileirado (será serializado como JSON)

| `options.delay`
| `number`
| Delay em ms antes da mensagem ficar disponível

| `options.backoffSchedule`
| `number[]`
| Intervalos de retry em ms (default: `[1000, 5000, 10000]`)

| `options.keysIfUndelivered`
| `KvKey[]`
| Chaves onde salvar o valor se falhar após todos os retries
|===

==== Escutar Mensagens

[source,typescript]
----
const handle = kv.listenQueue(handler, options?);

// Parar de escutar manualmente
handle.stop();

// Ou usar `using` para cleanup automático (TS 5.2+)
{
  using listener = kv.listenQueue(handler);
  await waitForShutdown();
} // listener.stop() chamado automaticamente
----

**Parâmetros:**

[cols="1,1,3"]
|===
| Parâmetro | Tipo | Descrição

| `handler`
| `(value: T) => Promise<void> \| void`
| Função que processa cada mensagem

| `options.mode`
| `"sse" \| "polling"`
| Modo de conexão (default: `"sse"`)

| `options.pollInterval`
| `number`
| Intervalo de polling em ms (default: `1000`)
|===

=== Exemplos

==== Envio de Email Assíncrono

[source,typescript]
----
interface EmailJob {
  body: string;
  subject: string;
  to: string;
}

// Producer: enfileirar emails
async function sendEmail(email: EmailJob): Promise<void> {
  await kv.enqueue(email, {
    // Se falhar, salvar em dead-letter queue
    keysIfUndelivered: [["failed_emails", crypto.randomUUID()]],
  });
}

// Consumer: processar emails
kv.listenQueue<EmailJob>(async (email) => {
  await mailService.send({
    to: email.to,
    subject: email.subject,
    body: email.body,
  });
  console.log(`Email enviado para ${email.to}`);
});
----

==== Tarefas Agendadas

[source,typescript]
----
interface ScheduledTask {
  action: string;
  params: Record<string, unknown>;
}

// Agendar tarefa para 5 minutos no futuro
await kv.enqueue<ScheduledTask>(
  { action: "cleanup", params: { olderThan: "7d" } },
  { delay: 5 * 60 * 1000 } // 5 minutos
);

// Processar tarefas agendadas
kv.listenQueue<ScheduledTask>(async (task) => {
  switch (task.action) {
    case "cleanup":
      await runCleanup(task.params);
      break;
    case "backup":
      await runBackup(task.params);
      break;
  }
});
----

==== Retry com Backoff Customizado

[source,typescript]
----
interface WebhookPayload {
  event: string;
  data: unknown;
  url: string;
}

// Backoff agressivo para webhooks
await kv.enqueue<WebhookPayload>(
  {
    event: "order.created",
    data: { orderId: 123 },
    url: "https://api.example.com/webhook",
  },
  {
    // 1s, 10s, 30s, 1min, 5min
    backoffSchedule: [1000, 10000, 30000, 60000, 300000],
    // Salvar para reprocessamento manual se falhar
    keysIfUndelivered: [["webhook_failures", crypto.randomUUID()]],
  }
);

// Processar webhooks
kv.listenQueue<WebhookPayload>(async (payload) => {
  const response = await fetch(payload.url, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      event: payload.event,
      data: payload.data,
    }),
  });

  if (!response.ok) {
    throw new Error(`Webhook failed: ${response.status}`);
  }
});
----

==== Processamento em Lote

[source,typescript]
----
interface BatchItem {
  batchId: string;
  index: number;
  data: unknown;
}

// Enfileirar itens de um lote
async function processBatch(items: unknown[]): Promise<string> {
  const batchId = crypto.randomUUID();

  for (let i = 0; i < items.length; i++) {
    await kv.enqueue<BatchItem>({
      batchId,
      index: i,
      data: items[i],
    });
  }

  return batchId;
}

// Consumer com rastreamento
kv.listenQueue<BatchItem>(async (item) => {
  console.log(`Processing batch ${item.batchId}, item ${item.index}`);
  await processItem(item.data);

  // Atualizar progresso no KV
  const progressKey = ["batch_progress", item.batchId];
  const entry = await kv.get<number>(progressKey);
  await kv.set(progressKey, (entry.value ?? 0) + 1);
});
----

=== Modos de Conexão

==== SSE (Server-Sent Events)

**Vantagens:**
- Baixa latência (~100ms)
- Conexão persistente
- Reconexão automática

**Quando usar:**
- Conexão direta com o servidor
- Processamento em tempo real
- Ambiente controlado

[source,typescript]
----
// SSE é o padrão
kv.listenQueue(handler);

// Explicitamente SSE
kv.listenQueue(handler, { mode: "sse" });
----

==== Polling

**Vantagens:**
- Compatível com proxies/load balancers
- Funciona através de CDNs
- Mais resiliente a firewalls

**Quando usar:**
- Ambiente com proxies restritivos
- Conexões intermitentes
- Debug e desenvolvimento

[source,typescript]
----
// Polling com intervalo padrão (1s)
kv.listenQueue(handler, { mode: "polling" });

// Polling com intervalo customizado
kv.listenQueue(handler, { mode: "polling", pollInterval: 2000 });
----

=== Garantias de Entrega

==== At-Least-Once

O KeyVal garante que cada mensagem será processada **pelo menos uma vez**:

1. Mensagem é bloqueada quando dequeued (locked)
2. Handler processa a mensagem
3. Se sucesso: ACK remove a mensagem
4. Se falha: NACK agenda retry
5. Se timeout: mensagem é desbloqueada automaticamente

[IMPORTANT]
====
Handlers devem ser **idempotentes** pois a mensagem pode ser processada mais de uma vez em caso de falhas de rede.
====

==== Timeout de Lock

Mensagens têm lock de 30 segundos. Se o handler não responder nesse tempo:

1. Mensagem é considerada falha
2. Retry é agendado segundo backoff schedule
3. Lock é liberado para outro consumer

[source,typescript]
----
// ⚠️ Handler deve completar em < 30s
kv.listenQueue(async (msg) => {
  // Operação deve ser rápida
  await quickOperation(msg);
});

// Para operações longas, quebre em sub-tarefas
kv.listenQueue<LongTask>(async (task) => {
  // Inicia operação longa em background
  await startLongOperation(task);

  // Enfileira verificação de status
  await kv.enqueue({ type: "check_status", taskId: task.id }, { delay: 5000 });
});
----

=== Dead Letter Queue

Quando todas as tentativas falham, `keysIfUndelivered` salva a mensagem:

[source,typescript]
----
await kv.enqueue(data, {
  backoffSchedule: [1000, 5000, 10000], // 3 retries
  keysIfUndelivered: [["dlq", "emails", crypto.randomUUID()]],
});

// Listar mensagens falhadas
for await (const entry of kv.list({ prefix: ["dlq", "emails"] })) {
  console.log("Failed email:", entry.value);
}

// Reprocessar manualmente
async function reprocessDLQ(): Promise<void> {
  for await (const entry of kv.list({ prefix: ["dlq", "emails"] })) {
    await kv.enqueue(entry.value);
    await kv.delete(entry.key);
  }
}
----

=== Monitoramento

==== Estatísticas da Fila

[source,typescript]
----
const stats = await fetch(`${baseUrl}/queue/stats`).then(r => r.json());

console.log(stats);
// {
//   pending: 42,
//   processing: 3,
//   failed: 1,
//   total: 46
// }
----

==== Logs de Processamento

[source,typescript]
----
kv.listenQueue(async (msg) => {
  const startTime = Date.now();

  try {
    await processMessage(msg);

    console.log({
      type: "queue.processed",
      duration: Date.now() - startTime,
      messageType: msg.type,
    });
  } catch (error) {
    console.error({
      type: "queue.failed",
      duration: Date.now() - startTime,
      error: error.message,
    });
    throw error; // Re-throw para trigger NACK
  }
});
----

=== Boas Práticas

==== Cleanup com `using` (TS 5.2+)

O handle implementa `Symbol.dispose`, permitindo cleanup automático:

[source,typescript]
----
// Cleanup automático quando o bloco termina
async function runWorker(): Promise<void> {
  using listener = kv.listenQueue<EmailJob>(async (email) => {
    await mailService.send(email);
  });

  // Aguarda sinal de shutdown
  await waitForShutdown();
} // listener.stop() chamado automaticamente

// Útil para testes
async function testQueueProcessing(): Promise<void> {
  using listener = kv.listenQueue<TestJob>(async (job) => {
    results.push(await processJob(job));
  });

  // Enfileira jobs de teste
  await kv.enqueue({ type: "test", data: 1 });
  await kv.enqueue({ type: "test", data: 2 });

  // Aguarda processamento
  await new Promise(r => setTimeout(r, 1000));
} // Listener parado automaticamente

// Múltiplos consumers
async function runMultipleWorkers(): Promise<void> {
  using emailListener = kv.listenQueue<EmailJob>(handleEmail);
  using webhookListener = kv.listenQueue<WebhookJob>(handleWebhook);
  using notificationListener = kv.listenQueue<NotificationJob>(handleNotification);

  await waitForShutdown();
} // Todos os listeners parados automaticamente
----

==== Handlers Idempotentes

[source,typescript]
----
// ❌ Ruim: não idempotente
kv.listenQueue(async (order) => {
  await chargeCard(order.cardToken, order.amount);
});

// ✅ Bom: verifica se já processou
kv.listenQueue(async (order) => {
  const existing = await kv.get(["processed_orders", order.id]);
  if (existing.value) return; // Já processou

  await chargeCard(order.cardToken, order.amount);
  await kv.set(["processed_orders", order.id], { processedAt: Date.now() });
});
----

==== Separe Producers de Consumers

[source,typescript]
----
// producer.ts - Apenas enfileira
export async function scheduleNotification(userId: string, message: string) {
  await kv.enqueue({ type: "notification", userId, message });
}

// consumer.ts - Apenas processa
export function startNotificationWorker() {
  kv.listenQueue(async (job) => {
    if (job.type === "notification") {
      await sendPushNotification(job.userId, job.message);
    }
  });
}
----

==== Limite Concorrência

[source,typescript]
----
// Limitar processamento paralelo
let activeJobs = 0;
const MAX_CONCURRENT = 5;

kv.listenQueue(async (msg) => {
  while (activeJobs >= MAX_CONCURRENT) {
    await new Promise(r => setTimeout(r, 100));
  }

  activeJobs++;
  try {
    await processMessage(msg);
  } finally {
    activeJobs--;
  }
});
----

=== Limitações

==== Mensagens Grandes

Valores são serializados como JSON. Para dados grandes:

[source,typescript]
----
// ❌ Evite: payload grande
await kv.enqueue({ data: hugeArray });

// ✅ Prefira: referência para dados externos
await kv.enqueue({ fileId: "abc123", bucket: "uploads" });
----

==== Ordenação

Mensagens são processadas por **ordem de ready_at**, não por ordem de enqueue:

[source,typescript]
----
// Ordem de processamento pode variar
await kv.enqueue({ seq: 1 });
await kv.enqueue({ seq: 2 });
await kv.enqueue({ seq: 3 });

// Se precisar de ordem, use delay incremental
await kv.enqueue({ seq: 1 }, { delay: 0 });
await kv.enqueue({ seq: 2 }, { delay: 100 });
await kv.enqueue({ seq: 3 }, { delay: 200 });
----

==== Múltiplos Consumers

Com múltiplos consumers, cada mensagem vai para apenas **um** consumer:

[source,typescript]
----
// Worker 1
kv.listenQueue(handler); // Recebe algumas mensagens

// Worker 2
kv.listenQueue(handler); // Recebe outras mensagens

// Total = todas as mensagens processadas uma vez
----
