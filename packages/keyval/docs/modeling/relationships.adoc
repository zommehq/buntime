== Relacionamentos

Em bancos relacionais, relacionamentos são definidos com `FOREIGN KEY` e combinados via `JOIN`. No KeyVal, relacionamentos são modelados através da **estrutura das chaves** e **referências explícitas**.

=== Comparação com SQL

==== SQL: Tabelas Separadas, JOIN para Combinar

[source,sql]
----
-- Duas tabelas separadas
CREATE TABLE users (id, name, email);
CREATE TABLE posts (id, user_id, title, content);

-- JOIN para combinar
SELECT u.name, p.title
FROM posts p
JOIN users u ON p.user_id = u.id
WHERE u.id = 1;
----

==== KeyVal: Duas Estratégias

No KeyVal, você escolhe entre duas abordagens:

1. **Hierarquia na chave** - dados do filho "dentro" do pai
2. **Referência explícita** - IDs apontando para outras entidades

[source,typescript]
----
// Estratégia 1: Hierárquica (posts dentro de users)
["users", userId] → { name, email }
["users", userId, "posts", postId] → { title, content }

// Estratégia 2: Referência (posts separados)
["users", userId] → { name, email }
["posts", postId] → { title, content, authorId: userId }
----

A escolha impacta como você consulta e deleta dados.

=== Relacionamento 1:1 (Um para Um)

Quando uma entidade tem exatamente um dado relacionado.

==== Abordagem 1: Documento Embutido

Se os dados são sempre acessados juntos, embuta no mesmo documento.

[source,typescript]
----
// Perfil embutido no usuário
await kv.set(["users", userId], {
  name: "Alice",
  email: "alice@example.com",
  profile: {
    bio: "Desenvolvedora full-stack",
    avatar: "https://...",
    socialLinks: { twitter: "@alice", github: "alice" }
  }
});

// Uma única leitura traz tudo
const user = await kv.get(["users", userId]);
console.log(user.value.profile.bio);
----

**Vantagens:**

* Uma única operação de leitura
* Atomicidade natural (tudo atualiza junto)
* Sem inconsistências entre documentos

**Desvantagens:**

* Documento pode ficar grande
* Não consegue ler só o perfil sem o resto

==== Abordagem 2: Chave Separada

Se os dados são acessados independentemente, separe.

[source,typescript]
----
// Usuário
["users", userId] → { name, email }

// Perfil em chave separada
["users", userId, "profile"] → { bio, avatar, socialLinks }

// Leituras separadas
const user = await kv.get(["users", userId]);
const profile = await kv.get(["users", userId, "profile"]);

// Ou em uma única chamada
const [user, profile] = await kv.get([
  ["users", userId],
  ["users", userId, "profile"]
]);
----

**Vantagens:**

* Lê apenas o que precisa
* Documentos menores

**Desvantagens:**

* Mais chamadas se precisar de ambos
* Precisa manter consistência manual

=== Relacionamento 1:N (Um para Muitos)

Quando uma entidade tem múltiplos itens relacionados.

==== Estratégia Hierárquica

Use a hierarquia da chave para agrupar dados relacionados.

[source,typescript]
----
// Usuário é o "pai"
["users", userId] → { name, email }

// Posts são "filhos" hierárquicos
["users", userId, "posts", postId] → { title, content, createdAt }
----

**Listar posts de um usuário:**

[source,typescript]
----
// Simples: apenas o prefixo
const posts: Post[] = [];
for await (const entry of kv.list<Post>(["users", userId, "posts"])) {
  posts.push(entry.value);
}
----

**Vantagem: Delete em cascata automático:**

[source,typescript]
----
// Deleta o usuário E todos os seus posts
await kv.delete(["users", userId]);
// Tudo que começa com ["users", userId] é removido:
// - ["users", userId]
// - ["users", userId, "posts", "post_1"]
// - ["users", userId, "posts", "post_2"]
// - ["users", userId, "profile"]
// - etc.
----

==== Estratégia por Referência

Quando os "filhos" precisam existir independentemente.

[source,typescript]
----
// Entidades separadas
["users", userId] → { name, email }
["posts", postId] → { title, content, authorId: userId }

// Índice para encontrar posts por autor
["posts_by_author", userId, postId] → post
----

**Listar posts de um usuário:**

[source,typescript]
----
// Passo 1: Encontrar IDs dos posts
const postIds: string[] = [];
for await (const entry of kv.list(["posts_by_author", userId])) {
  postIds.push(entry.value);
}

// Passo 2: Buscar posts (batch para eficiência)
const posts = await kv.get(postIds.map(id => ["posts", id]));
----

**Por que usar referência em vez de hierarquia?**

1. **Posts podem existir sem autor** (autor deletado, posts órfãos)
2. **Posts podem ter múltiplos autores** (co-autoria)
3. **Queries globais de posts** são comuns (não só por autor)

=== Relacionamento N:N (Muitos para Muitos)

Quando ambos os lados podem ter múltiplas conexões.

==== Exemplo: Posts e Tags

Um post pode ter várias tags. Uma tag pode estar em vários posts.

[source,typescript]
----
// Entidades principais
["posts", postId] → { title, content, tags: ["typescript", "tutorial"] }
["tags", tagName] → { description, postsCount }

// Tabela de junção (valor = timestamp de quando foi adicionada)
["post_tags", postId, tagName] → kv.now()
["tag_posts", tagName, postId] → kv.now()
----

**Criar post com tags:**

[source,typescript]
----
async function createPost(post: Post): Promise<string> {
  const postId = crypto.randomUUID();

  const atomic = kv.atomic()
    .set(["posts", postId], { ...post, id: postId });

  // Criar relações para cada tag
  const now = kv.now();
  for (const tag of post.tags) {
    atomic
      .set(["post_tags", postId, tag], now)
      .set(["tag_posts", tag, postId], now)
      .sum(["tags", tag, "count"], 1n);  // Contador de posts
  }

  await atomic.commit();
  return postId;
}
----

**Buscar posts por tag:**

[source,typescript]
----
async function getPostsByTag(tag: string): Promise<Post[]> {
  const postIds: string[] = [];

  for await (const entry of kv.list(["tag_posts", tag])) {
    // A chave é ["tag_posts", tag, postId]
    const postId = entry.key[2] as string;
    postIds.push(postId);
  }

  const entries = await kv.get<Post>(postIds.map(id => ["posts", id]));
  return entries.map(e => e.value).filter(Boolean) as Post[];
}
----

**Buscar tags de um post:**

[source,typescript]
----
async function getTagsForPost(postId: string): Promise<string[]> {
  const tags: string[] = [];

  for await (const entry of kv.list(["post_tags", postId])) {
    // A chave é ["post_tags", postId, tagName]
    const tagName = entry.key[2] as string;
    tags.push(tagName);
  }

  return tags;
}
----

==== Atualizar relações N:N

Quando as tags de um post mudam:

[source,typescript]
----
async function updatePostTags(postId: string, newTags: string[]): Promise<void> {
  const post = await kv.get<Post>(["posts", postId]);
  if (!post.value) throw new Error("Post não encontrado");

  const oldTags = new Set(post.value.tags);
  const newTagSet = new Set(newTags);

  const atomic = kv.atomic()
    .set(["posts", postId], { ...post.value, tags: newTags });

  // Tags removidas
  for (const tag of oldTags) {
    if (!newTagSet.has(tag)) {
      atomic
        .delete(["post_tags", postId, tag])
        .delete(["tag_posts", tag, postId])
        .sum(["tags", tag, "count"], -1n);
    }
  }

  // Tags adicionadas
  const now = kv.now();
  for (const tag of newTagSet) {
    if (!oldTags.has(tag)) {
      atomic
        .set(["post_tags", postId, tag], now)
        .set(["tag_posts", tag, postId], now)
        .sum(["tags", tag, "count"], 1n);
    }
  }

  await atomic.commit();
}
----

=== Denormalização: Trade-off de Performance

Em bancos relacionais, normalizamos para evitar duplicação. Em KeyVal, **denormalização controlada** pode melhorar performance drasticamente.

==== O Problema: N+1 Queries

[source,typescript]
----
// Lista posts com nome do autor
const postsWithAuthor = [];

for await (const entry of kv.list<Post>(["posts"], { limit: 10 })) {
  // Para cada post, busca o autor (N queries extras!)
  const author = await kv.get<User>(["users", entry.value.authorId]);

  postsWithAuthor.push({
    ...entry.value,
    authorName: author.value?.name
  });
}
// Total: 1 query (list) + 10 queries (get) = 11 queries
----

==== Solução 1: Batch com get

[source,typescript]
----
// Coleta IDs primeiro
const posts: Post[] = [];
const authorIds = new Set<string>();

for await (const entry of kv.list<Post>(["posts"], { limit: 10 })) {
  posts.push(entry.value);
  authorIds.add(entry.value.authorId);
}

// Busca autores em batch
const authors = await kv.get<User>(
  [...authorIds].map(id => ["users", id])
);
const authorMap = new Map(
  authors.map(a => [a.value?.id, a.value?.name])
);

// Combina
const postsWithAuthor = posts.map(p => ({
  ...p,
  authorName: authorMap.get(p.authorId)
}));
// Total: 1 query (list) + 1 query (get) = 2 queries
----

==== Solução 2: Denormalização

[source,typescript]
----
// Armazena nome do autor diretamente no post
["posts", postId] → {
  title: "Hello World",
  content: "...",
  authorId: "user_123",
  authorName: "Alice"  // Denormalizado!
}

// Lista sem lookup adicional
const postsWithAuthor: PostWithAuthor[] = [];
for await (const entry of kv.list<PostWithAuthor>(["posts"], { limit: 10 })) {
  postsWithAuthor.push(entry.value);
}
// Total: 1 query!
----

**Quando o autor muda de nome?**

[source,typescript]
----
// Precisa atualizar todos os posts
async function updateUserName(userId: string, newName: string): Promise<void> {
  // Atualiza o usuário
  const user = await kv.get<User>(["users", userId]);
  if (!user.value) return;

  await kv.set(["users", userId], { ...user.value, name: newName });

  // Atualiza posts denormalizados (pode ser assíncrono)
  await kv.enqueue({
    type: "update_author_name",
    authorId: userId,
    newName
  });
}

// Processador da fila
kv.listenQueue(async (msg) => {
  if (msg.type === "update_author_name") {
    for await (const entry of kv.list<Post>(["posts_by_author", msg.authorId])) {
      const post = await kv.get<Post>(["posts", entry.value]);
      if (post.value) {
        await kv.set(["posts", entry.value], {
          ...post.value,
          authorName: msg.newName
        });
      }
    }
  }
});
----

==== Quando Denormalizar?

[cols="1,1,1"]
|===
| Fator | Denormalizar | Não Denormalizar

| Leituras vs Escritas
| Muitas leituras, poucas escritas
| Escritas frequentes

| Frequência de mudança
| Dados raramente mudam
| Dados mudam constantemente

| Tolerância a inconsistência
| Eventual consistency aceitável
| Precisa de strong consistency

| Exemplo
| Nome do autor em posts
| Saldo de conta
|===

=== Padrões de Referência

==== Referência Simples (ID)

[source,typescript]
----
["posts", postId] → { title, authorId: "user_123" }
----

* Armazena apenas o ID
* Precisa de lookup para obter dados

==== Referência com Preview

[source,typescript]
----
["posts", postId] → {
  title,
  author: {
    id: "user_123",
    name: "Alice",       // Preview denormalizado
    avatarUrl: "https://..."
  }
}
----

* Dados frequentes já disponíveis
* Dados completos via lookup se necessário

==== Referência Bidirecional

[source,typescript]
----
// Post referencia autor
["posts", postId] → { title, authorId }

// Índice de posts por autor (valor = timestamp de criação)
["users", userId, "post_refs", postId] → kv.now()
----

* Navegação eficiente em ambas direções
* Requer manutenção de ambos ao criar/deletar

=== Referência Rápida

[cols="1,2,2"]
|===
| Tipo | Estratégia | Quando Usar

| 1:1
| Embutir no documento
| Dados sempre juntos

| 1:1
| Chave separada
| Acesso independente

| 1:N
| Hierarquia na chave
| Filho pertence ao pai, delete em cascata

| 1:N
| Referência + índice
| Entidades independentes

| N:N
| Tabela de junção
| Relações bidirecionais

| Performance
| Denormalização
| Leituras > Escritas, dados estáveis
|===
