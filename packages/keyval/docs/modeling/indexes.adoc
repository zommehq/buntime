== Índices Secundários

Em bancos relacionais, índices são criados com `CREATE INDEX` e gerenciados automaticamente. No KeyVal, **índices são manuais** — oferecendo controle total, mas exigindo disciplina na manutenção.

=== Fundamentos

==== O Problema: KeyVal Só Ordena por Chave

KeyVal armazena dados ordenados pela **chave primária**. Quando você faz `list()`, ele percorre essa ordenação.

[source,typescript]
----
["users", "usr_001"] → { name: "Alice", email: "alice@ex.com", city: "São Paulo" }
["users", "usr_002"] → { name: "Bob", email: "bob@ex.com", city: "Rio" }
["users", "usr_003"] → { name: "Carol", email: "carol@ex.com", city: "São Paulo" }
----

Para encontrar um usuário **por email**, não há atalho:

[source,typescript]
----
// Sem índice: precisa varrer TODOS os usuários
async function findByEmail(email: string): Promise<User | null> {
  for await (const entry of kv.list<User>(["users"])) {
    if (entry.value.email === email) {
      return entry.value;
    }
  }
  return null;
}
// Complexidade: O(n) - lento para milhões de registros
----

==== A Solução: Criar Estrutura Adicional

Um índice é simplesmente outra chave que aponta para o dado original.

[source,typescript]
----
// Índice: email → ID
["users_by_email", "alice@ex.com"] → "usr_001"
["users_by_email", "bob@ex.com"] → "usr_002"
["users_by_email", "carol@ex.com"] → "usr_003"

// Busca com índice: duas operações O(1)
async function findByEmail(email: string): Promise<User | null> {
  const ref = await kv.get(["users_by_email", email]);
  if (!ref.value) return null;

  const user = await kv.get<User>(["users", ref.value]);
  return user.value;
}
// Complexidade: O(1) - constante, não importa quantos usuários
----

=== Tipos de Índice

==== Índice Único

Para campos que **não podem repetir**: email, CPF, username.

[source,typescript]
----
// Estrutura
["users", userId]               → { name, email, ... }
["users_by_email", email]       → userId
["users_by_cpf", cpf]           → userId
----

**Criar usuário com índice único:**

[source,typescript]
----
async function createUser(data: NewUser): Promise<string> {
  const id = crypto.randomUUID();

  // Verifica se email já existe
  const existing = await kv.get(["users_by_email", data.email]);
  if (existing.value) {
    throw new Error("Email já cadastrado");
  }

  // Cria atomicamente (evita race condition)
  const result = await kv.atomic()
    .check({ key: ["users_by_email", data.email], versionstamp: null })
    .set(["users", id], { ...data, id, createdAt: kv.now() })
    .set(["users_by_email", data.email], id)
    .commit();

  if (!result.ok) {
    throw new Error("Email já cadastrado (race condition)");
  }

  return id;
}
----

O `check({ versionstamp: null })` garante que a chave não existe no momento do commit.

==== Índice Não-Único

Para campos que **podem repetir**: cidade, status, categoria.

A diferença é que você precisa incluir o ID na chave para evitar colisões:

[source,typescript]
----
// ERRADO: sem ID, segunda pessoa de SP sobrescreve a primeira
["users_by_city", "São Paulo"] → "usr_001"
["users_by_city", "São Paulo"] → "usr_003"  // Sobrescreveu!

// CORRETO: ID na chave evita colisão
["users_by_city", "São Paulo", "usr_001"] → "usr_001"
["users_by_city", "São Paulo", "usr_003"] → "usr_003"
----

**Criar com índice não-único:**

[source,typescript]
----
await kv.atomic()
  .set(["users", id], user)
  .set(["users_by_city", user.city, id], id)
  .commit();
----

**Listar por cidade:**

[source,typescript]
----
async function getUsersByCity(city: string): Promise<User[]> {
  const userIds: string[] = [];

  for await (const entry of kv.list(["users_by_city", city])) {
    userIds.push(entry.value);
  }

  // Busca em batch para eficiência
  const entries = await kv.get<User>(userIds.map(id => ["users", id]));
  return entries.map(e => e.value).filter(Boolean) as User[];
}
----

==== Índice Composto

Para queries com **múltiplos campos**: "produtos da categoria X ordenados por preço".

[source,typescript]
----
// Estrutura: campos na ordem da query
["products", productId] → { name, category, price }
["products_by_cat_price", category, price, productId] → productId
----

A ordem dos campos na chave determina a ordenação:

[source,typescript]
----
// Dados:
["products_by_cat_price", "eletrônicos", 99, "prod_1"] → "prod_1"
["products_by_cat_price", "eletrônicos", 199, "prod_2"] → "prod_2"
["products_by_cat_price", "eletrônicos", 599, "prod_3"] → "prod_3"
["products_by_cat_price", "roupas", 49, "prod_4"] → "prod_4"

// list(["products_by_cat_price", "eletrônicos"]) retorna:
// prod_1 (R$99), prod_2 (R$199), prod_3 (R$599) - ordenados por preço!
----

**Query com range de preço:**

[source,typescript]
----
async function getCheapProducts(category: string, maxPrice: number) {
  const productIds: string[] = [];

  for await (const entry of kv.list(["products_by_cat_price", category], {
    start: ["products_by_cat_price", category, 0],
    end: ["products_by_cat_price", category, maxPrice + 0.01]
  })) {
    productIds.push(entry.value);
  }

  const entries = await kv.get<Product>(productIds.map(id => ["products", id]));
  return entries.map(e => e.value).filter(Boolean);
}
----

==== Índice Temporal

Para ordenar por data/hora: "eventos mais recentes", "logs do último dia".

[source,typescript]
----
// Opção 1: Timestamp numérico
["events_by_time", timestamp, eventId] → eventId

// Opção 2: Usar UUIDv7 (ordenação perfeita - inclui timestamp)
const vs = Bun.randomUUIDv7();
await kv.atomic()
  .set(["events", id], event)
  .set(["events_by_time", vs, id], id)
  .commit();
----

**Eventos mais recentes:**

[source,typescript]
----
async function getRecentEvents(limit = 10): Promise<Event[]> {
  const eventIds: string[] = [];

  // reverse: true = mais recentes primeiro
  for await (const entry of kv.list(["events_by_time"], { reverse: true, limit })) {
    eventIds.push(entry.value);
  }

  const entries = await kv.get<Event>(eventIds.map(id => ["events", id]));
  return entries.map(e => e.value).filter(Boolean) as Event[];
}
----

**Eventos em um período:**

[source,typescript]
----
async function getEventsBetween(start: Date, end: Date): Promise<Event[]> {
  const eventIds: string[] = [];

  for await (const entry of kv.list(["events_by_time"], {
    start: ["events_by_time", start.getTime()],
    end: ["events_by_time", end.getTime()]
  })) {
    eventIds.push(entry.value);
  }

  const entries = await kv.get<Event>(eventIds.map(id => ["events", id]));
  return entries.map(e => e.value).filter(Boolean) as Event[];
}
----

==== Índice Invertido (Tags)

Para relações N:N onde você precisa buscar em ambas direções.

[source,typescript]
----
// Post tem múltiplas tags
["posts", postId] → { title, tags: ["typescript", "tutorial"] }

// Índice: tag → posts
["tags", "typescript", "post_1"] → "post_1"
["tags", "typescript", "post_2"] → "post_2"
["tags", "tutorial", "post_1"] → "post_1"
----

**Criar post com tags:**

[source,typescript]
----
async function createPost(data: NewPost): Promise<string> {
  const id = crypto.randomUUID();

  const atomic = kv.atomic()
    .set(["posts", id], { ...data, id });

  for (const tag of data.tags) {
    atomic.set(["tags", tag, id], id);
  }

  await atomic.commit();
  return id;
}
----

**Buscar posts por tag:**

[source,typescript]
----
async function getPostsByTag(tag: string): Promise<Post[]> {
  const postIds: string[] = [];

  for await (const entry of kv.list(["tags", tag])) {
    postIds.push(entry.value);
  }

  const entries = await kv.get<Post>(postIds.map(id => ["posts", id]));
  return entries.map(e => e.value).filter(Boolean) as Post[];
}
----

=== Manutenção de Índices

O maior desafio de índices manuais é **mantê-los sincronizados** com os dados.

==== Atualizar Campo Indexado

Quando o valor indexado muda, você precisa atualizar o índice:

[source,typescript]
----
async function updateUserEmail(userId: string, newEmail: string): Promise<void> {
  const user = await kv.get<User>(["users", userId]);
  if (!user.value) throw new Error("Usuário não encontrado");

  const oldEmail = user.value.email;

  // Se email não mudou, não precisa atualizar índice
  if (oldEmail === newEmail) {
    return;
  }

  // Verifica se novo email já existe
  const existing = await kv.get(["users_by_email", newEmail]);
  if (existing.value && existing.value !== userId) {
    throw new Error("Email já em uso");
  }

  // Atualiza atomicamente: usuário + índice antigo + índice novo
  const result = await kv.atomic()
    .check(user)  // Garante que usuário não mudou
    .check({ key: ["users_by_email", newEmail], versionstamp: null })
    .set(["users", userId], { ...user.value, email: newEmail })
    .delete(["users_by_email", oldEmail])  // Remove índice antigo
    .set(["users_by_email", newEmail], userId)  // Cria índice novo
    .commit();

  if (!result.ok) {
    throw new Error("Conflito - tente novamente");
  }
}
----

==== Atualizar Tags (N:N)

[source,typescript]
----
async function updatePostTags(postId: string, newTags: string[]): Promise<void> {
  const post = await kv.get<Post>(["posts", postId]);
  if (!post.value) throw new Error("Post não encontrado");

  const oldTags = new Set(post.value.tags);
  const newTagSet = new Set(newTags);

  const atomic = kv.atomic()
    .check(post)
    .set(["posts", postId], { ...post.value, tags: newTags });

  // Remover índices de tags removidas
  for (const tag of oldTags) {
    if (!newTagSet.has(tag)) {
      atomic.delete(["tags", tag, postId]);
    }
  }

  // Adicionar índices de tags novas
  for (const tag of newTagSet) {
    if (!oldTags.has(tag)) {
      atomic.set(["tags", tag, postId], postId);
    }
  }

  await atomic.commit();
}
----

==== Deletar com Índices

Não esqueça de remover os índices ao deletar:

[source,typescript]
----
async function deleteUser(userId: string): Promise<void> {
  const user = await kv.get<User>(["users", userId]);
  if (!user.value) return;

  await kv.atomic()
    .delete(["users", userId])
    .delete(["users_by_email", user.value.email])
    .delete(["users_by_cpf", user.value.cpf])
    .delete(["users_by_city", user.value.city, userId])
    .commit();
}
----

=== Reconstrução de Índices

Se um índice ficar inconsistente (bug, migração), você pode reconstruí-lo:

[source,typescript]
----
async function rebuildEmailIndex(): Promise<void> {
  console.log("Limpando índice antigo...");
  await kv.delete(["users_by_email"]);

  console.log("Reconstruindo índice...");
  let count = 0;

  for await (const entry of kv.list<User>(["users"])) {
    const user = entry.value;
    await kv.set(["users_by_email", user.email], user.id);
    count++;

    if (count % 1000 === 0) {
      console.log(`Processados: ${count}`);
    }
  }

  console.log(`Índice reconstruído: ${count} entradas`);
}
----

Para volumes grandes, processe em batches:

[source,typescript]
----
async function rebuildIndexBatched(): Promise<void> {
  const BATCH_SIZE = 100;
  let processed = 0;
  let batch: Array<{ key: KvKey; value: string }> = [];

  for await (const entry of kv.list<User>(["users"])) {
    batch.push({
      key: ["users_by_email", entry.value.email],
      value: entry.value.id
    });

    if (batch.length >= BATCH_SIZE) {
      const atomic = kv.atomic();
      for (const item of batch) {
        atomic.set(item.key, item.value);
      }
      await atomic.commit();

      processed += batch.length;
      console.log(`Processados: ${processed}`);
      batch = [];
    }
  }

  // Processa resto
  if (batch.length > 0) {
    const atomic = kv.atomic();
    for (const item of batch) {
      atomic.set(item.key, item.value);
    }
    await atomic.commit();
  }
}
----

=== Denormalização no Índice

Para evitar lookup adicional, armazene dados no índice:

[source,typescript]
----
// Em vez de apenas ID...
["users_by_city", "São Paulo", userId] → userId

// ...armazene dados frequentemente usados
["users_by_city", "São Paulo", userId] → {
  id: userId,
  name: "Alice",
  email: "alice@ex.com"
}
----

**Vantagem:** Lista sem lookup adicional.

[source,typescript]
----
async function getUsersByCity(city: string): Promise<UserPreview[]> {
  const users: UserPreview[] = [];

  for await (const entry of kv.list<UserPreview>(["users_by_city", city])) {
    users.push(entry.value);  // Já tem os dados!
  }

  return users;
}
// 1 query apenas!
----

WARNING: Dados denormalizados podem ficar desatualizados. Use apenas para dados que mudam raramente.

=== Referência Rápida

[cols="2,2,3"]
|===
| Caso de Uso | Tipo de Índice | Estrutura da Chave

| Email único, CPF
| Único
| `["users_by_email", email] → id`

| Usuários por cidade
| Não-único
| `["users_by_city", city, id] → id`

| Produtos por categoria + preço
| Composto
| `["products_by_cat_price", cat, price, id] → id`

| Posts por tag
| Invertido
| `["tags", tag, postId] → postId`

| Eventos recentes
| Temporal
| `["events_by_time", timestamp, id] → id`

| Autocomplete
| Prefixo
| `["users_by_name", prefix, id] → {id, name}`
|===

=== Exceção: Índices de Busca Textual (FTS)

Os índices descritos acima são **manuais** — você os cria e mantém no código. Porém, para **busca textual** (full-text search), o KeyVal oferece índices FTS gerenciados automaticamente pelo servidor.

[source,typescript]
----
// Sem FTS: varredura completa, lento
for await (const entry of kv.list<Post>(["posts"])) {
  if (entry.value.content.toLowerCase().includes("typescript")) {
    results.push(entry.value);
  }
}
// O(n) - precisa ler TODOS os posts

// Com FTS: busca indexada, rápido
for await (const entry of kv.search(["posts"], "typescript")) {
  console.log(entry.value);
}
// O(log n) - usa índice invertido
----

Para documentação completa sobre FTS, incluindo criação de índices, sintaxe de busca, limitações e casos de uso, veja xref:../features/fts.adoc[Full-Text Search (FTS)].
