== Índices Secundários

=== Visão Geral

O KeyVal usa chaves primárias para acesso direto aos dados. Porém, frequentemente precisamos buscar dados por outros campos. **Índices secundários** são padrões de design que permitem essas consultas alternativas.

=== Conceito

Um índice secundário é uma **entrada adicional** que mapeia um campo alternativo para a chave primária:

[source]
----
Dado primário:
["users", 123] → { id: 123, email: "alice@example.com", name: "Alice" }

Índice secundário por email:
["users_by_email", "alice@example.com"] → 123
----

=== Padrões de Índice

==== Índice Simples

Mapeia um campo único para o ID primário:

[source,typescript]
----
interface User {
  email: string;
  id: number;
  name: string;
}

async function createUser(user: User): Promise<void> {
  await kv.atomic()
    // Dado primário
    .set(["users", user.id], user)
    // Índice por email
    .set(["users_by_email", user.email], user.id)
    .commit();
}

async function getUserByEmail(email: string): Promise<User | null> {
  // Buscar ID pelo índice
  const indexEntry = await kv.get<number>(["users_by_email", email]);
  if (!indexEntry.value) return null;

  // Buscar dados pelo ID
  const userEntry = await kv.get<User>(["users", indexEntry.value]);
  return userEntry.value;
}
----

==== Índice Composto

Índice com múltiplos campos para consultas combinadas:

[source,typescript]
----
interface Product {
  category: string;
  id: string;
  price: number;
  status: "active" | "inactive";
}

async function createProduct(product: Product): Promise<void> {
  await kv.atomic()
    .set(["products", product.id], product)
    // Índice por categoria + status
    .set(["products_by_category_status", product.category, product.status, product.id], product.id)
    // Índice por preço (para range queries)
    .set(["products_by_price", product.price, product.id], product.id)
    .commit();
}

// Listar produtos ativos de uma categoria
async function getActiveProductsByCategory(category: string): Promise<Product[]> {
  const products: Product[] = [];

  for await (const entry of kv.list({
    prefix: ["products_by_category_status", category, "active"]
  })) {
    const product = await kv.get<Product>(["products", entry.value]);
    if (product.value) products.push(product.value);
  }

  return products;
}
----

==== Índice Invertido

Mapeia valores para múltiplas chaves (muitos-para-muitos):

[source,typescript]
----
interface Article {
  content: string;
  id: string;
  tags: string[];
  title: string;
}

async function createArticle(article: Article): Promise<void> {
  let atomic = kv.atomic()
    .set(["articles", article.id], article);

  // Criar entrada de índice para cada tag
  for (const tag of article.tags) {
    atomic = atomic.set(["articles_by_tag", tag, article.id], article.id);
  }

  await atomic.commit();
}

// Buscar artigos por tag
async function getArticlesByTag(tag: string): Promise<Article[]> {
  const articles: Article[] = [];

  for await (const entry of kv.list({
    prefix: ["articles_by_tag", tag]
  })) {
    const article = await kv.get<Article>(["articles", entry.value]);
    if (article.value) articles.push(article.value);
  }

  return articles;
}
----

==== Índice de Ordenação

Permite listar em ordem diferente da chave primária:

[source,typescript]
----
interface Post {
  authorId: string;
  createdAt: number;
  id: string;
  title: string;
}

async function createPost(post: Post): Promise<void> {
  await kv.atomic()
    .set(["posts", post.id], post)
    // Índice por data (mais recentes primeiro)
    // Usar MAX_SAFE_INTEGER - timestamp para ordem reversa
    .set(["posts_by_date", Number.MAX_SAFE_INTEGER - post.createdAt, post.id], post.id)
    // Índice por autor + data
    .set(["posts_by_author", post.authorId, post.createdAt, post.id], post.id)
    .commit();
}

// Listar posts mais recentes
async function getRecentPosts(limit = 10): Promise<Post[]> {
  const posts: Post[] = [];

  for await (const entry of kv.list({
    prefix: ["posts_by_date"],
    limit,
  })) {
    const post = await kv.get<Post>(["posts", entry.value]);
    if (post.value) posts.push(post.value);
  }

  return posts;
}

// Listar posts de um autor
async function getPostsByAuthor(authorId: string): Promise<Post[]> {
  const posts: Post[] = [];

  for await (const entry of kv.list({
    prefix: ["posts_by_author", authorId]
  })) {
    const post = await kv.get<Post>(["posts", entry.value]);
    if (post.value) posts.push(post.value);
  }

  return posts;
}
----

=== Manutenção de Índices

==== Atualização Atômica

Ao atualizar dados, os índices devem ser atualizados atomicamente:

[source,typescript]
----
async function updateUserEmail(userId: number, newEmail: string): Promise<void> {
  const user = await kv.get<User>(["users", userId]);
  if (!user.value) throw new Error("Usuário não encontrado");

  const oldEmail = user.value.email;

  await kv.atomic()
    // Verificar que usuário não mudou
    .check({ key: ["users", userId], versionstamp: user.versionstamp })
    // Verificar que novo email não está em uso
    .check({ key: ["users_by_email", newEmail], versionstamp: null })
    // Atualizar usuário
    .set(["users", userId], { ...user.value, email: newEmail })
    // Remover índice antigo
    .delete(["users_by_email", oldEmail])
    // Criar novo índice
    .set(["users_by_email", newEmail], userId)
    .commit();
}
----

==== Deleção com Índices

[source,typescript]
----
async function deleteUser(userId: number): Promise<void> {
  const user = await kv.get<User>(["users", userId]);
  if (!user.value) return;

  await kv.atomic()
    .delete(["users", userId])
    .delete(["users_by_email", user.value.email])
    .commit();
}
----

=== Padrões Avançados

==== Denormalização

Armazenar dados duplicados no índice para evitar lookups adicionais:

[source,typescript]
----
// Em vez de armazenar apenas o ID...
.set(["users_by_email", email], userId)

// ...armazenar dados relevantes para a consulta
.set(["users_by_email", email], {
  id: userId,
  name: user.name,  // Dados frequentemente necessários
})
----

==== Índice de Contagem

Manter contadores atualizados:

[source,typescript]
----
async function createArticle(article: Article): Promise<void> {
  // Obter contagem atual para cada tag
  const tagCounts = await Promise.all(
    article.tags.map(async (tag) => {
      const entry = await kv.get<number>(["tag_counts", tag]);
      return { tag, count: entry.value ?? 0, versionstamp: entry.versionstamp };
    })
  );

  let atomic = kv.atomic()
    .set(["articles", article.id], article);

  for (const { tag, count, versionstamp } of tagCounts) {
    atomic = atomic
      .check({ key: ["tag_counts", tag], versionstamp })
      .set(["articles_by_tag", tag, article.id], article.id)
      .set(["tag_counts", tag], count + 1);
  }

  await atomic.commit();
}
----

==== Índice Único (Constraint)

Garantir unicidade de campos:

[source,typescript]
----
async function createUserWithUniqueEmail(user: User): Promise<boolean> {
  const result = await kv.atomic()
    // Verificar que email não está em uso
    .check({ key: ["users_by_email", user.email], versionstamp: null })
    // Criar usuário e índice
    .set(["users", user.id], user)
    .set(["users_by_email", user.email], user.id)
    .commit();

  return result.ok; // false se email já existe
}
----

=== Reconstrução de Índices

Para recriar índices após mudanças de schema:

[source,typescript]
----
async function rebuildEmailIndex(): Promise<void> {
  // Limpar índice existente
  for await (const entry of kv.list({ prefix: ["users_by_email"] })) {
    await kv.delete(entry.key);
  }

  // Reconstruir a partir dos dados primários
  for await (const entry of kv.list<User>({ prefix: ["users"] })) {
    if (entry.value) {
      await kv.set(
        ["users_by_email", entry.value.email],
        entry.key[1] // userId
      );
    }
  }
}
----

=== Consultas Complexas

==== Paginação

[source,typescript]
----
interface PaginatedResult<T> {
  cursor: string | null;
  hasMore: boolean;
  items: T[];
}

async function listUsers(
  cursor?: string,
  pageSize = 20
): Promise<PaginatedResult<User>> {
  const users: User[] = [];
  let lastKey: string | null = null;

  const startKey = cursor ? ["users", parseInt(cursor)] : ["users"];

  for await (const entry of kv.list<User>({
    start: startKey,
    prefix: ["users"],
    limit: pageSize + 1, // +1 para detectar hasMore
  })) {
    if (entry.value && users.length < pageSize) {
      users.push(entry.value);
      lastKey = String(entry.key[1]);
    }
  }

  return {
    items: users,
    cursor: lastKey,
    hasMore: users.length > pageSize,
  };
}
----

==== Busca por Range de Datas

[source,typescript]
----
async function getOrdersBetweenDates(
  startDate: Date,
  endDate: Date
): Promise<Order[]> {
  const orders: Order[] = [];

  for await (const entry of kv.list({
    start: ["orders_by_date", startDate.getTime()],
    end: ["orders_by_date", endDate.getTime()],
  })) {
    const order = await kv.get<Order>(["orders", entry.value]);
    if (order.value) orders.push(order.value);
  }

  return orders;
}
----

=== Considerações de Performance

==== Trade-offs

[cols="1,1,1"]
|===
| Aspecto | Mais Índices | Menos Índices

| Leitura
| Mais rápida
| Mais lenta (scans)

| Escrita
| Mais lenta
| Mais rápida

| Armazenamento
| Maior
| Menor

| Consistência
| Mais complexa
| Mais simples
|===

==== Recomendações

1. **Crie índices apenas para consultas frequentes**
2. **Evite índices em campos que mudam frequentemente**
3. **Considere denormalização para leituras críticas**
4. **Documente todos os índices e suas finalidades**

[source,typescript]
----
/**
 * Índices do modelo User:
 *
 * - users_by_email: Lookup por email (login)
 * - users_by_created: Listagem por data de criação
 * - users_by_status: Filtro por status (active/inactive)
 */
----
