== Logging

O sistema de logging do Buntime é centralizado no pacote `@buntime/shared/logger`.

=== Arquitetura

[source]
----
@buntime/shared/logger
├── index.ts              # Singleton + exports
├── types.ts              # Logger, LogLevel, LogEntry, LogTransport
├── logger.ts             # LoggerImpl + createLogger
└── transports/
    ├── console.ts        # ConsoleTransport (pretty/json)
    └── file.ts           # FileTransport (buffer + flush)
----

=== API

==== Funções Principais

[cols="1,2"]
|===
| Função | Descrição

| `createLogger(config)`
| Cria uma nova instância de logger

| `getLogger()`
| Obtém o logger global (cria default se não existir)

| `setLogger(logger)`
| Define o logger global

| `getChildLogger(context)`
| Cria child logger com prefixo de contexto

| `initLogger(config)`
| Inicializa e define o logger global
|===

==== Interface Logger

[source,typescript]
----
interface Logger {
  debug(message: string, meta?: Record<string, unknown>): void;
  info(message: string, meta?: Record<string, unknown>): void;
  warn(message: string, meta?: Record<string, unknown>): void;
  error(message: string, meta?: Record<string, unknown>): void;
  child(context: string): Logger;
  flush(): Promise<void>;
  close(): Promise<void>;
}
----

==== Configuração

[source,typescript]
----
interface LoggerConfig {
  level?: "debug" | "info" | "warn" | "error";  // default: "info" ou LOG_LEVEL env
  format?: "pretty" | "json";                    // default: "pretty"
  colors?: boolean;                              // default: auto-detect TTY
  transports?: ("console" | "file" | LogTransport)[];
  filePath?: string;                             // obrigatório se usar "file"
}
----

=== Uso no Runner

O runner inicializa o logger global no início do processo:

[source,typescript]
----
// runtime/server/index.ts
import { createLogger, setLogger } from "@buntime/shared/logger";

const logger = createLogger({
  level: NODE_ENV === "production" ? "info" : "debug",
  format: NODE_ENV === "production" ? "json" : "pretty",
});
setLogger(logger);
----

IMPORTANT: O logger deve ser inicializado antes de qualquer outro código que use logging.

=== Uso em Plugins

Plugins recebem um logger via `ctx.logger` no hook `onInit`:

[source,typescript]
----
// plugins/plugin-example/src/index.ts
import type { BuntimePlugin, PluginContext } from "@buntime/shared/types";

let logger: PluginContext["logger"];

export default function createPlugin(config: Config): BuntimePlugin {
  return {
    name: "plugin-example",

    onInit(ctx: PluginContext) {
      logger = ctx.logger;
      logger.info("Plugin initialized", { config });
    },

    async onRequest(req: Request) {
      logger.debug("Processing request", { url: req.url });
      return req;
    },
  };
}
----

O `ctx.logger` já vem configurado com o contexto do plugin (ex: `plugin:example`).

==== Fallback

Se um plugin precisa de logger antes do `onInit` ou em contexto standalone, pode usar `getChildLogger`:

[source,typescript]
----
import { getChildLogger } from "@buntime/shared/logger";

const logger = getChildLogger("plugin:example");
----

NOTE: Se o runner ainda não inicializou o logger global, `getChildLogger` cria um logger console default.

=== Níveis de Log

Os níveis seguem ordem de severidade:

[cols="1,1,2"]
|===
| Nível | Prioridade | Uso

| `debug`
| 0
| Informações detalhadas para debugging

| `info`
| 1
| Eventos normais de operação

| `warn`
| 2
| Situações anormais mas não críticas

| `error`
| 3
| Erros que precisam atenção
|===

==== Filtragem por Nível

O logger só emite logs com prioridade >= nível configurado:

[source,typescript]
----
const logger = createLogger({ level: "warn" });
logger.debug("ignored");  // não aparece
logger.info("ignored");   // não aparece
logger.warn("appears");   // ✓ aparece
logger.error("appears");  // ✓ aparece
----

==== Variáveis de Ambiente

[cols="1,2"]
|===
| Variável | Efeito

| `LOG_LEVEL=debug`
| Define nível mínimo de log

| `DEBUG=*` ou `DEBUG=true`
| Ativa nível debug
|===

=== Transports

==== ConsoleTransport

Output para stdout/stderr com suporte a cores e formatos.

[source,typescript]
----
import { ConsoleTransport } from "@buntime/shared/logger";

const transport = new ConsoleTransport({
  format: "pretty",  // ou "json"
  colors: true,
});
----

===== Formato Pretty

----
12:34:56.789 INF [plugin:keyval] Request processed {"duration":45}
12:34:56.790 ERR [plugin:keyval] Failed to connect {"error":"timeout"}
----

===== Formato JSON

[source,json]
----
{"level":"info","message":"Request processed","time":"2024-01-15T12:34:56.789Z","context":"plugin:keyval","duration":45}
----

==== FileTransport

Escreve logs em arquivo com buffering para performance.

[source,typescript]
----
import { FileTransport } from "@buntime/shared/logger";

const transport = new FileTransport({
  path: "/var/log/buntime.log",
  bufferSize: 100,      // flush após 100 entradas
  flushInterval: 5000,  // flush a cada 5 segundos
});
----

=== Child Loggers

Child loggers herdam configuração mas adicionam contexto:

[source,typescript]
----
const logger = createLogger({ level: "debug" });
const childA = logger.child("moduleA");
const childB = childA.child("submodule");

childB.info("Hello");
// Output: ... [moduleA:submodule] Hello
----

=== Boas Práticas

==== DO

* Use `ctx.logger` em plugins
* Use níveis apropriados (debug para dev, info para prod)
* Inclua metadata estruturada
* Use child loggers para contexto

[source,typescript]
----
logger.info("User created", { userId: 123, email: "user@example.com" });
----

==== DON'T

* Não use `console.log` diretamente
* Não logue dados sensíveis (senhas, tokens)
* Não logue em loops tight (use debug + nível apropriado)

[source,typescript]
----
// ❌ Ruim
console.log("User created:", user);

// ✓ Bom
logger.info("User created", { userId: user.id });
----
