= Arquitetura Micro-Frontend de Plugins
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

== Visão Geral

Este documento descreve a arquitetura micro-frontend para plugins do Buntime, inspirada na estratégia de arquitetura Fragment da Cloudflare:

- https://blog.cloudflare.com/fragment-piercing/

=== Objetivos

- **Modularidade**: Cada plugin pode fornecer sua própria UI como um worker separado
- **Independência**: UIs de plugins são desenvolvidas, construídas e implantadas de forma independente
- **Agnóstico de Framework**: Plugins podem usar React, Solid, Qwik, Vue, etc.
- **SSR First**: Server-side rendering para carregamento inicial rápido
- **Integração Transparente**: Fragments se integram ao shell principal do dashboard

=== Diagrama da Arquitetura

[mermaid]
----
flowchart TB
    subgraph Runner["Buntime Runner (Port 8000)"]
        subgraph Gateway["FragmentGateway (Hono Middleware)"]
            G1["Intercepts HTML requests"]
            G2["Routes /fragment/:id to plugin workers"]
            G3["Routes /_fragment/:id/* to plugin assets"]
            G4["Combines fragment streams with shell HTML"]
        end

        Gateway --> Dashboard
        Gateway --> Deployments
        Gateway --> MetricsFrag

        subgraph Dashboard["Dashboard (Shell)"]
            D1["Layout"]
            D2["Nav"]
            D3["Outlets"]
        end

        subgraph Deployments["Deployments (Fragment)"]
            DF1["File Mgmt"]
            DF2["Upload"]
            DF3["Deploy"]
        end

        subgraph MetricsFrag["Metrics (Fragment)"]
            MF1["Charts"]
            MF2["Stats"]
            MF3["SSE"]
        end

        Dashboard --> MessageBus
        Deployments --> MessageBus
        MetricsFrag --> MessageBus

        subgraph MessageBus["MessageBus (Shared State)"]
            MB1["dispatch('auth', { user: '...' })"]
            MB2["listen('theme', (value) => ...)"]
            MB3["SSR state hydration"]
        end
    end
----

== Registro de UI de Plugin

=== Extensão da Interface de Plugin

[source,typescript]
----
interface BuntimePlugin {
  name: string;
  version: string;
  priority?: number;
  base?: string;
  routes?: Hono;

  // NEW: Micro-frontend UI configuration
  fragment?: {
    /** Unique fragment ID (derived from plugin name if not provided) */
    fragmentId?: string;
    /** Directory containing the fragment's built assets */
    assetsDir: string;
    /** SSR entry point that exports fetch handler */
    ssrEntry: string;
    /** Framework used (for gateway optimizations) */
    framework?: "react" | "qwik" | "solid" | "vue";
    /** Styles to apply before loading (for seamless transitions) */
    preLoadStyles?: string;
    /** Routes where this fragment should be pre-loaded in HTML */
    preLoadRoutes?: string[];
    /** Navigation item to register in dashboard */
    navigation?: {
      title: string;
      icon: string;
      path: string;
      priority?: number;
    };
  };
}
----

=== Exemplo de Plugin com Fragment

[source,typescript]
----
// plugins/plugin-deployments/src/index.ts
import { definePlugin } from "@buntime/shared";

export default definePlugin({
  name: "@buntime/plugin-deployments",
  version: "1.0.0",

  fragment: {
    assetsDir: "./dist/client",
    ssrEntry: "./dist/server/entry.ssr.js",
    framework: "react",
    preLoadRoutes: ["/dashboard/deployments*"],
    navigation: {
      title: "Deployments",
      icon: "lucide:cloud-upload",
      path: "/dashboard/deployments",
      priority: 10,
    },
  },

  // API routes (backend)
  routes: createDeploymentRoutes(),
});
----

== Componentes Principais

=== FragmentGateway para Bun

Adaptado da implementação da Cloudflare para o runtime do Bun.

[source,typescript]
----
// packages/fragment/src/fragment-gateway.ts
import type { Hono } from "hono";
import type { MessageBusState } from "./message-bus";

interface FragmentConfig {
  fragmentId: string;
  framework?: "react" | "qwik" | "solid" | "vue";
  preLoadStyles?: string;
  preLoadRoutes?: string[];
  assetsDir: string;
  ssrFetch: (req: Request) => Promise<Response>;
}

interface FragmentGatewayConfig {
  getShellHtml: (req: Request) => Promise<string>;
  generateMessageBusState: (
    requestState: MessageBusState,
    req: Request
  ) => MessageBusState | Promise<MessageBusState>;
}

export class FragmentGateway {
  private fragments = new Map<string, FragmentConfig>();

  constructor(private config: FragmentGatewayConfig) {}

  registerFragment(config: FragmentConfig): void {
    this.fragments.set(config.fragmentId, config);
  }

  middleware(): MiddlewareHandler {
    return async (ctx, next) => {
      // 1. Handle fragment SSR requests: /fragment/:id
      // 2. Handle fragment asset requests: /_fragment/:id/*
      // 3. For HTML requests, inject pre-loaded fragments
      // 4. Otherwise, pass to next handler
    };
  }
}
----

=== Web Component Fragment Host

[source,typescript]
----
// packages/fragment/src/fragment-host.ts
export class FragmentHost extends HTMLElement {
  private messageBus: FragmentMessageBus;
  fragmentId!: string;

  connectedCallback() {
    this.fragmentId = this.getAttribute("fragment-id")!;
    this.messageBus = new FragmentMessageBus(this);

    if (!this.fragmentIsLoaded) {
      this.setStylesEmbeddingObserver();
    }
  }

  loadInto(outlet: Element) {
    // Move this fragment into the outlet element
    outlet.appendChild(this);
    this.removeStylesEmbeddingObserver();
  }
}
----

=== Web Component Fragment Outlet

[source,typescript]
----
// packages/fragment/src/fragment-outlet.ts
export class FragmentOutlet extends HTMLElement {
  async connectedCallback() {
    const fragmentId = this.getAttribute("fragment-id")!;

    // Try to find existing pre-loaded fragment
    let host = document.querySelector(
      `fragment-host[fragment-id="${fragmentId}"]`
    );

    if (host) {
      // Fragment was pre-loaded in HTML, move it here
      host.loadInto(this);
    } else {
      // Fetch fragment on-demand
      const stream = await this.fetchFragment(fragmentId);
      await this.streamIntoOutlet(stream);
    }
  }

  private async fetchFragment(id: string): Promise<ReadableStream> {
    const res = await fetch(`/fragment/${id}`, {
      headers: {
        "message-bus-state": JSON.stringify(getBus().state),
      },
    });
    return res.body!;
  }
}
----

=== MessageBus para Comunicação Entre Fragments

[source,typescript]
----
// packages/fragment/src/message-bus.ts
export interface MessageBus {
  state: MessageBusState;
  dispatch(event: string, value: JSONValue): void;
  listen<T>(event: string, callback: (value: T) => void): () => void;
  latestValue<T>(event: string): T | undefined;
}

// Usage in fragments:
const bus = getBus();

// Listen for auth changes
bus.listen("auth", (user) => {
  console.log("User changed:", user);
});

// Dispatch navigation event
bus.dispatch("navigate", { path: "/deployments" });
----

== Plugin Dashboard (Shell)

O plugin dashboard fornece o shell que orquestra todos os plugins fragment.

=== Estrutura

[source]
----
plugins/plugin-dashboard/
├── package.json
├── src/
│   ├── index.ts           # Plugin entry
│   ├── server/
│   │   └── index.ts       # SSR shell
│   └── client/
│       ├── index.tsx      # Client entry
│       ├── components/
│       │   ├── layout.tsx # Main layout with outlets
│       │   └── nav.tsx    # Navigation (from plugin registry)
│       └── routes/
│           └── index.tsx  # Dashboard home
└── dist/
----

=== Layout do Shell com Outlets

[source,tsx]
----
// plugin-dashboard/src/client/components/layout.tsx
import { useNavigationItems } from "../hooks/use-navigation";

export function DashboardLayout({ children }: { children: React.ReactNode }) {
  const navItems = useNavigationItems(); // From MessageBus

  return (
    <div className="dashboard">
      <aside className="sidebar">
        <nav>
          {navItems.map((item) => (
            <NavLink key={item.path} to={item.path}>
              <Icon icon={item.icon} />
              {item.title}
            </NavLink>
          ))}
        </nav>
      </aside>

      <main className="content">
        {children}
      </main>
    </div>
  );
}
----

=== Rotas Dinâmicas de Fragment

[source,tsx]
----
// plugin-dashboard/src/client/routes/deployments.tsx
export function DeploymentsPage() {
  return (
    <DashboardLayout>
      {/* Fragment outlet - will load deployments fragment */}
      <fragment-outlet fragment-id="deployments" />
    </DashboardLayout>
  );
}
----

== Integração com o Buntime Runner

=== Coleta de Fragments no Registry

[source,typescript]
----
// runtime/server/plugins/registry.ts
export class PluginRegistry {
  // ... existing methods ...

  /**
   * Get all plugins that have fragment UIs
   */
  getFragmentPlugins(): Array<{
    plugin: LoadedPlugin;
    config: FragmentConfig;
  }> {
    return this.plugins
      .filter((p) => p.fragment)
      .map((p) => ({
        plugin: p,
        config: {
          fragmentId: p.fragment!.fragmentId ?? this.getFragmentId(p.name),
          ...p.fragment!,
        },
      }));
  }

  /**
   * Get navigation items from all fragment plugins
   */
  getNavigationItems(): NavigationItem[] {
    return this.getFragmentPlugins()
      .filter((p) => p.config.navigation)
      .map((p) => p.config.navigation!)
      .sort((a, b) => (a.priority ?? 50) - (b.priority ?? 50));
  }

  private getFragmentId(pluginName: string): string {
    // @buntime/plugin-deployments -> deployments
    return pluginName.replace(/^@[^/]+\/plugin-/, "");
  }
}
----

=== Integração com App

[source,typescript]
----
// runtime/server/app.ts
import { FragmentGateway } from "@buntime/fragment";

export function createApp(deps: AppDeps) {
  const app = new Hono();

  // Create fragment gateway
  const gateway = new FragmentGateway({
    getShellHtml: async (req) => {
      // Fetch shell HTML from dashboard plugin
      const dashboardWorker = deps.pool.getOrCreate("dashboard");
      const res = await dashboardWorker.fetch(req);
      return res.text();
    },
    generateMessageBusState: async (state, req) => {
      // Add navigation items to bus state
      return {
        ...state,
        navigation: deps.registry.getNavigationItems(),
        theme: "system",
      };
    },
  });

  // Register all fragment plugins
  for (const { config } of deps.registry.getFragmentPlugins()) {
    gateway.registerFragment({
      ...config,
      ssrFetch: async (req) => {
        const worker = deps.pool.getOrCreate(config.fragmentId);
        return worker.fetch(req);
      },
    });
  }

  // Add fragment middleware
  app.use("*", gateway.middleware());

  // ... rest of app setup
}
----

== Candidatos a Novos Plugins

Com base na funcionalidade atual do runner, estes podem se tornar plugins fragment:

=== plugin-deployments

Atual: `runtime/client/routes/deployments/`

Funcionalidades:
- Navegador de arquivos
- Upload/download
- Gerenciamento de pastas
- Implantação de workers

=== plugin-metrics (extensão de UI)

Atual: Já é um plugin, mas a UI está no runner

Adicionar fragment ao plugin existente:
- Dashboard de estatísticas do pool
- Gráficos de métricas de workers
- Visualização de métricas Prometheus

=== plugin-logs

Novo plugin para logging centralizado:
- Streaming de logs em tempo real (SSE)
- Filtragem/busca de logs
- Retenção/exportação de logs

=== plugin-health

Novo plugin para monitoramento de saúde:
- Endpoints de health check
- Probes de liveness/readiness
- Dashboard de status de serviços

== Caminho de Migração

1. **Fase 1**: Criar pacote `@buntime/fragment` com componentes principais
2. **Fase 2**: Criar `plugin-dashboard` como orquestrador do shell
3. **Fase 3**: Extrair `plugin-deployments` do cliente do runner
4. **Fase 4**: Adicionar UI fragment ao `plugin-metrics`
5. **Fase 5**: Criar novos plugins (logs, health)

== Benefícios

- **Implantação Independente**: Atualizar UIs de plugins sem alterar o runner
- **Liberdade Tecnológica**: Cada plugin pode usar frameworks diferentes
- **Melhor DX**: Desenvolvedores de plugins são donos de toda sua stack
- **Lazy Loading**: Fragments carregam sob demanda
- **Performance SSR**: Renderização inicial rápida com streaming
- **Isolamento**: Bugs em fragments não derrubam o shell
