= Arquitetura Micro-Frontend de Plugins
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

== Visão Geral

Este documento descreve a arquitetura micro-frontend para plugins do Buntime, inspirada na estratégia de arquitetura Fragment da Cloudflare:

- https://blog.cloudflare.com/fragment-piercing/

=== Objetivos

- **Modularidade**: Cada plugin pode fornecer sua própria UI como um worker separado
- **Independência**: UIs de plugins são desenvolvidas, construídas e implantadas de forma independente
- **Agnóstico de Framework**: Plugins podem usar React, Solid, Qwik, Vue, etc.
- **SSR First**: Server-side rendering para carregamento inicial rápido
- **Integração Transparente**: Fragments se integram ao shell principal do dashboard

=== Diagrama da Arquitetura

[mermaid]
----
flowchart TB
    subgraph Runner["Buntime Runner (Port 8000)"]
        subgraph Gateway["FragmentGateway (Hono Middleware)"]
            G1["Intercepts HTML requests"]
            G2["Routes /fragment/:id to plugin workers"]
            G3["Routes /_fragment/:id/* to plugin assets"]
            G4["Combines fragment streams with shell HTML"]
        end

        Gateway --> Dashboard
        Gateway --> Deployments
        Gateway --> MetricsFrag

        subgraph Dashboard["Dashboard (Shell)"]
            D1["Layout"]
            D2["Nav"]
            D3["Outlets"]
        end

        subgraph Deployments["Deployments (Fragment)"]
            DF1["File Mgmt"]
            DF2["Upload"]
            DF3["Deploy"]
        end

        subgraph MetricsFrag["Metrics (Fragment)"]
            MF1["Charts"]
            MF2["Stats"]
            MF3["SSE"]
        end

        Dashboard --> MessageBus
        Deployments --> MessageBus
        MetricsFrag --> MessageBus

        subgraph MessageBus["MessageBus (Shared State)"]
            MB1["dispatch('auth', { user: '...' })"]
            MB2["listen('theme', (value) => ...)"]
            MB3["SSR state hydration"]
        end
    end
----

== Registro de UI de Plugin

=== Extensão da Interface de Plugin

*Manifesto (PluginManifest):*

[source,typescript]
----
interface PluginManifest {
  name: string;
  base: string;
  dependencies?: string[];
  optionalDependencies?: string[];

  // Micro-frontend UI configuration
  fragment?: {
    /** Fragment sandbox type */
    type: "patch" | "iframe";
    /** Origin for iframe type (required for iframe) */
    origin?: string;
    /** Styles to apply before loading (for seamless transitions) */
    preloadStyles?: string;
  };

  // Navigation items for sidebar
  menus?: MenuItem[];
}
----

*Implementação (PluginImpl):*

[source,typescript]
----
interface PluginImpl {
  routes?: Hono;
  middleware?: MiddlewareHandler;
  server?: PluginServer;
  onInit?: (ctx: PluginContext) => Promise<void> | void;
  onShutdown?: () => Promise<void> | void;
  // ... other lifecycle hooks
}
----

=== Exemplo de Plugin com Fragment

*manifest.jsonc:*

[source,jsonc]
----
// plugins/plugin-deployments/manifest.jsonc
{
  "name": "@buntime/plugin-deployments",
  "base": "/deployments",
  "entrypoint": "dist/client/index.html",
  "fragment": { "type": "patch" },
  "menus": [
    {
      "title": "Deployments",
      "icon": "lucide:cloud-upload",
      "path": "/deployments",
      "priority": 10
    }
  ]
}
----

*plugin.ts:*

[source,typescript]
----
// plugins/plugin-deployments/plugin.ts
export default function createPlugin(config: DeploymentsConfig): PluginImpl {
  return {
    routes: createDeploymentRoutes(),

    async onInit(ctx) {
      ctx.logger.info("Deployments plugin initialized");
    },
  };
}
----

== Componentes Principais

=== FragmentGateway para Bun

Adaptado da implementação da Cloudflare para o runtime do Bun.

[source,typescript]
----
// packages/piercing/src/gateway/fragment-gateway.ts
import type { Hono } from "hono";
import type { MessageBusState } from "./message-bus";

interface FragmentConfig {
  fragmentId: string;
  framework?: "react" | "qwik" | "solid" | "vue";
  preLoadStyles?: string;
  preLoadRoutes?: string[];
  assetsDir: string;
  ssrFetch: (req: Request) => Promise<Response>;
}

interface FragmentGatewayConfig {
  getShellHtml: (req: Request) => Promise<string>;
  generateMessageBusState: (
    requestState: MessageBusState,
    req: Request
  ) => MessageBusState | Promise<MessageBusState>;
}

export class FragmentGateway {
  private fragments = new Map<string, FragmentConfig>();

  constructor(private config: FragmentGatewayConfig) {}

  registerFragment(config: FragmentConfig): void {
    this.fragments.set(config.fragmentId, config);
  }

  middleware(): MiddlewareHandler {
    return async (ctx, next) => {
      // 1. Handle fragment SSR requests: /fragment/:id
      // 2. Handle fragment asset requests: /_fragment/:id/*
      // 3. For HTML requests, inject pre-loaded fragments
      // 4. Otherwise, pass to next handler
    };
  }
}
----

=== Web Component Fragment Host

Container para conteúdo do fragmento (usado internamente e no pre-piercing).

[source,typescript]
----
// packages/piercing/src/client/fragment-host.ts
export class PiercingFragmentHost extends HTMLElement {
  private messageBus = new FragmentMessageBus();
  fragmentId!: string;

  connectedCallback(): void {
    const src = this.getAttribute("src");
    if (!src) throw new Error("PiercingFragmentHost requires a src attribute");

    // Derive fragmentId from src
    this.fragmentId = src.split("/").pop() || "fragment";

    // If not pierced yet, observe for styles to embed
    if (!this.isPierced) {
      this.setupStylesObserver();
    }
  }

  pierceInto(target: Element | ShadowRoot): void {
    // Move this fragment into the outlet
    target.appendChild(this);
    this.removeStylesObserver();
  }
}
----

=== Web Component Fragment Outlet

Placeholder que carrega e renderiza um fragmento. Usa Shadow DOM para isolamento de CSS.

[source,typescript]
----
// packages/piercing/src/client/fragment-host.ts
export class PiercingFragmentOutlet extends HTMLElement {
  private shadow: ShadowRoot;

  constructor() {
    super();
    this.shadow = this.attachShadow({ mode: "open" });
  }

  async connectedCallback(): Promise<void> {
    const src = this.getAttribute("src");
    const history = this.getAttribute("history") as "patch" | "isolate" | null;

    if (!src) throw new Error("PiercingFragmentOutlet requires a src attribute");

    // Check for pre-pierced fragment
    const host = document.querySelector(`fragment-host[src="${src}"]`);

    if (host) {
      host.pierceInto(this.shadow);
    } else {
      // Fetch and stream fragment
      const stream = await this.fetchFragment(src);
      await this.streamFragmentInto(stream);
    }
  }

  private async fetchFragment(url: string): Promise<ReadableStream> {
    const response = await fetch(url, {
      headers: { "x-message-bus-state": JSON.stringify(getBus().state) },
    });
    return response.body!;
  }
}
----

=== MessageBus para Comunicação Entre Fragments

[source,typescript]
----
// packages/piercing/src/message-bus/message-bus.ts
export interface MessageBus {
  state: MessageBusState;
  dispatch(event: string, value: JSONValue): void;
  listen<T>(event: string, callback: (value: T) => void): () => void;
  latestValue<T>(event: string): T | undefined;
}

// Usage in fragments:
const bus = getBus();

// Listen for auth changes
bus.listen("auth", (user) => {
  console.log("User changed:", user);
});

// Dispatch navigation event
bus.dispatch("navigate", { path: "/deployments" });
----

== Plugin Dashboard (Shell)

O plugin dashboard fornece o shell que orquestra todos os plugins fragment.

=== Estrutura

[source]
----
plugins/plugin-dashboard/
├── package.json
├── src/
│   ├── index.ts           # Plugin entry
│   ├── server/
│   │   └── index.ts       # SSR shell
│   └── client/
│       ├── index.tsx      # Client entry
│       ├── components/
│       │   ├── layout.tsx # Main layout with outlets
│       │   └── nav.tsx    # Navigation (from plugin registry)
│       └── routes/
│           └── index.tsx  # Dashboard home
└── dist/
----

=== Layout do Shell com Outlets

[source,tsx]
----
// plugin-dashboard/src/client/components/layout.tsx
import { useNavigationItems } from "../hooks/use-navigation";

export function DashboardLayout({ children }: { children: React.ReactNode }) {
  const navItems = useNavigationItems(); // From MessageBus

  return (
    <div className="dashboard">
      <aside className="sidebar">
        <nav>
          {navItems.map((item) => (
            <NavLink key={item.path} to={item.path}>
              <Icon icon={item.icon} />
              {item.title}
            </NavLink>
          ))}
        </nav>
      </aside>

      <main className="content">
        {children}
      </main>
    </div>
  );
}
----

=== Rotas Dinâmicas de Fragment

[source,tsx]
----
// plugin-dashboard/src/client/routes/deployments.tsx
export function DeploymentsPage() {
  return (
    <DashboardLayout>
      {/* Fragment outlet - will load deployments fragment */}
      <fragment-outlet src="/deployments" base="/cpanel" />
    </DashboardLayout>
  );
}
----

== Integração com o Buntime Runner

=== Coleta de Fragments no Registry

[source,typescript]
----
// runtime/src/plugins/registry.ts
export class PluginRegistry {
  // ... existing methods ...

  /**
   * Get all plugins that have fragment UIs
   */
  getFragmentPlugins(): Array<{
    plugin: LoadedPlugin;
    config: FragmentConfig;
  }> {
    return this.plugins
      .filter((p) => p.fragment)
      .map((p) => ({
        plugin: p,
        config: {
          fragmentId: p.fragment!.fragmentId ?? this.getFragmentId(p.name),
          ...p.fragment!,
        },
      }));
  }

  /**
   * Get navigation items from all fragment plugins
   */
  getNavigationItems(): NavigationItem[] {
    return this.getFragmentPlugins()
      .filter((p) => p.config.navigation)
      .map((p) => p.config.navigation!)
      .sort((a, b) => (a.priority ?? 50) - (b.priority ?? 50));
  }

  private getFragmentId(pluginName: string): string {
    // @buntime/plugin-deployments -> deployments
    return pluginName.replace(/^@[^/]+\/plugin-/, "");
  }
}
----

=== Integração com App

[source,typescript]
----
// runtime/server/app.ts
import { FragmentGateway } from "@buntime/piercing";

export function createApp(deps: AppDeps) {
  const app = new Hono();

  // Create fragment gateway
  const gateway = new FragmentGateway({
    getShellHtml: async (req) => {
      // Fetch shell HTML from dashboard plugin
      const dashboardWorker = deps.pool.getOrCreate("dashboard");
      const res = await dashboardWorker.fetch(req);
      return res.text();
    },
    generateMessageBusState: async (state, req) => {
      // Add navigation items to bus state
      return {
        ...state,
        navigation: deps.registry.getNavigationItems(),
        theme: "system",
      };
    },
  });

  // Register all fragment plugins
  for (const { config } of deps.registry.getFragmentPlugins()) {
    gateway.registerFragment({
      ...config,
      ssrFetch: async (req) => {
        const worker = deps.pool.getOrCreate(config.fragmentId);
        return worker.fetch(req);
      },
    });
  }

  // Add fragment middleware
  app.use("*", gateway.middleware());

  // ... rest of app setup
}
----

== Candidatos a Novos Plugins

Com base na funcionalidade atual do runner, estes podem se tornar plugins fragment:

=== plugin-deployments

Atual: `runtime/client/routes/deployments/`

Funcionalidades:
- Navegador de arquivos
- Upload/download
- Gerenciamento de pastas
- Implantação de workers

=== plugin-metrics (extensão de UI)

Atual: Já é um plugin, mas a UI está no runner

Adicionar fragment ao plugin existente:
- Dashboard de estatísticas do pool
- Gráficos de métricas de workers
- Visualização de métricas Prometheus

=== plugin-logs

Novo plugin para logging centralizado:
- Streaming de logs em tempo real (SSE)
- Filtragem/busca de logs
- Retenção/exportação de logs

=== plugin-health

Novo plugin para monitoramento de saúde:
- Endpoints de health check
- Probes de liveness/readiness
- Dashboard de status de serviços

== Caminho de Migração

1. **Fase 1**: Criar pacote `@buntime/piercing` com componentes principais
2. **Fase 2**: Criar `plugin-dashboard` como orquestrador do shell
3. **Fase 3**: Extrair `plugin-deployments` do cliente do runner
4. **Fase 4**: Adicionar UI fragment ao `plugin-metrics`
5. **Fase 5**: Criar novos plugins (logs, health)

== Benefícios

- **Implantação Independente**: Atualizar UIs de plugins sem alterar o runner
- **Liberdade Tecnológica**: Cada plugin pode usar frameworks diferentes
- **Melhor DX**: Desenvolvedores de plugins são donos de toda sua stack
- **Lazy Loading**: Fragments carregam sob demanda
- **Performance SSR**: Renderização inicial rápida com streaming
- **Isolamento**: Bugs em fragments não derrubam o shell
