= Kubernetes / OKD
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

Buntime fornece um Helm chart para deployment em Kubernetes e OpenShift/OKD.

== Pré-requisitos

* Kubernetes 1.19+ ou OpenShift/OKD 4.x
* Helm 3.x
* CLI `kubectl` ou `oc`

== Início Rápido

[source,bash]
----
# Clone o repositório
git clone https://github.com/djalmajr/buntime.git
cd buntime

# Instale com Helm
helm install buntime charts/buntime
----

== Métodos de Instalação

=== NodePort (Padrão)

Ideal para testes locais e clusters de desenvolvimento:

[source,bash]
----
helm install buntime charts/buntime

# Obtenha a URL de acesso
export NODE_PORT=$(kubectl get svc buntime -o jsonpath='{.spec.ports[0].nodePort}')
export NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[0].address}')
echo http://$NODE_IP:$NODE_PORT
----

=== Ingress (Kubernetes)

Para produção com um Ingress controller:

[source,bash]
----
helm install buntime charts/buntime \
  --set ingress.enabled=true \
  --set ingress.className=nginx \
  --set ingress.host=buntime.example.com
----

Com TLS:

[source,bash]
----
helm install buntime charts/buntime \
  --set ingress.enabled=true \
  --set ingress.className=nginx \
  --set ingress.host=buntime.example.com \
  --set ingress.tls.enabled=true \
  --set ingress.tls.secretName=buntime-tls
----

Com prefixo de path (rewrite habilitado automaticamente):

[source,bash]
----
helm install buntime charts/buntime \
  --set ingress.enabled=true \
  --set ingress.className=nginx \
  --set ingress.host=example.com \
  --set ingress.path=/b
----

Com host wildcard e secret TLS existente:

[source,bash]
----
helm install buntime charts/buntime \
  --set ingress.enabled=true \
  --set ingress.className=nginx \
  --set 'ingress.host=*.cloud4biz.com' \
  --set ingress.path=/b \
  --set ingress.tls.enabled=true \
  --set ingress.tls.secretName=cert-cloud4biz
----

NOTE: Ao usar `ingress.path` com um valor diferente de `/`, o chart adiciona automaticamente anotações de rewrite do nginx para remover o prefixo antes de encaminhar para o backend.

=== Route (OpenShift/OKD)

Para ambientes OpenShift/OKD:

[source,bash]
----
helm install buntime charts/buntime \
  --set route.enabled=true \
  --set route.host=buntime.apps.mycluster.com
----

== Configuração

=== values.yaml

[source,yaml]
----
replicaCount: 1

image:
  repository: ghcr.io/djalmajr/buntime
  tag: latest
  pullPolicy: Always

nameOverride: ""
fullnameOverride: ""

service:
  type: NodePort
  port: 8000

# Kubernetes Ingress
ingress:
  enabled: false
  className: ""  # nginx, traefik, alb, etc
  host: ""
  path: "/"  # Use "/b" para roteamento baseado em path (auto-rewrite)
  annotations: {}
  tls:
    enabled: false
    secretName: ""  # auto-generated if empty

# OpenShift/OKD Route
route:
  enabled: false
  host: ""
  tls:
    enabled: true
    termination: edge  # edge, passthrough, reencrypt

# Configuração do Buntime
buntime:
  port: 8000
  poolSize: 100
  workerDirs: "/data/apps"
  pluginDirs: "/data/plugins"
  logLevel: "info"

# Persistent storage
persistence:
  plugins:
    enabled: true
    size: 5Gi
    accessMode: ReadWriteOnce
    storageClass: ""  # Use default if empty
  apps:
    enabled: true
    size: 10Gi
    accessMode: ReadWriteOnce
    storageClass: ""  # Use default if empty
----

=== Configurações Comuns

==== Deployment Básico

[source,bash]
----
helm install buntime charts/buntime \
  --set replicaCount=2 \
  --set buntime.poolSize=200
----

==== Desabilitar Persistência

[source,bash]
----
helm install buntime charts/buntime \
  --set persistence.plugins.enabled=false \
  --set persistence.apps.enabled=false
----

==== Imagem Personalizada

[source,bash]
----
helm install buntime charts/buntime \
  --set image.repository=myregistry.io/buntime \
  --set image.tag=v1.2.3
----

== Arquitetura

=== Recursos Criados

[cols="1,2"]
|===
| Recurso | Descrição

| Deployment
| Pods do Buntime com health probes

| Service
| ClusterIP/NodePort para acesso interno

| ConfigMap
| Variáveis de ambiente (PORT, POOL_SIZE, WORKER_DIRS, PLUGIN_DIRS)

| PersistentVolumeClaim (apps)
| Storage para aplicações worker (10Gi padrão)

| PersistentVolumeClaim (plugins)
| Storage para plugins externos (5Gi padrão)

| Ingress (opcional)
| Acesso HTTP/HTTPS externo

| Route (opcional)
| OpenShift Route para acesso externo
|===

=== Configuração do Pod

O deployment cria pods com:

* **Health Probes**: Verificações de liveness e readiness em `/api/plugins`
* **Env Vars**: Carregadas do ConfigMap via `envFrom`
* **PVC Mounts**: Apps e plugins em volumes persistentes

== Operações

=== Visualizar Logs

[source,bash]
----
kubectl logs -f deployment/buntime
----

=== Verificar Configuração

[source,bash]
----
# Visualizar ConfigMap de variáveis de ambiente
kubectl get configmap buntime -o yaml
----

=== Escalar

[source,bash]
----
kubectl scale deployment buntime --replicas=3
----

=== Atualizar

[source,bash]
----
helm upgrade buntime charts/buntime \
  --set image.tag=v2.0.0
----

=== Desinstalar

[source,bash]
----
helm uninstall buntime
----

== Deployment do LibSQL

Se estiver usando plugins de database, faça o deploy do LibSQL junto com o Buntime:

[source,yaml]
----
# libsql-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: libsql
spec:
  replicas: 1
  selector:
    matchLabels:
      app: libsql
  template:
    metadata:
      labels:
        app: libsql
    spec:
      containers:
        - name: libsql
          image: ghcr.io/tursodatabase/libsql-server:latest
          ports:
            - containerPort: 8080
          env:
            - name: SQLD_NODE
              value: primary
            - name: SQLD_DISABLE_AUTH
              value: "true"
          volumeMounts:
            - name: data
              mountPath: /var/lib/sqld
      volumes:
        - name: data
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: libsql
spec:
  selector:
    app: libsql
  ports:
    - port: 8080
      targetPort: 8080
----

Em seguida, instale o Buntime. Cada plugin tem seu próprio `manifest.jsonc` no PVC de plugins:

[source,bash]
----
helm install buntime charts/buntime
----

NOTE: O runtime é configurado via variáveis de ambiente (PORT, WORKER_DIRS, POOL_SIZE, etc). Cada plugin tem seu próprio `manifest.jsonc` no PVC de plugins (database, keyval, etc).

== Resolução de Problemas

=== Pod Não Inicia

Verifique os eventos:

[source,bash]
----
kubectl describe pod -l app=buntime
----

Problemas comuns:

* Erro ao baixar imagem: Verifique o repositório da imagem e credenciais
* Falhas no probe: Verifique se o endpoint `/api/plugins` funciona
* Erro de configuração: Verifique os ConfigMaps para configuração válida

=== Falhas ao Carregar Plugins

Verifique os logs para erros de plugins:

[source,bash]
----
kubectl logs -l app=buntime | grep -i plugin
----

=== Conexão Recusada

Verifique se o service está rodando:

[source,bash]
----
kubectl get svc buntime
kubectl get endpoints buntime
----

== Recomendações para Produção

=== Limites de Recursos

Adicione limites de recursos em produção:

[source,yaml]
----
# values-production.yaml
replicaCount: 3

buntime:
  poolSize: 500

# Adicione ao deployment manualmente ou estenda o chart
resources:
  limits:
    cpu: "2"
    memory: 1Gi
  requests:
    cpu: 500m
    memory: 256Mi
----

=== Alta Disponibilidade

[source,bash]
----
helm install buntime charts/buntime \
  --set replicaCount=3 \
  --set buntime.poolSize=200
----

=== Monitoramento

Configure o plugin de metrics e colete com Prometheus.

NOTE: O plugin `@buntime/plugin-metrics` precisa ter `enabled: true` em seu `manifest.jsonc` para expor métricas.

Prometheus ServiceMonitor (se estiver usando Prometheus Operator):

[source,yaml]
----
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: buntime
spec:
  selector:
    matchLabels:
      app: buntime
  endpoints:
    - port: http
      path: /api/metrics/prometheus
      interval: 30s
----
