== Rotas da API
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

O servidor Buntime expõe dois grupos principais de rotas: plugins info API e worker routes.

NOTE: APIs específicas de plugins (como Deployments, KeyVal, Metrics) estão documentadas nos respectivos READMEs dos plugins em `plugins/plugin-*/README.adoc`.

=== Plugins Info API

Retorna informações sobre todos os plugins carregados.

Base path: `/api/plugins`

==== GET /api/plugins

Lista todos os plugins carregados com suas configurações.

Exemplo:

[source,bash]
----
GET /api/plugins
----

Resposta:

[source,json]
----
[
  {
    "name": "@buntime/plugin-metrics",
    "base": "/metrics",
    "fragment": {
      "enabled": true,
      "type": "patch"
    },
    "menus": [
      {
        "title": "Metrics",
        "icon": "lucide:activity",
        "path": "/metrics",
        "priority": 5
      }
    ],
    "dependencies": [],
    "optionalDependencies": []
  },
  {
    "name": "@buntime/plugin-keyval",
    "base": "/keyval",
    "fragment": {
      "enabled": true,
      "type": "patch"
    },
    "menus": [
      {
        "title": "KeyVal",
        "icon": "lucide:database",
        "path": "/keyval",
        "priority": 80,
        "items": [
          { "title": "Overview", "icon": "lucide:home", "path": "/keyval" },
          { "title": "Entries", "icon": "lucide:list", "path": "/keyval/entries" }
        ]
      }
    ],
    "dependencies": ["@buntime/plugin-database"],
    "optionalDependencies": []
  },
  {
    "name": "@buntime/plugin-authn",
    "base": "/authn",
    "fragment": {
      "enabled": false
    },
    "menus": [],
    "dependencies": ["@buntime/plugin-database"],
    "optionalDependencies": []
  }
]
----

Estrutura de Plugin:

[cols="1,1,3"]
|===
| Campo | Tipo | Descrição

| `name`
| string
| Nome do plugin (package name)

| `base`
| string
| Base path das rotas do plugin

| `fragment.enabled`
| boolean
| Se o plugin tem interface visual

| `fragment.type`
| "patch" \| "iframe"
| Tipo de sandbox do fragment (opcional)

| `fragment.origin`
| string
| Origem para iframes (opcional)

| `fragment.preloadStyles`
| string
| CSS inline para injetar antes do load (opcional)

| `menus`
| MenuItem[]
| Items de navegação para sidebar

| `menus[].title`
| string
| Título do item de menu

| `menus[].icon`
| string
| Ícone (ex: `lucide:database`)

| `menus[].path`
| string
| Path de navegação

| `menus[].priority`
| number
| Prioridade de ordenação (menor = primeiro)

| `menus[].items`
| MenuItem[]
| Submenus aninhados (opcional)

| `dependencies`
| string[]
| Plugins obrigatórios

| `optionalDependencies`
| string[]
| Plugins opcionais
|===

=== Worker Routes

Roteamento dinâmico para aplicações worker. Suporta versionamento semântico e descoberta automática de apps.

==== Formato de Apps

O runtime suporta dois formatos de diretório:

Flat (app@version):

[source]
----
apps/
  my-app@1.0.0/
  my-app@1.0.1/
  my-app@2.0.0/
----

Nested (app/version):

[source]
----
apps/
  my-app/
    1.0.0/
    1.0.1/
    2.0.0/
----

==== Resolução de Versões

O runtime usa semver para encontrar a versão correta:

[cols="1,2,2"]
|===
| Request | Descrição | Resolve para

| `/my-app/*`
| Versão mais recente
| `2.0.0`

| `/my-app@1/*`
| Versão mais recente 1.x.x
| `1.0.1`

| `/my-app@1.0/*`
| Versão mais recente 1.0.x
| `1.0.1`

| `/my-app@1.0.0/*`
| Versão exata
| `1.0.0`

| `/my-app@^1.0.0/*`
| Range semver
| `1.0.1`

| `/my-app@latest/*`
| Tag especial latest
| Diretório `my-app@latest` ou `my-app/latest`
|===

NOTE: Quando nenhuma versão é especificada (`/my-app/*`), o runtime prefere `latest` se existir, caso contrário usa a maior versão semver.

==== Entrypoints

O runtime busca entrypoints nesta ordem de prioridade:

1. `index.html` (servido como SPA estático)
2. `index.ts` (worker JavaScript)
3. `index.js` (worker JavaScript)
4. `index.mjs` (worker JavaScript)

Entrypoints podem ser customizados em `buntime.jsonc`:

[source,json]
----
{
  "entrypoint": "server.ts"
}
----

==== ALL /:app/*

Roteia todas as requisições para uma aplicação worker.

Path Parameters:

[cols="1,1,3"]
|===
| Parâmetro | Tipo | Descrição

| `app`
| string
| Nome da aplicação com versão opcional
|===

Exemplos:

[source,bash]
----
# Versão mais recente
GET /my-app/users

# Versão específica
GET /my-app@1.0.0/users

# Range semver
GET /my-app@^1.0.0/users
----

Processo:

1. Verifica se é plugin app (rotas registradas por plugins)
2. Resolve versão nos workspaces usando semver
3. Carrega worker config (`buntime.jsonc`)
4. Encontra entrypoint (HTML ou TS/JS)
5. Cria/reutiliza worker do pool
6. Injeta header `x-base` com base path (`/my-app`)
7. Encaminha requisição

Headers Especiais:

[cols="1,3"]
|===
| Header | Descrição

| `x-base`
| Base path injetado pelo runtime (ex: `/my-app`)
|===

Resposta:

- Depende da aplicação worker
- Para SPAs (index.html): serve assets estáticos e fallback para index.html

==== GET /*

Rota fallback para a raiz (quando nenhuma outra rota corresponde).

Comportamento:

- Se `homepage` está configurado no runtime: roteia para app homepage
- Caso contrário: retorna texto `"Buntime v{version}"`

Exemplo com homepage:

[source,bash]
----
GET /
# Redireciona para homepage app configurado
----

Exemplo sem homepage:

[source,bash]
----
GET /
# Retorna: "Buntime v1.0.0"
----

==== Plugin Routes

Plugins registram rotas Hono no path base definido. Exemplo real do plugin-keyval:

[source,typescript]
----
// plugins/plugin-keyval/plugin.ts
export default function keyvalExtension(config: KeyValConfig = {}): BuntimePlugin {
  return {
    name: "@buntime/plugin-keyval",
    base: config.base ?? "/keyval",
    dependencies: ["@buntime/plugin-database"],
    routes: api,

    fragment: {
      type: "patch",
    },

    menus: [
      {
        icon: "lucide:database",
        path: "/keyval",
        priority: 80,
        title: "KeyVal",
        items: [
          { icon: "lucide:home", path: "/keyval", title: "Overview" },
          { icon: "lucide:list", path: "/keyval/entries", title: "Entries" },
        ],
      },
    ],

    async onInit(ctx: PluginContext) {
      const database = ctx.getService<DatabaseService>("database");
      const kv = await initialize(database, { ... }, ctx.logger);
      ctx.registerService("kv", kv);
    },

    async onShutdown() {
      await shutdown();
    },
  };
}
----

Propriedades do `BuntimePlugin` (conforme `packages/shared/src/types/plugin.ts`):

[cols="1,1,3"]
|===
| Propriedade | Tipo | Descrição

| `name`
| string
| Nome único do plugin (ex: `@buntime/plugin-keyval`)

| `base`
| string
| Path base para montar as rotas (ex: `/keyval`)

| `dependencies`
| string[]
| Plugins obrigatórios que devem ser carregados antes

| `optionalDependencies`
| string[]
| Plugins opcionais carregados antes se disponíveis

| `routes`
| Hono
| App Hono montado em `/{base}/*`

| `middleware`
| MiddlewareHandler
| Alternativa ao `onRequest` como middleware Hono

| `server`
| PluginServer
| Rotas para `Bun.serve({ routes })` e fetch handler

| `fragment`
| FragmentOptions
| Configuração de sandbox (`patch` ou `iframe`)

| `menus`
| MenuItem[]
| Items de menu com suporte a nested via `items`
|===

Lifecycle hooks:

[cols="1,2"]
|===
| Hook | Descrição

| `onInit(ctx)`
| Chamado na inicialização, recebe `PluginContext`

| `onShutdown()`
| Chamado no shutdown do buntime

| `onServerStart(server)`
| Chamado após `Bun.serve()`, recebe instância do servidor

| `onRequest(req, app?)`
| Intercepta requisições antes do worker

| `onResponse(res, app)`
| Modifica response antes de enviar ao cliente

| `onWorkerSpawn(worker, app)`
| Chamado quando worker é criado

| `onWorkerTerminate(worker, app)`
| Chamado quando worker é terminado
|===

=== Arquitetura de Roteamento

Ordem de resolução de rotas (conforme implementado em `app.ts`):

1. **CSRF Protection** - Validação de Origin para requisições state-changing (POST, PUT, PATCH, DELETE)
2. **Plugin onRequest Hooks** - Executa hooks de autenticação e pré-processamento
3. **App-Shell Mode** - Intercepta navegação para shell se configurado (ver <<shell-routing>>)
4. **Plugins Info API** - `/api/plugins` (informações sobre plugins carregados)
5. **Plugin server.fetch** - Handlers de requisição de plugins com `server.fetch`
6. **Plugin Routes** - Rotas Hono montadas por plugins (ex: `/keyval/*`, `/metrics/*`)
7. **Plugin Apps** - Apps de plugins servidos via worker pool (fragmentos)
8. **Worker Routes** - Apps nos workspaces (ex: `/my-app/*`)
9. **404 with Shell** - Fallback para shell exibir página 404 consistente

NOTE: A ordem de prioridade garante que rotas mais específicas (plugins) sejam resolvidas antes de rotas genéricas (workers). Plugin Routes são ordenados por especificidade (paths mais longos primeiro).

[[shell-routing]]
==== Lógica de Shell Routing

A função `shouldRouteToShell()` determina se uma requisição deve ser interceptada pelo app-shell:

[cols="1,2"]
|===
| Condição | Comportamento

| `Sec-Fetch-Mode !== "navigate"`
| Rejeita - requests não-navegação (fetch, XMLHttpRequest) não são interceptados

| Path contém `/api/`
| Rejeita - rotas de API nunca vão para o shell

| Path é `/` ou vazio
| Aceita - homepage sempre vai para o shell

| Path corresponde a base de plugin
| Aceita - ex: `/metrics`, `/keyval/entries`
|===

O shell routing executa **após** os hooks `onRequest` dos plugins, permitindo que autenticação seja processada antes da decisão de roteamento.

==== Fallback para Homepage

Quando uma worker route retorna 404 e existe uma homepage configurada em modo inline (`base` definido), o runtime tenta servir o recurso a partir do app homepage:

[source]
----
GET /unknown-app/chunk-abc.js
  1. Worker route retorna 404
  2. Se homepage = { app: "/cpanel", base: "/" }
  3. Tenta buscar /cpanel/chunk-abc.js
  4. Se encontrado, retorna o asset
----

Isso permite que SPAs servidas na raiz carreguem assets corretamente mesmo quando acessadas por paths que não correspondem a apps específicos.

=== Formato de Erros

Plugins retornam erros no formato:

[source,json]
----
{
  "error": "Mensagem de erro legível",
  "code": "ERROR_CODE"
}
----

NOTE: Consulte a documentação de cada plugin (`plugins/plugin-*/README.adoc`) para os códigos de erro específicos.
