== Sistema de Plugins
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

=== Visão Geral

O sistema de plugins do Buntime permite extensibilidade modular do runtime através de componentes reutilizáveis. Plugins podem interceptar requests, modificar responses, fornecer APIs próprias, gerenciar workers e integrar-se ao ciclo de vida do servidor.

*Características Principais*:

* **Lifecycle Hooks**: Interceptação em diferentes estágios do request/response
* **Dependency Management**: Resolução automática de dependências entre plugins
* **Topological Ordering**: Execução ordenada baseada em dependências (via sort topológico)
* **Service Registry**: Compartilhamento de serviços entre plugins
* **Fragment Support**: Plugins podem fornecer UI embeddable no shell

=== Arquitetura

==== Componentes

[mermaid]
----
flowchart TD
    subgraph config["buntime.jsonc"]
        C1["plugins: [<br/>  '@buntime/plugin-metrics',<br/>  ['@buntime/plugin-authn', {...}]<br/>]"]
    end

    subgraph loader["PluginLoader"]
        L1["Parse configuration (Babel-style)"]
        L2["Resolve modules (builtin/external/npm)"]
        L3["Topological sort by dependencies"]
        L4["Initialize plugins in order"]
    end

    subgraph registry["PluginRegistry"]
        R1["Store loaded plugins"]
        R2["Run lifecycle hooks"]
        R3["Service registry"]
        R4["Route resolution"]
        R5["Public routes management"]
    end

    config --> loader
    loader --> registry

    registry --> Metrics["Metrics<br/>onRequest"]
    registry --> AuthN["AuthN<br/>onRequest"]
    registry --> Gateway["Gateway<br/>onRequest"]
    registry --> KeyVal["KeyVal<br/>routes"]
----

==== Resolução de Plugins

O `PluginLoader` resolve plugins em três estágios:

*1. Built-in Plugins (Embedded)*:

Plugins compilados no binário, sempre disponíveis. Todos usam lazy loading para comportamento consistente e evitar problemas de bundling com binários compilados:

[source,typescript]
----
const plugins: Record<string, () => Promise<PluginFactory>> = {
  "@buntime/plugin-authn": async () => (await import("@buntime/plugin-authn")).default,
  "@buntime/plugin-authz": async () => (await import("@buntime/plugin-authz")).default,
  "@buntime/plugin-database": async () => (await import("@buntime/plugin-database")).default,
  "@buntime/plugin-deployments": async () => (await import("@buntime/plugin-deployments")).default,
  "@buntime/plugin-durable": async () => (await import("@buntime/plugin-durable")).default,
  "@buntime/plugin-gateway": async () => (await import("@buntime/plugin-gateway")).default,
  "@buntime/plugin-keyval": async () => (await import("@buntime/plugin-keyval")).default,
  "@buntime/plugin-metrics": async () => (await import("@buntime/plugin-metrics")).default,
  "@buntime/plugin-proxy": async () => (await import("@buntime/plugin-proxy")).default,
};
----

Lista completa de plugins builtin: authn, authz, database, deployments, durable, gateway, keyval, metrics, proxy.

*2. External Plugins (./plugins/)*:

Plugins locais no diretório `./plugins/`:

[source]
----
./plugins/
├── custom-auth.ts              # ./plugins/custom-auth.ts
└── company-metrics/
    └── index.ts                # ./plugins/company-metrics/index.ts
----

*3. Node Modules (Dev/Bundle Mode)*:

Plugins instalados via npm:

[source,bash]
----
bun add @company/buntime-plugin-sso
----

==== Topological Sorting

Plugins são carregados em ordem baseada em dependências usando o algoritmo de Kahn:

[source,typescript]
----
// Configuração
{
  "plugins": [
    "@buntime/plugin-keyval",     // dependencies: ["@buntime/plugin-database"]
    "@buntime/plugin-authn",      // dependencies: []
    "@buntime/plugin-database"    // dependencies: []
  ]
}

// Ordem de carregamento (após sort)
1. @buntime/plugin-database   (sem dependências)
2. @buntime/plugin-keyval     (depende de database)
3. @buntime/plugin-authn      (sem dependências)
----

*Tipos de Dependências*:

* **dependencies**: Obrigatórias, falha se não configurado
* **optionalDependencies**: Opcionais, carregadas se disponível

[source,typescript]
----
export default function createPlugin(): BuntimePlugin {
  return {
    name: "@buntime/plugin-keyval",
    dependencies: ["@buntime/plugin-database"],  // Obrigatório
    optionalDependencies: ["@buntime/plugin-metrics"],  // Opcional
    // ...
  };
}
----

=== Lifecycle Hooks

==== onInit

Chamado quando o plugin é inicializado, antes do servidor iniciar.

*Assinatura*:

[source,typescript]
----
onInit?: (ctx: PluginContext) => Promise<void> | void;
----

*Context*:

[source,typescript]
----
interface PluginContext {
  config: Record<string, unknown>;        // Configuração do plugin
  globalConfig: GlobalPluginConfig;       // buntime.jsonc (workspaces, poolSize)
  logger: PluginLogger;                   // Logger com contexto do plugin
  pool?: unknown;                         // WorkerPool instance
  registerService<T>(name: string, service: T): void;
  getService<T>(name: string): T | undefined;
}
----

*Timeout de Inicialização*:

O hook `onInit` possui um timeout de 30 segundos. Se a inicialização não completar nesse período, o plugin falha com erro de timeout. Isso previne que plugins mal configurados bloqueiem a inicialização do servidor indefinidamente.

*Exemplo*:

[source,typescript]
----
export default function createPlugin(config: KeyValConfig): BuntimePlugin {
  let db: DatabaseAdapter;
  let kv: Kv;

  return {
    name: "@buntime/plugin-keyval",
    dependencies: ["@buntime/plugin-database"],

    async onInit(ctx) {
      // Obter serviço de outro plugin
      db = ctx.getService<DatabaseAdapter>("database")!;

      // Inicializar KV
      kv = new Kv({ db, logger: ctx.logger });
      await kv.init();

      // Registrar serviço para outros plugins
      ctx.registerService("kv", kv);

      ctx.logger.info("KeyVal initialized");
    },
  };
}
----

==== Validação de Segurança

O `PluginLoader` valida plugins durante o carregamento para prevenir problemas de segurança.

*Validação de Base Path*:

O base path deve seguir o padrão `/[a-zA-Z0-9_-]+`:

[source,typescript]
----
// Válidos
"/metrics"
"/my-plugin"
"/auth_v2"

// Inválidos (causam erro)
"/my/nested/path"    // Múltiplos segmentos
"/../escape"         // Path traversal
"/my plugin"         // Espaços
----

*Paths Reservados*:

Os seguintes paths são reservados pelo runtime e não podem ser usados por plugins:

- `/api` - Rotas internas da API do runtime
- `/health` - Endpoint de health check
- `/.well-known` - Recursos padrão web (ACME, etc.)

Tentativas de usar paths reservados resultam em erro durante o carregamento:

[source]
----
Error: Plugin "@company/my-plugin" cannot use reserved path "/api".
Reserved paths: /api, /health, /.well-known
----

==== onRequest

Chamado para cada request antes de chegar ao worker.

*Assinatura*:

[source,typescript]
----
onRequest?: (
  req: Request,
  app?: AppInfo
) => Promise<Request | Response | undefined> | Request | Response | undefined;
----

*Retornos Possíveis*:

* **Request**: Request modificado (continua pipeline)
* **Response**: Short-circuit (retorna imediatamente)
* **undefined**: Continua com request original

*Exemplo (AuthN)*:

[source,typescript]
----
async onRequest(req: Request, app?: AppInfo) {
  const authHeader = req.headers.get("Authorization");

  if (!authHeader) {
    return new Response("Unauthorized", { status: 401 });
  }

  // Validar token
  const user = await validateToken(authHeader);

  if (!user) {
    return new Response("Invalid token", { status: 401 });
  }

  // Injetar usuário no request
  const newReq = new Request(req, {
    headers: {
      ...Object.fromEntries(req.headers),
      "x-user-id": user.id,
      "x-user-email": user.email,
    },
  });

  return newReq;
}
----

*Ordem de Execução*:

Plugins executam onRequest em ordem de registro (após sort topológico):

[mermaid]
----
flowchart TD
    Request --> Metrics["Metrics.onRequest<br/>(coleta métricas)"]
    Metrics --> Proxy["Proxy.onRequest<br/>(pode short-circuit)"]
    Proxy --> AuthN["AuthN.onRequest<br/>(injeta identidade)"]
    AuthN --> Gateway["Gateway.onRequest<br/>(rate limit)"]
    Gateway --> Worker["Worker.fetch"]
----

==== onResponse

Chamado após o worker gerar a response, antes de enviar ao cliente.

*Assinatura*:

[source,typescript]
----
onResponse?: (res: Response, app: AppInfo) => Promise<Response> | Response;
----

*Exemplo (Metrics)*:

[source,typescript]
----
async onResponse(res: Response, app: AppInfo) {
  const duration = performance.now() - startTime;

  metrics.recordRequest({
    app: app.name,
    status: res.status,
    duration,
    method: req.method,
  });

  return res;  // Retorna response inalterado
}
----

==== onWorkerSpawn

Chamado quando um worker é criado.

*Assinatura*:

[source,typescript]
----
onWorkerSpawn?: (worker: WorkerInstance, app: AppInfo) => void;
----

*Exemplo*:

[source,typescript]
----
onWorkerSpawn(worker, app) {
  logger.info(`Worker spawned: ${worker.id} for ${app.name}`);

  // Registrar worker em sistema de monitoramento
  monitoring.registerWorker(worker.id, app.name);
}
----

==== onWorkerTerminate

Chamado quando um worker é terminado.

*Assinatura*:

[source,typescript]
----
onWorkerTerminate?: (worker: WorkerInstance, app: AppInfo) => void;
----

*Exemplo*:

[source,typescript]
----
onWorkerTerminate(worker, app) {
  logger.info(`Worker terminated: ${worker.id} (${worker.stats.requestCount} requests)`);

  monitoring.unregisterWorker(worker.id);
}
----

==== onServerStart

Chamado após o `Bun.serve()` iniciar.

*Assinatura*:

[source,typescript]
----
onServerStart?: (server: Server<unknown>) => void;
----

*Uso*: Acesso ao server instance para WebSocket upgrades.

*Exemplo*:

[source,typescript]
----
let server: Server;

export default function createPlugin(): BuntimePlugin {
  return {
    name: "@buntime/plugin-metrics",

    onServerStart(srv) {
      server = srv;
      logger.info(`Server started on port ${server.port}`);
    },

    websocket: {
      open(ws) {
        logger.info("WebSocket connected");
      },
    },
  };
}
----

==== onShutdown

Chamado quando o runtime está sendo encerrado.

*Assinatura*:

[source,typescript]
----
onShutdown?: () => Promise<void> | void;
----

*Ordem*: Plugins executam shutdown em ordem reversa (LIFO).

*Exemplo*:

[source,typescript]
----
async onShutdown() {
  logger.info("Shutting down KeyVal plugin");

  // Flush métricas pendentes
  await metrics.flush();

  // Fechar conexões DB
  await db.close();

  logger.info("KeyVal shutdown complete");
}
----

=== Public Routes

Plugins e workers podem definir rotas públicas que pulam hooks `onRequest` (ex: autenticação).

==== Formato de Configuração

*Array (todos métodos)*:

[source,typescript]
----
publicRoutes: ["/health", "/api/public/**"]
----

*Object (por método HTTP)*:

[source,typescript]
----
publicRoutes: {
  ALL: ["/health"],
  GET: ["/api/users/**"],
  POST: ["/api/webhook"]
}
----

==== Wildcards

* **\*** - Match um segmento: `/api/*/health`
* **\**** - Match múltiplos segmentos: `/api/**`

==== Plugin vs Worker Public Routes

*Plugin Public Routes*:

Paths absolutos, configuráveis em `buntime.jsonc`:

[source,jsonc]
----
{
  "plugins": [
    ["@buntime/plugin-authn", {
      "publicRoutes": {
        "ALL": ["/health"],
        "POST": ["/api/authn/login", "/api/authn/register"]
      }
    }]
  ]
}
----

*Worker Public Routes*:

Paths relativos ao worker, configuráveis em `buntime.jsonc`:

[source,jsonc]
----
{
  "publicRoutes": {
    "GET": ["/api/health", "/api/public/**"]
  }
}
----

Transformados em paths absolutos pelo runtime:

[source]
----
Worker: todos-kv
Base: /todos-kv

/api/health  →  /todos-kv/api/health
/api/public/** → /todos-kv/api/public/**
----

==== Merge de Public Routes

Config routes são adicionadas às routes do plugin:

[source,typescript]
----
// Plugin define
publicRoutes: {
  POST: ["/api/authn/login"]
}

// Config adiciona
publicRoutes: {
  POST: ["/api/authn/register"]
}

// Resultado final
publicRoutes: {
  POST: ["/api/authn/login", "/api/authn/register"]
}
----

=== Service Registry

Plugins podem registrar serviços para compartilhar funcionalidades.

==== Registrando um Serviço

[source,typescript]
----
async onInit(ctx) {
  const db = await createDatabase(ctx.config);

  // Registrar serviço
  ctx.registerService("database", db);

  ctx.logger.info("Database service registered");
}
----

==== Consumindo um Serviço

[source,typescript]
----
async onInit(ctx) {
  // Obter serviço de outro plugin
  const db = ctx.getService<DatabaseAdapter>("database");

  if (!db) {
    throw new Error("Database service not available");
  }

  // Usar serviço
  const kv = new Kv({ db });
}
----

==== Exemplo Completo

[source,typescript]
----
// Plugin Database
export default function createDatabase(config: DbConfig): BuntimePlugin {
  let adapter: DatabaseAdapter;

  return {
    name: "@buntime/plugin-database",

    async onInit(ctx) {
      adapter = new DatabaseAdapter(config.libsqlUrl);
      await adapter.connect();

      // Registrar serviço
      ctx.registerService("database", adapter);
    },

    async onShutdown() {
      await adapter.close();
    },
  };
}

// Plugin KeyVal
export default function createKeyVal(): BuntimePlugin {
  let kv: Kv;

  return {
    name: "@buntime/plugin-keyval",
    dependencies: ["@buntime/plugin-database"],

    async onInit(ctx) {
      // Consumir serviço
      const db = ctx.getService<DatabaseAdapter>("database")!;
      kv = new Kv({ db });

      // Registrar próprio serviço
      ctx.registerService("kv", kv);
    },
  };
}
----

=== Registry Methods

A classe `PluginRegistry` gerencia plugins carregados e orquestra a execução de lifecycle hooks. A tabela abaixo documenta os métodos públicos disponíveis.

==== Métodos de Lifecycle

[cols="2,3"]
|===
| Método | Descrição

| `runOnRequest(req: Request, app?: AppInfo): Promise<Request \| Response>`
| Executa todos os hooks `onRequest` em ordem de registro. Retorna o request modificado ou uma response para short-circuit. Se um plugin retornar `Response`, a execução para imediatamente.

| `runOnResponse(res: Response, app: AppInfo): Promise<Response>`
| Executa todos os hooks `onResponse` em ordem de registro. Cada plugin pode modificar a response antes de enviar ao cliente.

| `runOnServerStart(server: Server<unknown>): void`
| Notifica todos os plugins quando o servidor inicia via `Bun.serve()`. Plugins podem armazenar a referência do server para WebSocket upgrades.

| `runOnShutdown(): Promise<void>`
| Executa hooks de shutdown em ordem reversa (LIFO). Plugins carregados por último são encerrados primeiro, garantindo que dependências ainda estejam disponíveis durante cleanup.

| `runOnWorkerSpawn(worker: WorkerInstance, app: AppInfo): void`
| Chamado quando um novo worker é criado. Plugins podem registrar o worker em sistemas de monitoramento ou inicializar recursos específicos.

| `runOnWorkerTerminate(worker: WorkerInstance, app: AppInfo): void`
| Chamado quando um worker é terminado. Plugins podem coletar métricas finais ou limpar recursos associados ao worker.
|===

==== Métodos de Resolução

[cols="2,3"]
|===
| Método | Descrição

| `getPluginBasePaths(): Set<string>`
| Retorna um `Set` com todos os base paths dos plugins registrados. Usado pelo app-shell para determinar quais paths devem ser interceptados.

| `resolvePluginApp(pathname: string): { dir: string; basePath: string } \| undefined`
| Resolve um pathname para o diretório e base path do plugin correspondente. Retorna `undefined` se nenhum plugin corresponder ao path.

| `collectServerRoutes(): Record<string, RouteHandler>`
| Coleta todas as rotas definidas em `server.routes` de cada plugin e aplica wrapper de autenticação. O resultado é usado diretamente em `Bun.serve({ routes })`.
|===

==== Métodos de Serviço

[cols="2,3"]
|===
| Método | Descrição

| `registerService<T>(name: string, service: T): void`
| Registra um serviço para compartilhamento entre plugins. Se um serviço com o mesmo nome já existir, emite um warning e sobrescreve.

| `getService<T>(name: string): T \| undefined`
| Recupera um serviço registrado por outro plugin. Retorna `undefined` se o serviço não existir.
|===

==== Métodos de Acesso

[cols="2,3"]
|===
| Método | Descrição

| `get(name: string): BuntimePlugin \| undefined`
| Retorna um plugin pelo nome.

| `getAll(): BuntimePlugin[]`
| Retorna todos os plugins em ordem de registro (após ordenação topológica).

| `has(name: string): boolean`
| Verifica se um plugin está registrado.

| `size: number`
| Propriedade que retorna o número de plugins registrados.

| `getPluginDir(name: string): string \| undefined`
| Retorna o diretório de um plugin (usado para spawning de workers).

| `getPluginsWithServerFetch(): BuntimePlugin[]`
| Retorna plugins que possuem `server.fetch` handlers.

| `getWebSocketHandler(): WebSocketHandler \| undefined`
| Retorna handler WebSocket combinado de todos os plugins. Se múltiplos plugins definem handlers, eles são combinados em um único handler.

| `getMountedPaths(): Map<string, string>`
| Retorna um `Map` com paths montados e seus plugins correspondentes. Usado para detecção de conflitos de rotas.

| `setMountedPaths(paths: Map<string, string>): void`
| Define os paths montados para detecção de conflitos. O mapa relaciona path com nome do plugin.
|===

==== Exemplo de Uso

[source,typescript]
----
// Obtendo o registry do loader
const registry = loader.getRegistry();

// Verificar plugins carregados
console.log("Total:", registry.size);
console.log("Plugins:", registry.getAll().map((p) => p.name));

// Verificar base paths para routing
const bases = registry.getPluginBasePaths();
console.log("Plugin bases:", [...bases]);

// Resolver um path para plugin
const result = registry.resolvePluginApp("/keyval/api/entries");
if (result) {
  console.log("Plugin dir:", result.dir);
  console.log("Base path:", result.basePath);
}

// Obter serviço registrado por outro plugin
const kv = registry.getService<Kv>("kv");
----

=== Plugin Server Module

Plugins podem servir arquivos estáticos e APIs diretamente no processo principal via `server.routes` e `server.fetch`.

==== Server Routes

Routes são mapeadas para `Bun.serve({ routes })` com wrapper de autenticação.

[source,typescript]
----
export default function createPlugin(): BuntimePlugin {
  return {
    name: "@buntime/plugin-authn",

    server: {
      routes: {
        // Arquivo estático
        "/login": Bun.file("./public/login.html"),

        // Handler function
        "/api/health/*": () => new Response("OK"),

        // Handler async
        "/api/user": async (req) => {
          const user = await getUser(req);
          return Response.json(user);
        },
      },
    },

    publicRoutes: {
      GET: ["/login", "/api/health/**"],
    },
  };
}
----

==== Server Fetch

Handler invocado após routes não matcharem, antes de routes Hono.

[source,typescript]
----
export default function createPlugin(): BuntimePlugin {
  const app = new Hono();

  app.get("/api/users", (c) => c.json({ users: [] }));

  return {
    name: "@buntime/plugin-api",

    server: {
      fetch: app.fetch,
    },
  };
}
----

==== Ordem de Resolução

[mermaid]
----
flowchart TD
    Request --> BunRoutes{"Bun.serve routes<br/>(server.routes de todos plugins)"}
    BunRoutes --> Login["/login (plugin-authn)"]
    BunRoutes --> Health["/api/health/* (plugin-authn)"]
    BunRoutes -->|no match| ServerFetch{"server.fetch<br/>(de cada plugin em ordem)"}

    ServerFetch --> AuthnFetch["plugin-authn.server.fetch"]
    ServerFetch --> KeyvalFetch["plugin-keyval.server.fetch"]
    ServerFetch --> GatewayFetch["plugin-gateway.server.fetch"]
    ServerFetch -->|no match| HonoRoutes{"Hono app.routes<br/>(agregação de todos plugin.routes)"}

    HonoRoutes --> KeyvalAPI["/api/keyval/* (plugin-keyval)"]
    HonoRoutes --> MetricsAPI["/api/metrics/* (plugin-metrics)"]
----

==== Middleware

Alternativa ao `onRequest` usando o padrão de middleware do Hono. O middleware é executado no contexto da aplicação Hono principal.

*Assinatura*:

[source,typescript]
----
middleware?: MiddlewareHandler;
----

*Exemplo*:

[source,typescript]
----
import { createMiddleware } from "hono/factory";
import type { BuntimePlugin } from "@buntime/shared/types";

export default function createPlugin(): BuntimePlugin {
  return {
    name: "@company/request-logger",
    base: "/logger",

    middleware: createMiddleware(async (c, next) => {
      const start = Date.now();
      await next();
      const duration = Date.now() - start;
      console.log(`${c.req.method} ${c.req.path} - ${duration}ms`);
    }),
  };
}
----

*Diferença entre middleware e onRequest*:

[cols="1,2,2"]
|===
| Aspecto | middleware | onRequest

| Contexto
| Hono Context (c)
| Request + AppInfo

| Retorno
| Chama next() para continuar
| Retorna Request, Response ou undefined

| Posicionamento
| Executado dentro do Hono app
| Executado antes do Hono app
|===

=== Fragment Support

Plugins podem fornecer UI embeddable no shell (C-Panel) via `fragment`.

==== Fragment Options

[source,typescript]
----
interface FragmentOptions {
  type: "patch" | "iframe";
  origin?: string;              // Obrigatório para iframe
  preloadStyles?: string;       // CSS para reduzir flash
}
----

==== Tipos de Fragment

*Patch (Recomendado)*:

Intercepta History API, previne mudanças de URL. Ideal para plugins internos.

[source,typescript]
----
export default function createPlugin(): BuntimePlugin {
  return {
    name: "@buntime/plugin-keyval",
    base: "/keyval",

    fragment: {
      type: "patch",
    },

    menus: [
      { title: "KeyVal", icon: "lucide:database", path: "/keyval" },
    ],
  };
}
----

*Iframe (Full Isolation)*:

Carrega app externo em iframe com isolamento completo. Ideal para aplicações de terceiros não confiáveis.

[source,typescript]
----
fragment: {
  type: "iframe",
  origin: "https://external-app.company.com",
}
----

*Comparação dos Tipos*:

[cols="1,1,1,1"]
|===
| Tipo | Isolamento | Compartilha Estilos | Caso de Uso

| patch
| Baixo
| Sim
| Plugins internos

| iframe
| Alto
| Não
| Apps não confiáveis
|===

NOTE: A propriedade `origin` é obrigatória para o tipo `iframe`.

==== Menu Items

Plugins definem items de menu para navegação no shell.

[source,typescript]
----
menus: [
  {
    title: "Logs",
    icon: "lucide:scroll-text",
    path: "/logs",
    priority: 10,
  },
  {
    title: "Reports",
    icon: "lucide:file-text",
    path: "/reports",
    items: [
      { title: "Daily", icon: "lucide:calendar", path: "/reports/daily" },
      { title: "Monthly", icon: "lucide:calendar-range", path: "/reports/monthly" },
    ],
  },
]
----

=== Criando um Plugin Customizado

==== Estrutura Básica

[source,typescript]
----
import type { BuntimePlugin, PluginContext } from "@buntime/shared/types";

export default function createMyPlugin(config: MyPluginConfig): BuntimePlugin {
  return {
    name: "@company/my-plugin",

    async onInit(ctx) {
      ctx.logger.info("Plugin initialized", { config: ctx.config });
    },

    async onRequest(req, app) {
      ctx.logger.debug("Request received", { url: req.url });
      return req;  // Continue pipeline
    },

    async onShutdown() {
      ctx.logger.info("Plugin shutdown");
    },
  };
}
----

==== Factory Function

Plugins são factory functions que recebem configuração e retornam `BuntimePlugin`.

*Formato*:

[source,typescript]
----
export type PluginFactory = (
  config?: Record<string, unknown>
) => BuntimePlugin | Promise<BuntimePlugin>;
----

*Exemplos*:

[source,typescript]
----
// Sync factory
export default function createPlugin(config: MyConfig): BuntimePlugin {
  return { name: "my-plugin", /* ... */ };
}

// Async factory
export default async function createPlugin(config: MyConfig): Promise<BuntimePlugin> {
  const db = await initializeDb(config);
  return { name: "my-plugin", /* ... */ };
}

// Default export
export default function createPlugin(config: MyConfig) {
  return { name: "my-plugin", /* ... */ };
}
----

==== Exemplo Completo: Rate Limiter

[source,typescript]
----
import type { BuntimePlugin, PluginContext } from "@buntime/shared/types";

interface RateLimitConfig {
  maxRequests: number;
  windowMs: number;
}

interface RateLimitEntry {
  count: number;
  resetAt: number;
}

export default function createRateLimiter(config: RateLimitConfig): BuntimePlugin {
  const limits = new Map<string, RateLimitEntry>();
  const defaultConfig = { maxRequests: 100, windowMs: 60000 };
  const cfg = { ...defaultConfig, ...config };

  function getClientKey(req: Request): string {
    const forwarded = req.headers.get("x-forwarded-for");
    const ip = forwarded ? forwarded.split(",")[0] : "unknown";
    return ip || "unknown";
  }

  function checkRateLimit(key: string): boolean {
    const now = Date.now();
    const entry = limits.get(key);

    if (!entry || now > entry.resetAt) {
      limits.set(key, {
        count: 1,
        resetAt: now + cfg.windowMs,
      });
      return true;
    }

    if (entry.count >= cfg.maxRequests) {
      return false;
    }

    entry.count++;
    return true;
  }

  return {
    name: "@company/rate-limiter",

    async onInit(ctx: PluginContext) {
      ctx.logger.info("Rate limiter initialized", {
        maxRequests: cfg.maxRequests,
        windowMs: cfg.windowMs,
      });

      // Cleanup expired entries every minute
      setInterval(() => {
        const now = Date.now();
        for (const [key, entry] of limits.entries()) {
          if (now > entry.resetAt) {
            limits.delete(key);
          }
        }
      }, 60000);
    },

    async onRequest(req: Request) {
      const key = getClientKey(req);
      const allowed = checkRateLimit(key);

      if (!allowed) {
        return new Response("Too Many Requests", {
          status: 429,
          headers: {
            "Retry-After": String(Math.ceil(cfg.windowMs / 1000)),
          },
        });
      }

      return req;
    },
  };
}
----

*Configuração*:

[source,jsonc]
----
{
  "plugins": [
    ["@company/rate-limiter", {
      "maxRequests": 1000,
      "windowMs": 60000
    }]
  ]
}
----

==== Exemplo Completo: Custom Logger

[source,typescript]
----
import { Hono } from "hono";
import type { BuntimePlugin, PluginContext } from "@buntime/shared/types";

interface LogEntry {
  timestamp: string;
  level: string;
  message: string;
  meta?: Record<string, unknown>;
}

export default function createCustomLogger(): BuntimePlugin {
  const logs: LogEntry[] = [];
  const maxLogs = 1000;

  function addLog(level: string, message: string, meta?: Record<string, unknown>) {
    logs.push({
      timestamp: new Date().toISOString(),
      level,
      message,
      meta,
    });

    // Keep only last maxLogs entries
    if (logs.length > maxLogs) {
      logs.shift();
    }
  }

  const app = new Hono();

  // API para obter logs
  app.get("/api/logs", (c) => {
    const level = c.req.query("level");
    const limit = Number(c.req.query("limit")) || 100;

    let filtered = logs;
    if (level) {
      filtered = logs.filter((log) => log.level === level);
    }

    return c.json({
      logs: filtered.slice(-limit),
      total: filtered.length,
    });
  });

  return {
    name: "@company/custom-logger",
    base: "/logs",

    routes: app,

    fragment: {
      type: "patch",
    },

    menus: [
      {
        title: "Logs",
        icon: "lucide:scroll-text",
        path: "/logs",
      },
    ],

    async onInit(ctx: PluginContext) {
      ctx.logger.info("Custom logger initialized");
    },

    async onRequest(req: Request, app) {
      addLog("info", "Request received", {
        url: req.url,
        method: req.method,
        app: app?.name,
      });

      return req;
    },

    async onResponse(res: Response, app) {
      addLog("info", "Response sent", {
        status: res.status,
        app: app.name,
      });

      return res;
    },
  };
}
----

=== Best Practices

==== Use Dependencies

Declare dependências explícitas para garantir ordem de carregamento:

[source,typescript]
----
export default function createPlugin(): BuntimePlugin {
  return {
    name: "@company/my-plugin",
    dependencies: ["@buntime/plugin-database"],  // Obrigatório
    optionalDependencies: ["@buntime/plugin-metrics"],  // Opcional
  };
}
----

==== Registre Serviços

Exponha funcionalidades para outros plugins via service registry:

[source,typescript]
----
async onInit(ctx) {
  const cache = new CacheService(ctx.config);
  ctx.registerService("cache", cache);
}
----

==== Use Logger com Contexto

Use o logger fornecido para ter contexto automático:

[source,typescript]
----
async onRequest(req: Request, app) {
  ctx.logger.info("Processing request", { url: req.url, app: app?.name });
}
----

==== Graceful Shutdown

Implemente `onShutdown` para cleanup de recursos:

[source,typescript]
----
async onShutdown() {
  await cache.flush();
  await db.close();
  clearInterval(cleanupTimer);
}
----

==== Public Routes

Declare rotas públicas para evitar overhead de autenticação:

[source,typescript]
----
publicRoutes: {
  GET: ["/health", "/metrics"],
  POST: ["/webhook/**"],
}
----

==== Error Handling

Trate erros gracefully nos hooks:

[source,typescript]
----
async onRequest(req: Request) {
  try {
    return await processRequest(req);
  } catch (error) {
    ctx.logger.error("Request processing failed", { error });
    return new Response("Internal Server Error", { status: 500 });
  }
}
----

=== Debugging

==== Logs

Use o logger do plugin para debugging:

[source,typescript]
----
ctx.logger.debug("Cache hit", { key, ttl });
ctx.logger.info("Request processed", { duration });
ctx.logger.warn("Rate limit approaching", { count, limit });
ctx.logger.error("Database error", { error });
----

==== Plugin Registry

Inspecionar plugins carregados:

[source,typescript]
----
const registry = loader.getRegistry();
console.log("Loaded plugins:", registry.getAll().map((p) => p.name));
console.log("Plugin count:", registry.size);
----

==== Dependency Graph

Verificar ordem de carregamento:

[source,bash]
----
# Logs do PluginLoader mostram ordem
[PluginLoader] Loaded: @buntime/plugin-database
[PluginLoader] Loaded: @buntime/plugin-keyval
[PluginLoader] Loaded: @buntime/plugin-metrics
----

==== Service Registry

Verificar serviços registrados:

[source,typescript]
----
const db = ctx.getService<DatabaseAdapter>("database");
if (!db) {
  ctx.logger.error("Database service not available");
}
----

=== Utilitários

==== getShortName

Função utilitária para extrair o nome curto de um plugin a partir do nome completo do pacote. Localizada em `runtime/src/utils/plugins.ts`.

*Assinatura*:

[source,typescript]
----
function getShortName(pluginName: string): string;
----

*Exemplos*:

[source,typescript]
----
import { getShortName } from "@/utils/plugins";

getShortName("@buntime/plugin-keyval");  // "keyval"
getShortName("@buntime/keyval");         // "keyval"
getShortName("@other/plugin-foo");       // "foo"
getShortName("@company/metrics");        // "metrics"
----

*Validação de Segurança*:

A função valida o resultado contra ataques de path traversal. Nomes resultantes devem conter apenas caracteres alfanuméricos e hifens (`[a-z0-9-]+`):

[source,typescript]
----
// Válidos
getShortName("@buntime/plugin-keyval");     // "keyval"
getShortName("@buntime/my-plugin");         // "my-plugin"

// Inválidos (lançam erro)
getShortName("@malicious/../../../etc");    // Error: invalid characters
getShortName("@bad/plugin with spaces");    // Error: invalid characters
----

=== Worker Config Visibility

Workers podem definir uma propriedade `visibility` que controla como aparecem na UI de deployments.

==== Tipos de Visibilidade

[cols="1,2,2"]
|===
| Valor | Descrição | Caso de Uso

| `public`
| Visível e editável na UI (padrão)
| Aplicações normais gerenciadas via UI

| `protected`
| Visível mas somente leitura
| Aplicações que não devem ser editadas acidentalmente

| `internal`
| Oculto da UI
| Serviços internos do runtime (authn, shell)
|===

==== Configuração

*Em buntime.jsonc do app*:

[source,jsonc]
----
{
  "visibility": "internal"
}
----

*Exemplo de app interno*:

[source,jsonc]
----
// apps/authn-app@latest/buntime.jsonc
{
  "entrypoint": "server/index.ts",
  "visibility": "internal"
}
----

*Valor padrão*: Se não especificado, `visibility` é `"public"`.

=== Limitações e Considerações

==== Circular Dependencies

Dependências circulares são detectadas e causam erro:

[source]
----
Plugin A depends on B
Plugin B depends on A
→ Error: Circular dependency detected
----

==== Service Availability

Serviços só estão disponíveis após o plugin que os registra ser inicializado:

[source,typescript]
----
// Plugin A (depende de B)
dependencies: ["plugin-b"]  // Garante que B carrega primeiro

async onInit(ctx) {
  const service = ctx.getService("service-b");  // Sempre disponível
}
----

==== Hook Performance

Hooks `onRequest`/`onResponse` são chamados para cada request. Evite operações pesadas:

[source,typescript]
----
// Evite
async onRequest(req) {
  await heavyDatabaseQuery();  // Adiciona latência
}

// Prefira
async onRequest(req) {
  const cached = cache.get(key);  // Operação rápida
  if (cached) return cached;
}
----

==== Public Routes Precedence

Public routes de plugins têm precedência sobre workers:

[source]
----
Plugin define: /api/health (public)
Worker define: /api/health

→ Plugin handler é executado, worker não recebe request
----
