== Server Core
:toc: left
:toclevels: 3
:sectnums:
:sectnumlevels: 5
:icons: font
:source-highlighter: highlightjs

O núcleo do servidor Buntime é composto por três módulos principais que trabalham em conjunto para inicializar o runtime, carregar plugins e rotear requisições.

=== Arquitetura

[source]
----
runtime/src/
├── index.ts              # Bun.serve entry point
├── api.ts                # Dependency initialization
├── app.ts                # Request resolution, CSRF, shell mode
├── config.ts             # Runtime configuration
├── constants.ts          # Environment variables
├── routes/
│   ├── plugins-info.ts   # /api/plugins
│   └── worker.ts         # /:app/* routes
└── utils/
    ├── request.ts        # Body cloning, size limits, URL rewriting
    ├── serve-static.ts   # Static file serving
    └── ...
----

=== Fluxo de Inicialização

[source]
----
┌─────────────┐
│ constants.ts│ Valida env vars (PORT, NODE_ENV)
└──────┬──────┘
       │
┌──────▼──────┐
│   api.ts    │ Inicializa dependências:
│             │ 1. Logger global
│             │ 2. Carrega buntime.jsonc
│             │ 3. Inicializa config (workspaces, poolSize)
│             │ 4. Cria WorkerPool
│             │ 5. Carrega plugins (PluginLoader)
│             │ 6. Cria rotas (plugins-info, workers)
│             │ 7. Cria app (createApp)
└──────┬──────┘
       │
┌──────▼──────┐
│  index.ts   │ Inicia servidor:
│             │ 1. Bun.serve({ fetch: app.fetch })
│             │ 2. registry.runOnServerStart(server)
│             │ 3. Configura graceful shutdown
└─────────────┘
----

=== Módulos

==== constants.ts

Valida e exporta variáveis de ambiente usando Zod:

[source,typescript]
----
export const { DELAY_MS, NODE_ENV, PORT } = envSchema.parse(Bun.env);
export const IS_COMPILED = typeof BUNTIME_COMPILED !== "undefined" && BUNTIME_COMPILED;
export const IS_DEV = NODE_ENV === "development";
export const VERSION = version;  // from package.json
----

[cols="1,1,2"]
|===
| Variável | Padrão | Descrição

| `PORT`
| 8000
| Porta do servidor HTTP

| `NODE_ENV`
| development
| Ambiente de execução (development, production, staging, test)

| `DELAY_MS`
| 100
| Delay em ms antes de terminar worker (graceful shutdown)
|===

As seguintes constantes são derivadas no código (não são variáveis de ambiente):

[cols="1,1,2"]
|===
| Constante | Valor | Descrição

| `IS_COMPILED`
| false
| Se o runtime foi compilado para binário (detectado via `typeof BUNTIME_COMPILED`)

| `VERSION`
| package.json
| Versão do runtime (lido do package.json)

| `SHUTDOWN_TIMEOUT_MS`
| 30000
| Timeout de graceful shutdown (30s)
|===

Além das variáveis de ambiente, o módulo exporta constantes para uso interno:

[cols="1,2"]
|===
| Constante | Descrição

| `Headers`
| Headers HTTP customizados (x-base, x-fragment-route, x-not-found, x-request-id, sec-fetch-dest, sec-fetch-mode)

| `MessageTypes`
| Tipos de mensagem IPC (READY, REQUEST, RESPONSE, ERROR, IDLE, TERMINATE)

| `BodySizeLimits`
| Limites de tamanho de body (DEFAULT: 10MB, MAX: 100MB)

| `WorkerState`
| Estados do worker (active, idle, ephemeral, offline)
|===

==== config.ts

Combina variáveis de ambiente com configurações do `buntime.jsonc`:

[source,typescript]
----
interface RuntimeConfig {
  bodySize: {
    default: number;       // Limite padrão de body (10MB)
    max: number;           // Limite máximo de body (100MB)
  };
  delayMs: number;         // Rate limit delay
  homepage?: string | HomepageConfig;  // App ou config de homepage
  isCompiled: boolean;     // Se é binário compilado
  isDev: boolean;          // Se está em modo dev
  nodeEnv: string;         // development|production|staging|test
  poolSize: number;        // Tamanho do pool de workers
  port: number;            // Porta do servidor
  version: string;         // Versão do runtime
  workspaces: string[];    // Diretórios de apps (obrigatório)
}
----

===== Inicialização

[source,typescript]
----
// 1. Carrega buntime.jsonc
const { baseDir, config: buntimeConfig } = await loadBuntimeConfig();

// 2. Inicializa config com valores combinados
const runtimeConfig = initConfig(buntimeConfig, baseDir);

// 3. Usa config
console.log(runtimeConfig.workspaces);  // ["/path/to/apps"]
console.log(runtimeConfig.poolSize);    // 100
----

===== Prioridade de Configuração

Para cada campo, a prioridade é:

1. Valor em `buntime.jsonc`
2. Variável de ambiente
3. Padrão do ambiente (para `poolSize`)
4. Padrão hardcoded

[cols="1,1,1,1"]
|===
| Campo | buntime.jsonc | Env Var | Padrão

| `workspaces`
| `workspaces: ["apps"]`
| `WORKSPACES_DIR=/path`
| ERRO (obrigatório)

| `poolSize`
| `poolSize: 200`
| `POOL_SIZE=50`
| 10 (dev), 500 (prod), 50 (staging), 5 (test)

| `homepage`
| `homepage: "cpanel"` ou `homepage: { app: "cpanel", shell: true }`
| `HOMEPAGE_APP=cpanel`
| undefined
|===

Além das variáveis acima, `config.ts` também parseia estas variáveis de ambiente:

[cols="1,1,2"]
|===
| Variável | Padrão | Descrição

| `POOL_SIZE`
| Por ambiente (dev: 10, prod: 500, staging: 50, test: 5)
| Tamanho do pool de workers

| `HOMEPAGE_APP`
| undefined
| App para servir na raiz (formato string apenas via env var)

| `WORKSPACES_DIR`
| ERRO (obrigatório)
| Diretórios de apps (suporta valores separados por vírgula)
|===

===== Resolução de Caminhos

Caminhos relativos em `workspaces` são resolvidos contra o diretório do `buntime.jsonc`:

[source]
----
/project/
├── buntime.jsonc         # workspaces: ["./apps", "/abs/path"]
└── apps/
    └── todos/

Resultado: ["/project/apps", "/abs/path"]
----

Variáveis de ambiente são substituídas usando `substituteEnvVars`:

[source,json]
----
{
  "workspaces": ["${HOME}/apps", "${WORKSPACE}/examples"]
}
----

==== api.ts

Inicializa todas as dependências e exporta o app Hono pronto para uso.

IMPORTANT: Este módulo NÃO inicia o servidor. Ele apenas prepara o app para ser usado por `index.ts` (produção) ou `index.tsx` (dev com frontend).

===== Sequência de Inicialização

[source,typescript]
----
// 1. Logger global
const logger = createLogger({
  format: NODE_ENV === "production" ? "json" : "pretty",
  level: NODE_ENV === "production" ? "info" : "debug",
});
setLogger(logger);

// 2. Carrega buntime.jsonc
const { baseDir, config: buntimeConfig } = await loadBuntimeConfig();

// 3. Inicializa config do runtime
const runtimeConfig = initConfig(buntimeConfig, baseDir);

// 4. Cria pool de workers
const pool = new WorkerPool({ maxSize: runtimeConfig.poolSize });

// 5. Cria resolver de apps
const getAppDir = createAppResolver(runtimeConfig.workspaces);

// 6. Carrega plugins
const loader = new PluginLoader(buntimeConfig, pool);
const registry = await loader.load();

// 7. Cria rotas
const pluginsInfo = createPluginsInfoRoutes({ registry });
const workers = createWorkerRoutes({ config, getAppDir, pool, registry });

// 8. Cria app
const app = createApp({ pluginsInfo, workers, ... });

// 9. Coleta recursos de plugins
const websocket = registry.getWebSocketHandler();
const pluginRoutes = registry.collectServerRoutes();
----

NOTE: Plugins sempre têm prioridade sobre apps regulares quando há conflito de rotas.

===== Exports

[cols="1,2"]
|===
| Export | Descrição

| `app`
| Hono app principal (fetch handler)

| `buntimeConfig`
| Configuração do buntime.jsonc

| `hasPluginRoutes`
| Se há rotas de plugins para Bun.serve

| `logger`
| Logger global instance

| `pluginRoutes`
| Rotas de `server.routes` dos plugins

| `pool`
| WorkerPool instance

| `registry`
| PluginRegistry instance

| `websocket`
| WebSocket handler de plugins (se houver)
|===

NOTE: `runtimeConfig` não é exportado diretamente. Use `buntimeConfig` para acessar a configuração do buntime.jsonc.

==== app.ts

Cria o app Hono principal e implementa a lógica de resolução de rotas, proteção CSRF e roteamento app-shell.

===== Segurança

====== CSRF Protection

O runtime valida requests que modificam estado (POST, PUT, PATCH, DELETE) para prevenir Cross-Site Request Forgery:

[mermaid]
----
flowchart TD
    A[Request state-changing] --> B{Origin header presente?}
    B -->|Não| C{X-Requested-With: XMLHttpRequest?}
    B -->|Sim| D{Origin == Host?}
    C -->|Sim| E[OK]
    C -->|Não| F[403]
    D -->|Sim| G[OK]
    D -->|Não| H[403]
----

Validações realizadas:

1. **Origin obrigatório**: Requests sem Origin recebem 403, exceto se possuírem `X-Requested-With: XMLHttpRequest` (AJAX same-origin)
2. **Origin válido**: URL parsing seguro, rejeita credenciais embutidas (`user:pass@host`)
3. **Protocolo válido**: Apenas `http:` e `https:` aceitos
4. **Host match**: `Origin.host` deve ser igual ao header `Host`

[source,typescript]
----
// Exemplo de request bloqueado
// Origin: https://evil.com
// Host: localhost:8000
// Result: 403 Forbidden

// Exemplo de request permitido (AJAX)
// Origin: (ausente)
// X-Requested-With: XMLHttpRequest
// Result: Prossegue
----

====== Request Correlation

Toda request recebe um ID único para rastreamento:

[source,typescript]
----
// Geração do ID
const requestId = req.headers.get("x-request-id") ?? crypto.randomUUID();

// Incluído em todas as responses
response.headers.set("x-request-id", requestId);
----

O ID aparece em logs para correlacionar eventos:

[source]
----
INFO [app] Request received { requestId: "550e8400-e29b-41d4-a716-446655440000" }
WARN [csrf] Validation failed { requestId: "550e8400-e29b-41d4-a716-446655440000" }
----

====== Body Size Limits

Requests com body grande são rejeitados para prevenir DoS:

[source,typescript]
----
try {
  requestBody = await cloneRequestBody(req, maxBodySize);
} catch (err) {
  if (err instanceof BodyTooLargeError) {
    return new Response("Payload Too Large", { status: 413 });
  }
}
----

Limites configuráveis por worker (veja <<../deployment/configuration.adoc#body-size>>).

===== App-Shell Mode

O runtime suporta arquitetura micro-frontend onde um "shell" envolve múltiplos fragmentos.

====== Configuração

[source,jsonc]
----
// buntime.jsonc
{
  "homepage": {
    "app": "cpanel",   // App que serve como shell
    "shell": true      // Ativa modo app-shell
  }
}
----

====== Fluxo

[mermaid]
----
sequenceDiagram
    participant B as Browser
    participant R as Runtime
    participant S as Shell Worker
    participant F as Fragment Worker

    B->>R: GET /metrics (navigate)
    Note over R: Sec-Fetch-Mode: navigate
    R->>S: Request com x-fragment-route: /metrics
    S->>B: HTML com fragment-outlet

    B->>R: GET /fragment/metrics/
    R->>F: Request para plugin-metrics
    F->>B: Fragment HTML
----

====== Decisão de Roteamento

A função `shouldRouteToShell` determina se uma request vai para o shell:

[cols="2,1,2"]
|===
| Condição | Shell? | Motivo

| `Sec-Fetch-Mode: navigate` + path `/`
| Sim
| Homepage sempre via shell

| `Sec-Fetch-Mode: navigate` + path `/metrics`
| Sim
| Plugin base match

| Path contém `/api/`
| Não
| APIs não passam pelo shell

| `Sec-Fetch-Mode: cors` (fetch interno)
| Não
| Fragment outlet carrega diretamente
|===

====== Headers Injetados

O shell recebe headers especiais para renderizar o fragment correto:

[cols="1,2"]
|===
| Header | Descrição

| `x-fragment-route`
| Path original (ex: `/metrics/workers`)

| `x-not-found`
| `true` se nenhum app foi resolvido (shell decide como exibir 404)

| `x-base`
| Base path do shell para assets
|===

===== Request Resolution Flow

O fluxo de resolução de requests ocorre em etapas ordenadas por prioridade:

[mermaid]
----
flowchart TD
    A[Request arrives] --> B{CSRF check<br/>POST/PUT/PATCH/DELETE}
    B -->|Fail| C[403 Forbidden]
    B -->|Pass| D{App-shell mode?<br/>Sec-Fetch-Mode: navigate}
    D -->|Sim| E[Serve via shell]
    D -->|Não| F["Run onRequest hooks<br/>(auth, metrics, etc.)"]
    F -->|Auth failed| G[401/403]
    F -->|Pass| H{"/api/plugins?"}
    H -->|Sim| I[Plugins info routes]
    H -->|Não| J["Plugin server.fetch"]
    J -->|404?| K["Plugin routes (Hono)"]
    K -->|404?| L["Plugin apps (pool)"]
    L -->|404?| M["Worker routes /:app/*"]
    M -->|404?| N{Shell disponível?}
    N -->|Sim| O[Shell com x-not-found: true]
    N -->|Não| P[404 Not Found]
----

Ordem de execução dentro do handler `app.all("*")`:

1. **CSRF Protection**: Valida requests state-changing (POST, PUT, PATCH, DELETE)
2. **Shell mode**: Se navegação (`Sec-Fetch-Mode: navigate`) e path é plugin base, roteia para shell
3. **onRequest hooks**: Plugins executam autenticação, métricas, rate limiting
4. **Plugins Info**: Rota `/api/plugins` para metadados de plugins
5. **Plugin server.fetch**: Handlers customizados de plugins
6. **Plugin routes (Hono)**: Rotas Hono montadas por plugins
7. **Plugin apps**: Apps de plugins via worker pool
8. **Worker routes**: Apps regulares em workspaces (`/:app/*`)
9. **404 handling**: Shell exibe página de erro ou retorna 404

NOTE: As rotas públicas (configuradas em `publicRoutes`) são verificadas dentro dos hooks `onRequest`, permitindo acesso sem autenticação a endpoints específicos.

===== Resolução de Target App

O `resolveTargetApp` determina qual app irá processar a requisição:

[source,typescript]
----
async function resolveTargetApp(
  pathname: string,
  registry: PluginRegistry,
  getAppDir: (name: string) => string | undefined,
): Promise<ResolvedApp | undefined>
----

Retorna informações sobre o app resolvido:

[source,typescript]
----
interface ResolvedApp {
  type: "plugin" | "worker";     // Tipo do app
  name: string;                   // Nome do app
  dir: string;                    // Diretório do app
  basePath: string;               // Base path (ex: /todos)
  config: WorkerConfig;           // Configuração do worker
}
----

===== Ordem de Resolução

1. **Plugin apps** (via `registry.resolvePluginApp`)
   - Configurados em plugins com `app` option
   - Exemplo: `@buntime/plugin-proxy` com `{ app: "todos", base: "/todos" }`

2. **Worker apps regulares** (pattern `/:app/*`)
   - Apps em diretórios de `workspaces`
   - Exemplo: `apps/todos/` responde em `/todos/*`

===== Semantic Versioning

O runtime suporta versionamento semântico completo de apps através do `createAppResolver`.

====== Formatos de Diretório

O resolver suporta dois formatos de organização:

*Flat (recomendado para deploy)*:

[source]
----
workspace/
├── todos@1.0.0/
├── todos@1.1.0/
├── todos@latest/
└── api@2.0.0/
----

*Nested (recomendado para desenvolvimento)*:

[source]
----
workspace/
├── todos/
│   ├── 1.0.0/
│   ├── 1.1.0/
│   └── latest/
└── api/
    └── 2.0.0/
----

O formato flat é verificado primeiro, permitindo deploy atômico via symlinks ou renames.

====== Resolução de Versão

[cols="2,3"]
|===
| Formato | Comportamento

| `app-name`
| Prefere `@latest` se existir, senão maior versão semver

| `app-name@latest`
| Versão especial "latest" (não-semver)

| `app-name@1`
| Maior versão compatível com 1.x.x

| `app-name@1.4`
| Maior versão compatível com 1.4.x

| `app-name@1.4.2`
| Versão exata

| `app-name@^1.0.0`
| Range semver (compatible)

| `app-name@~1.4.0`
| Range semver (patch updates)

| `app-name@>=2.0.0`
| Range semver (minimum)
|===

====== Pre-release Versions

Pre-releases são incluídos na resolução:

[source]
----
workspace/
├── api@2.0.0-rc.1/
├── api@2.0.0-beta.2/
└── api@2.0.0/

getAppDir("api@^2.0.0-rc")  → api@2.0.0-rc.1
getAppDir("api@2")          → api@2.0.0
----

====== Tag "latest"

O tag `@latest` tem prioridade especial sobre versões semver:

[mermaid]
----
flowchart TD
    A[getAppDir] --> B{version especificada?}
    B -->|"@latest"| C[Retorna diretório @latest]
    B -->|"@1.x"| D[maxSatisfying semver]
    B -->|nenhuma| E{"@latest existe?"}
    E -->|sim| C
    E -->|não| F[Maior versão semver]
----

====== Exemplo de Uso

[source,typescript]
----
const getAppDir = createAppResolver(["/apps", "/external"]);

// Busca em todos os workspaces
getAppDir("todos");           // /apps/todos@latest ou maior semver
getAppDir("todos@1.4");       // /apps/todos@1.4.2 (maior 1.4.x)
getAppDir("api@^2.0.0");      // /external/api@2.1.0

// Retorna string vazia se não encontrar
getAppDir("nonexistent");     // ""
----

NOTE: Workspaces são pesquisados em ordem. O primeiro match prevalece, permitindo overlays de versão.

===== Base Path Injection

Apps servidos sob subpaths recebem o header `x-base` para configurar o router:

[source,typescript]
----
// Plugin app em /todos
const basePath = "/todos";
const newReq = new Request(new URL(pathname + url.search, req.url).href, req);
newReq.headers.set("x-base", basePath);

// Worker recebe:
// GET /todos/api/items
// x-base: /todos
//
// Processa internamente como:
// GET /api/items
----

O worker usa `x-base` para:

1. Configurar `<base href>` em HTML
2. Configurar `basepath` do TanStack Router
3. Gerar URLs absolutas corretas

Exemplo no worker:

[source,typescript]
----
// wrapper.ts injeta base no HTML
const baseTag = `<base href="${base}/">`;
html = html.replace("</head>", `${baseTag}</head>`);

// client/index.tsx lê base tag
const base = document.querySelector("base")?.getAttribute("href") || "/";
const router = createRouter({ basepath: base, ... });
----

===== Fragments

Micro-frontends são servidos através do mecanismo de app-shell. Quando uma navegação ocorre para um path de plugin (ex: `/metrics`), o runtime:

1. Detecta `Sec-Fetch-Mode: navigate` indicando navegação do browser
2. Roteia para o shell worker com headers especiais
3. O shell renderiza o layout com `fragment-outlet`
4. O `fragment-outlet` faz fetch para o path do fragment diretamente

Exemplo:

[source,html]
----
<!-- Shell recebe navegação para /metrics -->
<!-- Headers injetados: x-fragment-route: /metrics, x-base: /cpanel -->

<!-- Shell HTML -->
<fragment-outlet fragment-path="/metrics" />

<!-- Fragment outlet faz fetch interno -->
GET /metrics/ (Sec-Fetch-Mode: cors)

<!-- Plugin @buntime/plugin-metrics responde com HTML -->
<div>Metrics dashboard UI</div>
----

O fragment-outlet é um web component que:

1. Lê o atributo `fragment-path` ou `window.__FRAGMENT_ROUTE__`
2. Faz fetch do conteúdo com `Sec-Fetch-Mode: cors` (evita loop de shell)
3. Injeta o HTML retornado no DOM

===== Plugin Routes Priority

Plugin routes são montadas em ordem de especificidade (mais específica primeiro):

[source,typescript]
----
// Plugins:
// - @buntime/plugin-keyval: /api/keyval
// - @buntime/plugin-metrics: /api/metrics
// - @buntime/plugin-root: /

// Ordem de matching:
const sortedPaths = ["/api/keyval", "/api/metrics", "/"].sort(
  (a, b) => b.length - a.length
);

// Request: /api/keyval/get
// Match: /api/keyval (corresponde)
----

IMPORTANT: Se dois plugins tentarem montar no mesmo path, ocorre erro na inicialização.

==== index.ts

Entry point de produção que inicia o servidor Bun.

===== Configuração do Servidor

O servidor é configurado dinamicamente baseado nos recursos disponíveis:

[source,typescript]
----
const server = Bun.serve({
  fetch: app.fetch,
  idleTimeout: 0,  // Desabilita timeout - necessário para SSE/WebSocket
  port: PORT,
  ...(isDev && { development: { hmr: true } }),
  ...(hasPluginRoutes && { routes: pluginRoutes }),
  ...(websocket && { websocket }),
});
----

[cols="1,2"]
|===
| Opção | Descrição

| `idleTimeout: 0`
| Desabilita timeout de conexões idle. Necessário para SSE (Server-Sent Events) e WebSocket que mantêm conexões de longa duração.

| `development.hmr`
| Ativa Hot Module Replacement em modo development.

| `routes`
| Rotas nativas do Bun.serve (plugin `server.routes`).

| `websocket`
| Handler WebSocket de plugins.
|===

===== Plugin Routes vs Hono Routes

Existem dois tipos de rotas de plugins:

1. **Hono routes** (`plugin.routes`)
   - Hono app montado no app principal
   - Processado via `app.fetch` (sem worker pool)
   - Exemplo: `/api/keyval/*` (REST API)

2. **Server routes** (`plugin.server.routes`)
   - Pattern matching nativo do Bun.serve
   - Processado antes do fetch handler
   - Usado para WebSocket e file serving otimizado

[source,typescript]
----
// Coleta server.routes de todos os plugins
const pluginRoutes = registry.collectServerRoutes();

// Exemplo de server.routes:
{
  "/ws": {
    upgrade: (req, server) => server.upgrade(req),
  },
  "/public/*": {
    fetch: (req) => serveFile(req),
  },
}
----

NOTE: `server.routes` tem performance superior para WebSocket e static files, mas `plugin.routes` (Hono) é mais flexível e suporta autenticação via middleware.

===== Lifecycle Hooks

[source,typescript]
----
// Após servidor iniciar
const server = startServer();
registry.runOnServerStart(server);

// Graceful shutdown com timeout
process.on("SIGINT", async () => {
  logger.info("Shutting down...");

  // Force exit após timeout (30s) para plugins mal comportados
  const forceExitTimer = setTimeout(() => {
    logger.error("Shutdown timeout exceeded, forcing exit");
    process.exit(1);
  }, SHUTDOWN_TIMEOUT_MS);

  try {
    // 1. Notifica plugins
    await registry.runOnShutdown();

    // 2. Encerra workers
    pool.shutdown();

    // 3. Flush de logs
    await logger.flush();

    clearTimeout(forceExitTimer);
    process.exit(0);
  } catch (err) {
    logger.error("Error during shutdown", { error: err });
    clearTimeout(forceExitTimer);
    process.exit(1);
  }
});
----

O timeout de shutdown (30 segundos) previne que plugins mal comportados bloqueiem o encerramento indefinidamente.

===== Hot Module Replacement

Em modo development, HMR é ativado automaticamente:

[source,typescript]
----
const isDev = NODE_ENV === "development";

Bun.serve({
  fetch: app.fetch,
  port: PORT,
  ...(isDev && { development: { hmr: true } }),
});
----

NOTE: HMR funciona apenas para o código do runtime. Workers são recarregados via `pool.reload()`.

=== Uso Programático

O runtime pode ser usado como biblioteca:

[source,typescript]
----
import { createApp } from "@buntime/runtime/app";
import { loadBuntimeConfig, PluginLoader } from "@buntime/runtime/plugins/loader";

// 1. Carrega config
const { config, baseDir } = await loadBuntimeConfig();

// 2. Carrega plugins
const loader = new PluginLoader(config, pool);
const registry = await loader.load();

// 3. Cria app
const app = createApp({ ... });

// 4. Usa em servidor customizado
Bun.serve({ fetch: app.fetch, port: 3000 });
----

=== Boas Práticas

==== DO

* Use `getConfig()` para acessar configuração após inicialização
* Sempre aguarde `registry.shutdown()` antes de encerrar processo
* Use `logger.flush()` antes de sair para garantir que logs sejam escritos
* Configure `workspaces` como array para suportar múltiplos diretórios

[source,typescript]
----
// buntime.jsonc
{
  "workspaces": ["./apps", "./examples", "${HOME}/external-apps"]
}
----

==== DON'T

* Não chame `initConfig()` múltiplas vezes (singleton)
* Não modifique `runtimeConfig` diretamente após inicialização
* Não use `console.log` - sempre use `logger`
* Não inicie `Bun.serve` diretamente em plugins (use hooks)

[source,typescript]
----
// ERRADO
const config = initConfig(buntimeConfig, baseDir);
config.poolSize = 200;  // Não tem efeito

// CORRETO
const config = initConfig(
  { ...buntimeConfig, poolSize: 200 },
  baseDir
);
----

=== Troubleshooting

==== Conflito de Rotas

[source]
----
Error: Route collision: Plugin "plugin-b" cannot mount routes at "/api" -
       already used by "plugin-a"
----

Solução: Configure `base` diferente em um dos plugins:

[source,json]
----
{
  "plugins": [
    ["@buntime/plugin-a", { "base": "/api/a" }],
    ["@buntime/plugin-b", { "base": "/api/b" }]
  ]
}
----

==== Workspaces Not Found

[source]
----
Error: workspaces is required: set in buntime.jsonc or WORKSPACES_DIR env var
----

Solução: Configure `workspaces` no `buntime.jsonc`:

[source,json]
----
{
  "workspaces": ["./apps"]
}
----

==== Worker Pool Exhausted

[source]
----
Warning: Worker pool exhausted (100/100 workers active)
----

Solução: Aumente `poolSize` para seu ambiente:

[source,json]
----
{
  "poolSize": 500
}
----

Ou via env var:

[source,bash]
----
POOL_SIZE=500 bun start
----
