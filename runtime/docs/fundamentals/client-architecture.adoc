== Client Architecture

=== Technology Stack

The admin dashboard is a modern React application built with:

[cols="1,2"]
|===
| Technology | Purpose

| React 19
| UI framework with concurrent features

| TanStack Router
| Type-safe file-based routing

| TanStack Query
| Server state management and caching

| Hono RPC
| End-to-end type-safe API client

| i18next
| Internationalization (en, pt)

| Iconify
| Icon system with virtual registry

| Tailwind CSS
| Utility-first styling

| shadcn/ui
| Component library

| Piercing
| Micro-frontend web components
|===

=== Project Structure

[source]
----
runtime/client/
├── index.tsx                  # Application entry point
├── index.html                 # HTML template with <base> tag
├── routes/                    # File-based routing
│   ├── __root.tsx             # Root layout with providers
│   ├── index.tsx              # Dashboard (/)
│   ├── deployments/           # Deployment manager
│   ├── redirects/             # Proxy rules (plugin-proxy)
│   ├── keyval/                # KeyVal UI (plugin-keyval)
│   ├── metrics/               # Metrics UI (plugin-metrics)
│   ├── durable/               # Durable actors (plugin-durable)
│   ├── authz/                 # Authorization (plugin-authz)
│   ├── gateway/               # Gateway config (plugin-gateway)
│   ├── health/                # Health checks (plugin-health)
│   ├── logs/                  # Logs viewer (plugin-logs)
│   ├── locales/               # Common translations
│   │   ├── en.json
│   │   └── pt.json
│   └── -components/           # Shared route components
├── components/                # Reusable components
│   ├── icon.tsx               # Icon component
│   ├── layouts/               # Layout components
│   └── ui/                    # shadcn/ui components
├── helpers/                   # Core utilities
│   ├── api-client.ts          # Hono RPC clients
│   ├── i18n.ts                # i18next configuration
│   └── query-client.ts        # TanStack Query setup
├── hooks/                     # Custom hooks
│   ├── use-plugins.ts         # Plugin detection
│   └── use-breadcrumbs.ts     # Breadcrumb generation
└── contexts/                  # React contexts
    └── header-context.tsx     # Page header state
----

=== Application Entry Point

==== Base Path Injection

The runtime injects `<base href>` into HTML responses for SPAs under subpaths:

[source,typescript]
----
// Runtime injects: <base href="/cpanel/">

// client/index.tsx reads the base tag
const base = document.querySelector("base");
const url = new URL(base?.href || "http://a.b");

const router = createRouter({
  basepath: url.pathname,  // "/cpanel"
  routeTree,
});
----

This allows the same build to work at any path without hardcoding routes.

==== Initialization Flow

[source,typescript]
----
// 1. Import i18n for side-effect initialization
import "~/helpers/i18n";

// 2. Register piercing web components for micro-frontends
registerPiercingComponents();

// 3. Read base path from <base> tag
const base = document.querySelector("base");
const url = new URL(base?.href || "http://a.b");

// 4. Create router with dynamic basepath
const router = createRouter({
  basepath: url.pathname,
  routeTree,
});

// 5-6. Initialize plugin bases and render app inside async main()
async function main() {
  await initPluginBases();

  const rootElement = document.getElementById("root");
  if (!rootElement) throw new Error("Root element not found");

  createRoot(rootElement).render(
    <StrictMode>
      <RouterProvider router={router} />
    </StrictMode>
  );
}

main();
----

=== File-Based Routing

Routes are generated from the file structure using `@zomme/bun-plugin-tsr`.

==== Route Naming Conventions

[cols="1,2,2"]
|===
| Pattern | File | URL

| Index route
| `routes/index.tsx`
| `/`

| Static route
| `routes/deployments/index.tsx`
| `/deployments`

| Dynamic route
| `routes/durable/$id/index.tsx`
| `/durable/:id`

| Layout route
| `routes/keyval/route.tsx`
| `/keyval/*` (wraps children)

| Private folder
| `routes/keyval/-components/`
| Not a route
|===

==== Route File Structure

Route files MUST export the route definition at the end:

[source,typescript]
----
import { createFileRoute } from "@tanstack/react-router";

function DeploymentsPage() {
  // Component implementation
}

// Route export ALWAYS LAST
export const Route = createFileRoute("/deployments/")({
  component: DeploymentsPage,
});
----

==== Layout Routes

Layout routes (`route.tsx`) wrap child routes:

[source]
----
routes/keyval/
├── route.tsx                  # Layout for /keyval/*
├── index.tsx                  # /keyval
├── entries/index.tsx          # /keyval/entries
└── metrics/index.tsx          # /keyval/metrics
----

[source,typescript]
----
// route.tsx
export const Route = createFileRoute("/keyval")({
  component: KeyvalLayout,
});

function KeyvalLayout() {
  return (
    <div>
      <KeyvalHeader />
      <Outlet />  {/* Child routes render here */}
    </div>
  );
}
----

=== API Client

==== Hono RPC Integration

The client uses Hono's RPC client for end-to-end type safety:

[source]
----
runtime/server/              runtime/client/
┌─────────────────┐          ┌──────────────────┐
│ routes/         │          │ helpers/         │
│  deployments.ts │──────────│  api-client.ts   │
│                 │   Types  │                  │
│ export type     │ ────────▶│ hc<RoutesType>() │
│ DeploymentRoutes│          │                  │
└─────────────────┘          └──────────────────┘
----

Types are inferred automatically from server route definitions.

==== Dynamic Plugin Bases

The API client dynamically discovers plugin base paths:

[source,typescript]
----
// 1. Initialize plugin bases before rendering
export async function initPluginBases(): Promise<void> {
  const res = await fetch(`${API_BASE}/api/plugins`);
  const plugins: PluginInfo[] = await res.json();

  for (const plugin of plugins) {
    const name = plugin.name.replace(/^@[^/]+\//, "").replace(/^plugin-/, "");
    bases[name] = plugin.base ?? `/api/${name}`;
  }
}

// 2. Lazy-initialized clients
export const api = {
  get keyval() {
    return getClient("keyval", () =>
      hc<KeyvalRoutesType>(`${API_BASE}${getBase("keyval")}`)
    );
  },
  get metrics() {
    return getClient("metrics", () =>
      hc<MetricsRoutesType>(`${API_BASE}${getBase("metrics")}`)
    );
  },
  // ... other plugins
};
----

This allows plugins to customize their base path (e.g., `/kv` instead of `/api/keyval`).

==== Usage Pattern

[source,typescript]
----
import { api } from "~/helpers/api-client";

// Type-safe API calls
const res = await api.deployments.list.$get({
  query: { path: "/" }
});

if (!res.ok) throw new Error("Failed to fetch deployments");
const data = await res.json();  // Type: DeploymentResponse
----

No manual type casting needed - types flow from server to client.

=== State Management

==== TanStack Query Setup

Query client is configured with sensible defaults:

[source,typescript]
----
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false,  // Avoid refetch on tab switch
      retry: 1,                      // Retry failed queries once
      staleTime: 1000 * 60,          // 1 minute cache
    },
  },
});
----

==== Query Naming Convention

ALWAYS use `$` suffix for queries to avoid naming conflicts:

[source,typescript]
----
// CORRECT - $ suffix prevents conflicts
const deployments$ = useQuery({
  queryKey: ["deployments", path],
  queryFn: async () => {
    const res = await api.deployments.list.$get({ query: { path } });
    return res.json();
  },
});

{deployments$.isLoading && <Spinner />}
{deployments$.data?.items.map(...)}

// WRONG - destructuring causes conflicts
const { data, isLoading } = useQuery(...);
----

The `$` suffix allows multiple queries in the same component without conflicts.

==== Plugin Detection Hook

Routes conditionally render based on enabled plugins:

[source,typescript]
----
export function usePlugins() {
  return useQuery({
    queryKey: ["plugins"],
    queryFn: async () => {
      const res = await api.plugins.index.$get();
      return res.json() as Promise<PluginInfo[]>;
    },
    staleTime: Infinity,  // Plugins don't change during runtime
  });
}

export function hasPlugin(plugins: PluginInfo[] | undefined, name: string): boolean {
  return plugins?.some((p) => p.name === name) ?? false;
}
----

Usage in navigation:

[source,typescript]
----
const plugins$ = usePlugins();

const navGroups = useMemo(() => {
  const items = [];

  // Dashboard requires plugin-metrics
  if (hasPlugin(plugins$.data, "@buntime/plugin-metrics")) {
    items.push({
      icon: "lucide:gauge",
      title: t("nav.dashboard"),
      url: "/",
    });
  }

  // Deployments is always visible (core feature)
  items.push({
    icon: "lucide:folder",
    title: t("nav.deployments"),
    url: "/deployments",
  });

  // Redirects requires plugin-proxy
  if (hasPlugin(plugins$.data, "@buntime/plugin-proxy")) {
    items.push({
      icon: "lucide:network",
      title: t("nav.redirects"),
      url: "/redirects",
    });
  }

  return [{ label: t("nav.platform"), items }];
}, [plugins$.data, t]);
----

=== Internationalization

==== i18next Setup

i18next is configured with virtual imports from `@zomme/bun-plugin-i18next`:

[source,typescript]
----
import { translations } from "virtual:i18n";
import i18n from "i18next";
import LanguageDetector from "i18next-browser-languagedetector";
import resourcesToBackend from "i18next-resources-to-backend";
import { initReactI18next } from "react-i18next";

i18n
  .use(resourcesToBackend((lng: string, ns: string) => {
    const loader = translations[ns]?.[lng];
    if (!loader) return Promise.reject(new Error(`Translation not found: ${ns}/${lng}`));
    return loader();
  }))
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    defaultNS: "common",
    fallbackLng: "en",
    interpolation: {
      escapeValue: false,
    },
    nonExplicitSupportedLngs: true,
    partialBundledLanguages: true,
    react: {
      useSuspense: false,
    },
    supportedLngs: ["pt", "en"],
    detection: {
      order: ["localStorage", "navigator"],
      lookupLocalStorage: "buntime:language",
      caches: ["localStorage"],
    },
    ns: [
      "common",
      "deployments",
      "keyval",
      "keyval.entries",
      "metrics",
      // ... all namespaces
    ],
  });
----

==== Colocated Translations

Translations live next to routes in `locales/` folders:

[source]
----
routes/
├── locales/                 # namespace: "common"
│   ├── en.json
│   └── pt.json
└── keyval/
    ├── locales/             # namespace: "keyval"
    │   ├── en.json
    │   └── pt.json
    ├── entries/
    │   └── locales/         # namespace: "keyval.entries"
    │       ├── en.json
    │       └── pt.json
    └── index.tsx
----

Usage in components:

[source,typescript]
----
import { useTranslation } from "react-i18next";

function KeyvalEntriesPage() {
  const { t } = useTranslation("keyval.entries");
  const { t: tc } = useTranslation("common");  // Alias for common

  return (
    <div>
      <h1>{t("title")}</h1>
      <button>{tc("actions.save")}</button>
    </div>
  );
}
----

=== Icon System

==== Virtual Icon Registry

Icons are bundled at build time using `@zomme/bun-plugin-iconify`:

[source,typescript]
----
import { registry } from "virtual:icons";

interface IconData {
  body: string;    // SVG body (trusted build-time data)
  height: number;  // Viewbox height
  width: number;   // Viewbox width
}

export function Icon({ icon, ...props }: IconProps) {
  const iconData = typeof icon === "string" ? registry[icon] : icon;

  if (!iconData) return null;  // Missing icons handled silently

  return (
    <svg
      dangerouslySetInnerHTML={{ __html: iconData.body }}
      height="1em"
      width="1em"
      viewBox={`0 0 ${iconData.width} ${iconData.height}`}
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    />
  );
}
----

NOTE: `dangerouslySetInnerHTML` is safe here because icon data comes from the build-time virtual registry (@iconify/json), not user input.

==== Icon Usage

Icons use the format `collection:name`:

[source,typescript]
----
import { Icon } from "~/components/icon";

<Icon icon="lucide:search" className="size-4" />
<Icon icon="lucide:check-circle" className="size-6 text-green-500" />
<Icon icon="heroicons:trash" className="size-5" />
----

Icons are tree-shaken - only used icons are bundled.

=== Root Layout

==== Provider Hierarchy

The root layout wraps the application with necessary providers:

[source,typescript]
----
export const Route = createRootRoute({
  beforeLoad: () => ({ queryClient }),
  component: RootLayout,
});

function RootLayout() {
  return (
    <QueryClientProvider client={queryClient}>
      <HeaderProvider>
        <RootLayoutContent />
        <Toaster />
      </HeaderProvider>
    </QueryClientProvider>
  );
}
----

Provider order:

1. `QueryClientProvider` - TanStack Query
2. `HeaderProvider` - Page header state
3. `RootLayoutContent` - Main layout
4. `Toaster` - Toast notifications

==== Dynamic Navigation

Navigation items are generated based on enabled plugins:

[source,typescript]
----
const navGroups: SidebarNavGroup[] = useMemo(() => {
  const platformItems = [];

  // Conditional menu items based on plugins
  if (hasPlugin(plugins$.data, "@buntime/plugin-metrics")) {
    platformItems.push({
      icon: "lucide:gauge",
      title: t("nav.dashboard"),
      url: "/",
    });
  }

  // Core features always visible
  platformItems.push({
    icon: "lucide:folder",
    title: t("nav.deployments"),
    url: "/deployments",
  });

  return [{ label: t("nav.platform"), items: platformItems }];
}, [plugins$.data, t]);
----

=== Page Header Context

==== Header State Management

Routes can dynamically update the page header:

[source,typescript]
----
// contexts/header-context.tsx
interface HeaderState {
  title?: ReactNode;
  description?: string;
  actions?: ReactNode;
}

export function HeaderProvider({ children }: { children: ReactNode }) {
  const [header, setHeader] = useState<HeaderState | null>(null);

  return (
    <HeaderContext.Provider value={{ header, setHeader }}>
      {children}
    </HeaderContext.Provider>
  );
}
----

Usage in routes:

[source,typescript]
----
import { useHeader } from "~/contexts/header-context";

function DeploymentsPage() {
  const { setHeader } = useHeader();

  useEffect(() => {
    setHeader({
      title: "Deployments",
      description: "Manage application deployments",
      actions: <NewDeploymentButton />,
    });

    return () => setHeader(null);  // Cleanup
  }, [setHeader]);

  return <div>...</div>;
}
----

The root layout renders the header state:

[source,typescript]
----
function RootLayoutContent() {
  const { header } = useHeader();

  return (
    <MainLayout
      header={header ?? undefined}
      // ...
    >
      <Outlet />
    </MainLayout>
  );
}
----

=== Component Patterns

==== Alphabetical Attribute Order

JSX attributes are alphabetical with handlers at the end:

[source,typescript]
----
<Button
  className="w-full"
  disabled={loading}
  size="lg"
  type="button"
  variant="primary"
  onClick={handleClick}
  onFocus={handleFocus}
>
  Submit
</Button>
----

==== Interface Alphabetical Order

Interface properties are alphabetical with handlers at the end:

[source,typescript]
----
interface ComponentProps {
  className?: string;
  description?: string;
  isDisabled?: boolean;
  title: string;
  variant?: "default" | "primary";
  onChange?: (value: string) => void;
  onClick?: () => void;
}
----

Destructuring follows the same order.

==== Component Structure

Components follow a consistent internal structure:

[source,typescript]
----
function MyComponent({ title, description, onChange }: ComponentProps) {
  // 1. State and Hooks
  const [value, setValue] = useState("");
  const { t } = useTranslation("namespace");

  // 2. Derived Variables
  const isValid = value.length > 0;
  const buttonText = isValid ? t("submit") : t("invalid");

  // 3. Handlers and Effects
  const handleSubmit = useCallback(() => {
    onChange?.(value);
  }, [value, onChange]);

  useEffect(() => {
    // Effects
  }, []);

  // 4. Return JSX
  return (
    <div>
      <h1>{title}</h1>
      <p>{description}</p>
      <button onClick={handleSubmit}>{buttonText}</button>
    </div>
  );
}
----

=== Build and Development

==== Build Plugins

The client uses Bun plugins configured in `bunfig.toml`:

[cols="1,2"]
|===
| Plugin | Purpose

| `@zomme/bun-plugin-react-compiler`
| Automatic memoization

| `@zomme/bun-plugin-tsr`
| TanStack Router generation

| `@zomme/bun-plugin-iconify`
| Icon bundling and virtual registry

| `@zomme/bun-plugin-i18next`
| Translation loading and virtual imports

| `bun-plugin-tailwind`
| Tailwind CSS processing
|===

==== Entry Point

The client entry is `client/index.html`:

[source,html]
----
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin</title>
    <!-- <base href> injected by runtime wrapper.ts in production -->
    <!-- In dev mode, no base tag is needed (defaults to /) -->
    <link rel="stylesheet" href="./index.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./index.tsx"></script>
  </body>
</html>
----

The runtime injects `<base href>` dynamically in production based on proxy rules. In development mode, no base tag is needed and the app defaults to `/`.

==== Path Aliases

[cols="1,2"]
|===
| Alias | Resolves To

| `~/`
| `./client/`

| `@/`
| `./server/`
|===

Usage:

[source,typescript]
----
import { api } from "~/helpers/api-client";       // client/helpers/api-client.ts
import { Icon } from "~/components/icon";         // client/components/icon.tsx
import type { AppConfig } from "@/types/config";  // server/types/config.ts
----

=== Micro-Frontend Support

==== Piercing Web Components

The dashboard supports micro-frontends via Piercing:

[source,typescript]
----
import { registerPiercingComponents } from "@buntime/piercing/client";

// Register before router creation
registerPiercingComponents();
----

This allows embedding other SPAs as web components:

[source,tsx]
----
<piercing-root
  src="https://external-app.com"
  base="/external"
  style={{ height: "100vh" }}
/>
----

The web component handles:

- Base path injection
- Message passing
- Iframe sandboxing
- Loading states

=== Performance Considerations

==== Code Splitting

Routes are automatically code-split by TanStack Router:

- Each route bundle loads on demand
- Shared components are deduplicated
- Common chunks extracted automatically

==== Query Caching

TanStack Query caches responses for 1 minute:

[source,typescript]
----
{
  queries: {
    staleTime: 1000 * 60,  // 1 minute
    retry: 1,               // Retry failed queries once
  }
}
----

Plugin data is cached indefinitely:

[source,typescript]
----
useQuery({
  queryKey: ["plugins"],
  staleTime: Infinity,  // Plugins don't change during runtime
});
----

==== Icon Tree-Shaking

Only used icons are bundled:

[source]
----
// Build scans for Icon usage
<Icon icon="lucide:search" />

// Only lucide:search data is bundled
registry = {
  "lucide:search": { body: "...", width: 24, height: 24 }
}
----

Missing icons show build warnings but don't break the app.

=== Testing Considerations

==== Component Tests

Use co-located tests for components:

[source]
----
components/
├── icon.tsx
└── icon.test.tsx
----

==== Route Tests

Route tests go in `tests/client/routes/`:

[source]
----
tests/
└── client/
    └── routes/
        └── deployments.test.tsx
----

==== API Mocking

Mock Hono RPC clients in tests:

[source,typescript]
----
import { api } from "~/helpers/api-client";

vi.mock("~/helpers/api-client", () => ({
  api: {
    deployments: {
      list: {
        $get: vi.fn(() => Promise.resolve({
          ok: true,
          json: () => Promise.resolve({ items: [] })
        }))
      }
    }
  }
}));
----
